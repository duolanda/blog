(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{1121:function(e,t,a){"use strict";a.r(t);var _=a(11),s=Object(_.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"_1-stl-体系结构基础介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-stl-体系结构基础介绍"}},[e._v("#")]),e._v(" 1.STL 体系结构基础介绍")]),e._v(" "),_("h2",{attrs:{id:"_1-1-认识-headers、版本、重要资源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-认识-headers、版本、重要资源"}},[e._v("#")]),e._v(" 1.1 认识 headers、版本、重要资源")]),e._v(" "),_("ul",[_("li",[e._v("Generic Programming（GP，泛型编程），使用template模板为主要工具来编写程序。")]),e._v(" "),_("li",[e._v("STL 是泛型编程最成功的作品。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(832),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("C++标准库（C++ Standard Library）；C++标准库 .h 文件编译器自带，可以看到源代码")]),e._v(" "),_("li",[e._v("可以认为标准库中 70% 都是 STL，二者是包含关系")]),e._v(" "),_("li",[e._v("新式 include C header 的写法是把 .h 去掉，开头加上 c，如"),_("code",[e._v("#include<stdio.h>")]),e._v("写成"),_("code",[e._v("#include<cstdio>")])]),e._v(" "),_("li",[e._v("新式头文件都封装在 std 名称空间中，"),_("code",[e._v("using namespace std;")])])]),e._v(" "),_("h2",{attrs:{id:"_1-2-stl-体系结构基础介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-stl-体系结构基础介绍"}},[e._v("#")]),e._v(" 1.2 STL 体系结构基础介绍")]),e._v(" "),_("h2",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")]),e._v(" "),_("img",{attrs:{src:a(833),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("STL六大部件\n"),_("ul",[_("li",[e._v("容器（Container）")]),e._v(" "),_("li",[e._v("分配器（Allocators）")]),e._v(" "),_("li",[e._v("算法（Algorithms）")]),e._v(" "),_("li",[e._v("迭代器（Iterators）")]),e._v(" "),_("li",[e._v("适配器（Adapters）")]),e._v(" "),_("li",[e._v("仿函数（Functors）")])])]),e._v(" "),_("li",[e._v("容器帮我们把内存的事情都解决掉，所以背后要有分配器来支持；有一些操作是容器里面做的，还有更多东西独立出来，成为算法；算法为了处理容器里的内容，需要有访问的方式，这个桥梁就是迭代器（可以认为是泛化的指针）；仿函数的作用像是函数；适配器可以帮我们做一些转换，容器、仿函数、迭代器都可以做转换")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(834),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("其实大部分人都可以不用操心分配器，因为容器的源码里默认参数会指明分配器，这里为了教学才写出来")]),e._v(" "),_("li",[_("code",[e._v("count_if")]),e._v(" 算法帮我们计算符合条件的元素有几个，这里是计算大于等于 40 的元素有几个；为了告诉它元素的范围，我们用迭代器给它头和尾；我们找到了仿函数 "),_("code",[e._v("less")]),e._v("，并用适配器"),_("code",[e._v("bind2nd")]),e._v("将第二参数绑定为 40；"),_("code",[e._v("not1")]),e._v(" 适配器是反义，会判断是否大于等于 40，返回 true false。\n"),_("ul",[_("li",[e._v("最后代码输出为 4")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(835),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("标准库采用前闭后开区间")]),e._v(" "),_("li",[_("code",[e._v("begin()")]),e._v(" 要指向第一个元素，"),_("code",[e._v("end()")]),e._v(" 不是指向最后一个元素，而是指向最后一个元素的下一个位置")]),e._v(" "),_("li",[e._v("因为迭代器是泛化的指针，所以指针能做的迭代器都能做，ite 可以 "),_("code",[e._v("++``--``*``->")]),e._v("，上面的例子是习惯的遍历写法")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(836),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("现在更推荐这种新写法（range-based for statement）")])]),e._v(" "),_("h1",{attrs:{id:"_2-容器分类与各种测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-容器分类与各种测试"}},[e._v("#")]),e._v(" 2.容器分类与各种测试")]),e._v(" "),_("h2",{attrs:{id:"_2-1-结构与分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-结构与分类"}},[e._v("#")]),e._v(" 2.1 结构与分类")]),e._v(" "),_("p",[_("img",{attrs:{src:a(837),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("容器分为序列式容器（Sequence Containers）、关联式容器（Associative Containers）。无序容器（Unordered Containers）其实也算是关联式容器")]),e._v(" "),_("li",[e._v("红色框代表是 C++11 新增的")]),e._v(" "),_("li",[e._v("序列式容器\n"),_("ul",[_("li",[e._v("Array 是把语言中的数组包装为 class")]),e._v(" "),_("li",[e._v("Vector 在空间不够时会自动扩充")]),e._v(" "),_("li",[e._v("Deque 双向队列，前后都可扩充")]),e._v(" "),_("li",[e._v("List 链表，每个元素用双向指针连接")]),e._v(" "),_("li",[e._v("Forward-List 单向链表，比 List 更省内存（少一个指针就省 4 个字节）")])])]),e._v(" "),_("li",[e._v("关联式容器\n"),_("ul",[_("li",[e._v("能够高速查找，底层用红黑树实现（一种自平衡二叉查找树）")]),e._v(" "),_("li",[e._v("Set 不分 key 和 value，Map 的每一个节点有 key 和 value")]),e._v(" "),_("li",[e._v("Set 和 Map 的 key 都不能重复，但 Multiset 和 Multimap 可以")]),e._v(" "),_("li",[e._v("无序容器的底层实现是 HashTable，标准库的实现方式是 Separate Chaining（分离链接法），将具有同一个 hash 值的 key 存到一个链表中，解决碰撞（冲突）")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(838),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("以下是后面测试程序会用到的辅助函数")]),e._v(" "),_("li",[_("code",[e._v("get_a_target_long()")]),e._v("用交互方式让使用者输入要查找的元素；"),_("code",[e._v("get_a_target_string()")]),e._v("把输入的数字转成字符串，为了体现实际使用中容器不会只存储数值；"),_("code",[e._v("compareLongs()")]),e._v("和"),_("code",[e._v("compareStrings()")]),e._v("比较 long 或字符串的大小，未来传给 qsort 快速排序函数使用。")])]),e._v(" "),_("h2",{attrs:{id:"_2-2-序列式容器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-序列式容器"}},[e._v("#")]),e._v(" 2.2 序列式容器")]),e._v(" "),_("h3",{attrs:{id:"_2-2-1-array"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-array"}},[e._v("#")]),e._v(" 2.2.1 array")]),e._v(" "),_("p",[_("img",{attrs:{src:a(839),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("ASIZE 告诉 array 数组长度为五十万（这个参数不能省略）")]),e._v(" "),_("li",[_("code",[e._v("array.data()")]),e._v("会返回这个数组在内存中的起点地址")]),e._v(" "),_("li",[_("code",[e._v("qsort()")]),e._v(" 的四个参数：起点地址、多少个元素、每个元素大小、怎么比大小")]),e._v(" "),_("li",[e._v("使用二分查找之前一定要先排序")])]),e._v(" "),_("h3",{attrs:{id:"_2-2-2-vector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-vector"}},[e._v("#")]),e._v(" 2.2.2 vector")]),e._v(" "),_("p",[_("img",{attrs:{src:a(840),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("插入一百万个数据")]),e._v(" "),_("li",[e._v("只有"),_("code",[e._v("push_back()")]),e._v("，插入到数据尾部，因为只能往后扩展。每次"),_("code",[e._v("push_back")]),e._v("申请的空间以两倍增长，会申请预留空间；size 是大小，capacity 是申请的内存空间大小（两倍增长那个）。")]),e._v(" "),_("li",[e._v("try 和 catch 捕获异常，以防输入测试数量过大，内存空间不足")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(841),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("找 23456 没什么特殊意义，随便打的数")]),e._v(" "),_("li",[_("code",[e._v("find()")]),e._v("是标准库的算法，模板函数，按顺序查找。不加"),_("code",[e._v("::")]),e._v("编译器也会自动从全局找，写上是为了更清晰")]),e._v(" "),_("li",[_("code",[e._v("sort()")]),e._v("是 C++ 标准库提供的，"),_("code",[e._v("bsearch()")]),e._v("是 C 库里的")])]),e._v(" "),_("h3",{attrs:{id:"_2-2-3-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-list"}},[e._v("#")]),e._v(" 2.2.3 list")]),e._v(" "),_("p",[_("img",{attrs:{src:a(842),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("list 每次"),_("code",[e._v("push_back")]),e._v("只需在空间中找一个节点大小\n"),_("ul",[_("li",[e._v("相比之下 vector 每次扩充不光要先开出两倍的空间，还要把之前的数据都移到新的空间，步骤更多")])])]),e._v(" "),_("li",[e._v("list 有"),_("code",[e._v("max_size()")]),e._v("， forward_list 和 deque 也有。为什么会有 max_size()？后面我们再看")]),e._v(" "),_("li",[e._v("这里使用的不是全局的"),_("code",[e._v("sort()")]),e._v("，而是 list 容器自己的"),_("code",[e._v("sort()")]),e._v("当容器自己提供"),_("code",[e._v("sort()")]),e._v("的时候，建议使用自带的")])]),e._v(" "),_("h3",{attrs:{id:"_2-2-4-forward-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-forward-list"}},[e._v("#")]),e._v(" 2.2.4 forward_list")]),e._v(" "),_("p",[_("img",{attrs:{src:a(843),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("没有"),_("code",[e._v("push_back()")]),e._v("，只有"),_("code",[e._v("push_front()")]),e._v("，因为是单向的，只能在头部插入元素")]),e._v(" "),_("li",[e._v("在 C++11 之前还有"),_("code",[e._v("slist")]),e._v("，不在标准规范中，用法等完全相同")])]),e._v(" "),_("h3",{attrs:{id:"_2-2-5-deque"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-deque"}},[e._v("#")]),e._v(" 2.2.5 deque")]),e._v(" "),_("p",[_("img",{attrs:{src:a(844),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("这张图详细描述了它的结构")]),e._v(" "),_("li",[e._v("可以发现 deque 是分成一段一段的，每段内部是连续的，即分段连续，使用者感觉起来会是连续的")]),e._v(" "),_("li",[e._v("空间用完时，每次会扩充一个 buffer，相比之下 vector 的扩充可能会有很大的浪费")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(845),alt:"image.png"}})]),e._v(" "),_("h3",{attrs:{id:"_2-2-6-stack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-6-stack"}},[e._v("#")]),e._v(" 2.2.6 stack")]),e._v(" "),_("p",[_("img",{attrs:{src:a(846),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("deque 涵盖 stack 和 queue，源代码也是如此，stack 和 queue 内部其实都是用 deque 实现的")]),e._v(" "),_("li",[e._v("因为这两个容器没有自己的数据结构，所以很多人在技术上不认为这两个是容器，而是将它们称为容器适配器")]),e._v(" "),_("li",[e._v("stack 先进后出，queue 先进先出")]),e._v(" "),_("li",[e._v("不提供 iterator，因为可能会破坏先进先出或先进后出的机制，所以这里没有示范"),_("code",[e._v("find()")])])]),e._v(" "),_("h2",{attrs:{id:"_2-3-关联式容器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-关联式容器"}},[e._v("#")]),e._v(" 2.3 关联式容器")]),e._v(" "),_("h3",{attrs:{id:"_2-3-1-multiset"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-multiset"}},[e._v("#")]),e._v(" 2.3.1 multiset")]),e._v(" "),_("p",[_("img",{attrs:{src:a(847),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("因为一百万次极大概率会出现重复数据，所以测试 multiset")]),e._v(" "),_("li",[e._v("数据并不是插入到头或尾，而是根据一定规则插入（自动排序），不需要用户操心")]),e._v(" "),_("li",[e._v("自己的"),_("code",[e._v("find()")]),e._v("比全局"),_("code",[e._v("find()")]),e._v("快很多，是 0，可见关联式容器查找速度很快，相应地在数据插入时会慢一些")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-2-multimap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-multimap"}},[e._v("#")]),e._v(" 2.3.2 multimap")]),e._v(" "),_("p",[_("img",{attrs:{src:a(848),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("insert()")]),e._v("时要自己用 pair 把 key 和 value 组合起来")]),e._v(" "),_("li",[e._v("用容器自己的"),_("code",[e._v("find()")]),e._v("，同样很快")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-3-unordered-multiset"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-3-unordered-multiset"}},[e._v("#")]),e._v(" 2.3.3 unordered_multiset")]),e._v(" "),_("p",[_("img",{attrs:{src:a(849),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("bucker_count()")]),e._v("桶的数量，桶的数量一定比现有元素数量还多，因为每个桶出去的链表不能太长，如果元素数量 >= 桶的数量，桶的数量就会扩充到原来的两倍（原有元素也会重新打散分配）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(850),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("同样的，自己的"),_("code",[e._v("find()")]),e._v("很快")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-4-unordered-multimap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-4-unordered-multimap"}},[e._v("#")]),e._v(" 2.3.4 unordered_multimap")]),e._v(" "),_("p",[_("img",{attrs:{src:a(851),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("没什么好说的")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-5-set"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-5-set"}},[e._v("#")]),e._v(" 2.3.5 set")]),e._v(" "),_("p",[_("img",{attrs:{src:a(852),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("key 不可以重复，真正放进去的数据不会有一百万个，图中显示，只有 32768（随机数产生刚好是 0~32767）")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-6-map"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-6-map"}},[e._v("#")]),e._v(" 2.3.6 map")]),e._v(" "),_("p",[_("img",{attrs:{src:a(853),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("multimap 不可以用"),_("code",[e._v("[]")]),e._v("做插入，但 map 可以："),_("code",[e._v("c[i]=string(buf);")]),e._v("，i 和 map 会自动合成 pair")]),e._v(" "),_("li",[e._v("map 真正放进去的数据依然有一百万个，因为 key 其实没有重复，只有 value 重复了")])]),e._v(" "),_("h3",{attrs:{id:"_2-3-7-unordered-set-和-unordered-map"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-7-unordered-set-和-unordered-map"}},[e._v("#")]),e._v(" 2.3.7 unordered_set 和 unordered_map")]),e._v(" "),_("p",[_("img",{attrs:{src:a(854),alt:"image.png"}})]),e._v(" "),_("p",[_("img",{attrs:{src:a(855),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("底层为哈希表，没有什么可说的")])]),e._v(" "),_("h2",{attrs:{id:"_2-4-其他补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-其他补充"}},[e._v("#")]),e._v(" 2.4 其他补充")]),e._v(" "),_("ul",[_("li",[e._v("还有叫作 priority_queue 和 heap 的容器，一个是用的比较少，二是底层实现为其他容器，所以这里不做测试")]),e._v(" "),_("li",[e._v("早期有 hash_set、hash_map、hash_multiset、hash_multimap，（现在改名为 unordered_... 后加入到标准库了）就像 slist 一样，如果你想让使用它们的旧程序依然可以正常编译，需要在导入头文件时加上 ext，如"),_("code",[e._v("#include <ext\\slist>")])])]),e._v(" "),_("h1",{attrs:{id:"_3-分配器测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-分配器测试"}},[e._v("#")]),e._v(" 3.分配器测试")]),e._v(" "),_("p",[_("img",{attrs:{src:a(856),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("不同编译器的分配器设计可能有所不同")]),e._v(" "),_("li",[e._v("每个容器类都有默认的容器分配器（红色部分）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(857),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("以上是 gcc 编译器的测试代码")]),e._v(" "),_("li",[e._v("测试中选择 list 作为容器，搭配不同的分配器，这些分配器定义在"),_("code",[e._v("__gnu:cxx")]),e._v("命名空间下")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(858),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以自行调用"),_("code",[e._v("allocate()")]),e._v("和"),_("code",[e._v("deallocate()")]),e._v("，但没有必要。尽量使用容器，容器之外小量内存申请就用 new、delete 或 malloc、free；不需要记住当时申请内存的大小，这才是对的、好的。直接用分配器在释放（"),_("code",[e._v("deallocate()")]),e._v("）的时候不仅需要指针，还要指明申请时的大小，记忆负担重，并不好用")])]),e._v(" "),_("h1",{attrs:{id:"_4-源码分布及技术基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-源码分布及技术基础"}},[e._v("#")]),e._v(" 4.源码分布及技术基础")]),e._v(" "),_("h2",{attrs:{id:"_4-1-源码分布"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-源码分布"}},[e._v("#")]),e._v(" 4.1 源码分布")]),e._v(" "),_("p",[_("img",{attrs:{src:a(859),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("vc 很直白，gcc 更复杂一些")])]),e._v(" "),_("h2",{attrs:{id:"_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程"}},[e._v("#")]),e._v(" 4.2 OOP(Object-Oriented programming，面向对象编程) vs. GP(Genic Programming，泛型编程)")]),e._v(" "),_("p",[_("img",{attrs:{src:a(860),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("许多大型 OOP 库会有很复杂的继承关系，很多虚函数，标准库中则很少有这种构造")]),e._v(" "),_("li",[e._v("OOP = 数据 + 操作")]),e._v(" "),_("li",[e._v("list 类中有自己的"),_("code",[e._v("sort()")]),e._v(" "),_("ul",[_("li",[e._v("原因是能够符合"),_("code",[e._v("first+(last-first/2)")]),e._v("中 + - / 运算的迭代器一定是 RandomAccessIterator（随机访问迭代器），而 list 在内存中是不连续的，它具备的迭代器只能向前或向后走，不能跳到特定的位置，所以 list 不能使用全局的 sort 排序")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(861),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("GP 是将 data 和 method 分开来。")]),e._v(" "),_("li",[e._v("vector 和 deque 类中都没有排序的操作，操作被单独的设计到一个全局的"),_("code",[e._v("sort()")]),e._v("函数中，使用时通过迭代器传入头尾")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(862),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("GP 有以下两个好处：\n"),_("ul",[_("li",[e._v("Container 和 Alogorithm 团队可以各自闭门造车，然后用 iterator 沟通即可")]),e._v(" "),_("li",[e._v("Alogorithm 通过 Iterator 确定操作范围，并通过 Iterator 取用 Continer 元素")])])]),e._v(" "),_("li",[e._v("如右上角的例子，函数只负责返回 a 和 b 里更小的那一个，至于 a 和 b 怎么比大小，应该是 a 和 b 的那种东西去定（它俩肯定是一种东西），这个思路也代表着操作符重载很重要")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(863),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("所谓算法，其内最终设计元素本身的操作，无非就是比大小。找一个东西是相等，不小于也不大于就是等于，排序也是类似的道理")]),e._v(" "),_("li",[_("code",[e._v('max(string("zoo"), string("hello"))')]),e._v("调用的是第一个版本的"),_("code",[e._v("max()")]),e._v("，字符串对于"),_("code",[e._v("<")]),e._v("的定义是，b 比 a 大，c 比 b 大，z 最大，不管长度，所以输出是 zoo 更大")]),e._v(" "),_("li",[_("code",[e._v('max(string("zoo"), string("hello", strLonger))')]),e._v("使用了自己的比较方式，根据长度比大小，调用"),_("code",[e._v("max()")]),e._v("的第二个版本，得出 hello 更大")])]),e._v(" "),_("h2",{attrs:{id:"_4-3-技术基础-操作符重载和模板"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-技术基础-操作符重载和模板"}},[e._v("#")]),e._v(" 4.3 技术基础（操作符重载和模板）")]),e._v(" "),_("h3",{attrs:{id:"_4-3-1-操作符重载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-操作符重载"}},[e._v("#")]),e._v(" 4.3.1 操作符重载")]),e._v(" "),_("p",[_("img",{attrs:{src:a(864),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(865),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("第一页总结的很好")]),e._v(" "),_("li",[e._v("第二页的限制不需要记，写的时候翻资料即可")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(866),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("这个是链表迭代器的代码")])]),e._v(" "),_("h3",{attrs:{id:"_4-3-2-模板"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-模板"}},[e._v("#")]),e._v(" 4.3.2 模板")]),e._v(" "),_("p",[e._v("模板分为三大类：类模板，函数模板，成员模板\n"),_("img",{attrs:{src:a(867),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("类模板")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(868),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("函数模板")]),e._v(" "),_("li",[e._v("这里的 class 可以写成 typename，class 是早期的写法")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(869),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("成员模板")]),e._v(" "),_("li",[e._v("后面我们的标准库源代码暂时看不到这个，所以不讲")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(870),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("特化的语法 "),_("code",[e._v("template<> struct __type_traits<int>")]),e._v("，由于泛化的 T 已经绑定为 int 了，所以后面要写上 int，前面的 template<> 中是空的")])]),e._v(" "),_("div",{staticClass:"language-cpp line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-cpp"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//泛化")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("template")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typename")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("T")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("__type_traits")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//特化")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("template")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("__type_traits")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br"),_("span",{staticClass:"line-number"},[e._v("6")]),_("br"),_("span",{staticClass:"line-number"},[e._v("7")]),_("br")])]),_("p",[_("img",{attrs:{src:a(871),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("__STL_TEMPLATE_NULL")]),e._v(" 就是 "),_("code",[e._v("template<>")]),e._v("，所以看到它出现就意味着要特化了")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(872),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("上面的特化也可以称为全特化")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(873),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("有两个模板参数，绑定其中一个")]),e._v(" "),_("li",[e._v("右边的例子是范围上的“偏”，范围限定为指针")])]),e._v(" "),_("h1",{attrs:{id:"_5-分配器源码分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-分配器源码分析"}},[e._v("#")]),e._v(" 5.分配器源码分析")]),e._v(" "),_("p",[e._v("幕后英雄，分配器好不好影响容器的性能好不好\n"),_("img",{attrs:{src:a(874),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("operator new()")]),e._v("底层都会调用到"),_("code",[e._v("malloc()")])]),e._v(" "),_("li",[_("code",[e._v("malloc()")]),e._v("分配出的内存如右图所示。用户要求的大小是浅蓝色部分（size），"),_("code",[e._v("malloc()")]),e._v("实际分配了更多的东西，细节会在内存管理课讲\n"),_("ul",[_("li",[e._v("附加的部分大小几乎是差不多的，所以你要求分配的空间越大，附加部分所占比例越小")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(875),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("这里列举了四个容器，其他也差不多，它们默认的分配器都是"),_("code",[e._v("allocator")]),e._v("，所以下面我们将分析"),_("code",[e._v("allocator")]),e._v("的源码")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(876),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("分配器最重要的两个函数："),_("code",[e._v("allocate()")]),e._v("和"),_("code",[e._v("deallocate()")]),e._v("，而"),_("code",[e._v("allocate()")]),e._v("调用的是"),_("code",[e._v("operator new()")]),e._v("，"),_("code",[e._v("operator new()")]),e._v("调用的是"),_("code",[e._v("malloc()")]),e._v(";"),_("code",[e._v("deallocate()")]),e._v("调用"),_("code",[e._v("operator delete()")]),e._v("，最终调用"),_("code",[e._v("free()")])]),e._v(" "),_("li",[e._v("可见，VC6 的 allocator 只是用"),_("code",[e._v("operator new()")]),e._v("和"),_("code",[e._v("operator delete()")]),e._v("完成"),_("code",[e._v("allocate()")]),e._v("和"),_("code",[e._v("deallocate()")]),e._v("，没有任何特殊设计")]),e._v(" "),_("li",[e._v("我们通常放的元素都不大，像 string 只有四字节，而这就意味着额外开销（malloc 多分配的内容）很大，甚至有可能比元素本身还大，如果元素有几百万个，会是很可怕的事情，但 vc 就是这么做的")]),e._v(" "),_("li",[e._v("右下角的代码证明我们也可以直接调用分配器，但不鼓励，因为没有人有心思记当时分配的内存有多大，大家只会记指针。但是容器去用没有问题，未来讲细节")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(877),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(878),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("gcc 2.9 直接写出，虽然实现了分配器，但是容器并没有用这个实现的分配器，可以看出，容器用的是 alloc 分配器而不是 allocator")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(879),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("gcc 的 alloc 分配器源码将在内存管理课上分析")]),e._v(" "),_("li",[e._v("思路是尽量减少"),_("code",[e._v("malloc()")]),e._v("次数，设计了 16 条链表，每条链表负责特定大小的区块，如链表 0 负责八字节大小，链表 7 负责六十四字节大小。容器的大小会被调整到 8 的倍数大小，如 60 会调整到 64，分配器 "),_("code",[e._v("malloc()")]),e._v(" 一大块内存，每块用单向链表做切割，切出来的每一块都不带 cookie（额外开销主要体现在 cookie 上，cookie 消耗 8 个字节）")]),e._v(" "),_("li",[e._v("它也有缺点，内存管理时讲")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(880),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(881),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("gcc 4.9 （不一定是 4.9 开始，可能之前就改了）中容器又改用了另一个分配器。变成和 vc 的情况差不多了，直接 "),_("code",[e._v("malloc()")])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(882),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("根据源代码，gcc 4.9 提供的众多 extension allocators 中的 __pool_allocate 就是之前 gcc 2.9 的 alloc")]),e._v(" "),_("li",[e._v("如果想使用它，把它指定为容器的第二个模板参数即可 "),_("code",[e._v("vector<string, __gnu_cxx::__pool_alloc<string>> vec;")])])]),e._v(" "),_("h1",{attrs:{id:"_6-容器源码分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-容器源码分析"}},[e._v("#")]),e._v(" 6.容器源码分析")]),e._v(" "),_("h2",{attrs:{id:"_6-1-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-list"}},[e._v("#")]),e._v(" 6.1 list")]),e._v(" "),_("p",[_("img",{attrs:{src:a(883),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("不是最简单的，但是是最具代表性的")]),e._v(" "),_("li",[e._v("容器大小，指的是本身控制操作所需的大小（如需要几根指针），与控制的数据多少无关")]),e._v(" "),_("li",[e._v("整个 list 里的数据只有一个：node，是 list_node 指针，大小为 4 字节，所以 gcc 2.9 里 list 的大小就是 4")]),e._v(" "),_("li",[e._v("list_node 有三个变量，向前指的指针、向后指的指针、数据，因此算占用内存的时候不能只计算数据大小，还要加上两个指针")]),e._v(" "),_("li",[e._v("为了满足前闭后开，最后一个元素并非指向第一个元素，而是指向一个空白节点，"),_("code",[e._v("begin()")]),e._v("返回的是第一个节点，"),_("code",[e._v("end()")]),e._v("返回的是最后一个元素后面的空白节点")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(884),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("除了 array 和 vector，其他容器的 iterator 都要是 class 才能设计出聪明的动作，比方说 list 的 iterator++ 需要改成去找 next 指针，而不是真的直接找下一个内存地址")]),e._v(" "),_("li",[e._v("所有容器的 iterator 都会有一大堆的 typedef 和一大组操作符重载")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(885),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("++")]),e._v("分为前置和后置的，"),_("code",[e._v("++i")]),e._v("是前置，"),_("code",[e._v("i++")]),e._v("是后置，为了区分，带参数的"),_("code",[e._v("operator++(int)")]),e._v("为后置，"),_("code",[e._v("operator++()")]),e._v("为前置；")]),e._v(" "),_("li",[e._v("先看前置 ++ 的"),_("code",[e._v("operator++()")]),e._v("，取出 node 指的 next 的值并赋给 node")]),e._v(" "),_("li",[e._v("再看后置 ++ 的"),_("code",[e._v("operator++(int)")]),e._v("，先记住原来的值，然后进行++操作，最后返回原值。第一步里的"),_("code",[e._v("self tmp = *this;")]),e._v("并不会唤起 * 的重载，而是先来到被重载的 =，即拷贝构造，"),_("code",[e._v("*this")]),e._v("被解释为拷贝构造函数的参数。第二步的 ++ 唤起前 ++ 的 "),_("code",[e._v("operator++()")])]),e._v(" "),_("li",[e._v("在重载 ++ 时，设计者会向整数的 ++ 看齐，C++ 不允许后置 ++ 两次，即整数不可以"),_("code",[e._v("i++++")]),e._v("，所以 iterator 的"),_("code",[e._v("operator++(int)")]),e._v("为了阻止两次 ++，返回的是数值 self，而非前 ++ 的引用 self&")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(886),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("除了 ++ --，另一个很重要的动作是获取数值")]),e._v(" "),_("li",[_("code",[e._v("*")]),e._v("，使用者想要取得 data，所以返回"),_("code",[e._v("(*node).data")])]),e._v(" "),_("li",[_("code",[e._v("->")]),e._v("，思路类似，右侧有说明")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(887),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("刚才看 gcc 2.9 的一些细节有点奇怪，一个是"),_("code",[e._v("__list_node")]),e._v("中向前向后的指针类型都是"),_("code",[e._v("void*")]),e._v("，还有就是"),_("code",[e._v("__list_iterator")]),e._v("要传三个参数，按道理来说只传一个 T（数据本身类型）就够了，第二个和三个在函数里生成即可")]),e._v(" "),_("li",[e._v("这里将 2.9 和 4.9 的代码上下并置")]),e._v(" "),_("li",[e._v("4.9 的"),_("code",[e._v("__list_iterator")]),e._v("只需要传入一个参数，传入之后再取"),_("code",[e._v("*")]),e._v("和"),_("code",[e._v("&")]),e._v("定义出 pointer 和 reference")]),e._v(" "),_("li",[e._v("4.9 节点的设计分为了两块，指针不再是"),_("code",[e._v("void*")]),e._v("，而是指向自己的类型，这也是我们在学校学到的最好的做法")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(888),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以看出 4.9 的 list 变复杂了许多")]),e._v(" "),_("li",[e._v("4.9 的 list 里没有数据，他的大小就是父类的数据大小，父类数据有两个指针"),_("code",[e._v("_M_next")]),e._v("和"),_("code",[e._v("_M_prev")]),e._v("，所以 4.9 的大小是 8 字节\n"),_("ul",[_("li",[e._v("2.9 是一个 node 指针，大小为 4")])])])]),e._v(" "),_("h2",{attrs:{id:"_6-2-迭代器的设计规则和-iterator-traits-的作用与设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-迭代器的设计规则和-iterator-traits-的作用与设计"}},[e._v("#")]),e._v(" 6.2 "),_("strong",[e._v("迭代器的设计规则和 Iterator Traits 的作用与设计")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(889),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("Traits 的中文是特征。Traits 是人为设计制造的一种萃取机，萃取出你丢给它的东西的特征。标准库中有很多种 Traits，除了 iterator Traits 还有 Type Traits、Character Traits 等等")]),e._v(" "),_("li",[e._v("iterator 是容器和算法之间的桥梁，以"),_("code",[e._v("rotate()")]),e._v("算法举例，看它想要知道 iterator 的哪些属性")]),e._v(" "),_("li",[_("code",[e._v("return typename iterator traits<_Iter>::iterator_category();}")]),e._v("想要萃取出 iterator 的 category。这个 category 指的是 Iterator 的移动性质，有的 Iterator 可以 ++，有的还能 --，有的可以跳着走（随机访问） +=3。所以"),_("code",[e._v("rotate()")]),e._v("想要知道它的 category，以便采取最佳的操作方式")]),e._v(" "),_("li",[_("code",[e._v("rotate()")]),e._v("还想知道 iterator 的 difference_type 和 value_type。\n"),_("ul",[_("li",[e._v("value_type：iterator 指的东西是什么 type，如容器里存的是字符串，这个 type 就是 string")]),e._v(" "),_("li",[e._v("difference_type：两个 iterator 之间的距离应该用什么 type 来表示，比方说容器中两个离得最远的指针相减范围也不超过 232-1，就可以用 unsigned int")])])]),e._v(" "),_("li",[e._v("类似这样的提问在 C++ 标准库中有 5 种，本例给出了三种，剩下两种为 reference 和 pointer（但这两种未曾在标准库中使用），我们称这 5 个 type 为 iterator 的 associated type，迭代器必须定义出来，以便回答算法提问")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(890),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("右侧是提问的写法（直接问）")]),e._v(" "),_("li",[e._v("大部分实现都用"),_("code",[e._v("ptrdiff_t")]),e._v("定义 difference_type，它通常被定义为 long int")]),e._v(" "),_("li",[e._v("iterator_catefory 选择的是双向的标签，很合理")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(891),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("有时候传入算法的可能是一个指针，而非迭代器（泛化的指针），指针无法回答算法的问题，这时候就需要 traits 了（可以理解为加中间层）")]),e._v(" "),_("li",[e._v("traits 可以区分是 class 设计出的 iterator 还是一般的指针\n"),_("ul",[_("li",[e._v("如果是 class 形式的 iterator，就直接用"),_("code",[e._v("::")]),e._v("问")]),e._v(" "),_("li",[e._v("如果是指针，就用另外一种方式得到答案")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(892),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("我们写一个 iterator_traits，如果传入的是 class iterator 就直接问，如果传入的是指针就进入偏特化的版本")]),e._v(" "),_("li",[e._v("注意两个偏特化的 valut_type 都是 T，为什么后面那个不加 const 呢？我们需要 value_type 的主要目的是用它声明变量，声明一个无法被赋值的变量没什么用，所以两个都是 T")]),e._v(" "),_("li",[e._v("下方框中的算法想要知道 iterator 的 value_type 时，通过把 iterator 放到 traits 中，间接问")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(893),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("指针的 category 是 random_access_iterator_tag")]),e._v(" "),_("li",[e._v("可以看出，算法发现手上是指针的时候，同样能回答五个问题")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(894),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("后面会讲其他 traits")])]),e._v(" "),_("h2",{attrs:{id:"_6-3-vector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-vector"}},[e._v("#")]),e._v(" 6.3 vector")]),e._v(" "),_("p",[_("img",{attrs:{src:a(895),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("如果空间不足，不可能原地扩充，都是重新找一个两倍大的地方")]),e._v(" "),_("li",[e._v("用三个指针控制整个容器，"),_("strong",[e._v("start")]),e._v("：起点，"),_("strong",[e._v("finish")]),e._v("：终点，"),_("strong",[e._v("end_of_storage")]),e._v("：整个空间的终点。所以 vector 的大小是 12 字节")]),e._v(" "),_("li",[e._v("前闭后开，finish 指向最后一个元素的后面一个")]),e._v(" "),_("li",[e._v("为什么"),_("code",[e._v("size()")]),e._v("的实现是"),_("code",[e._v("end()-begin()")]),e._v("而不是"),_("code",[e._v("finish-start")]),e._v("呢？因为未来 vector 的实现方式会改变，不再只有 start、finish、end_of_storage，但 size 是 end()-begin() 这点不会改变")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(896),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("两倍增长一定发生在放元素进去的时候，所以这里找了最具代表性的"),_("code",[e._v("push_back()")])]),e._v(" "),_("li",[e._v("如果没有空间了，就调用"),_("code",[e._v("insert_aux()")]),e._v("，"),_("code",[e._v("insert_aux()")]),e._v("上来依然要先检查有没有空间，因为它不光被"),_("code",[e._v("push_back")]),e._v("调用，还会被其他函数调用")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(897),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("两倍增长的代码")]),e._v(" "),_("li",[e._v("如果原大小为 0，则分配 1（个元素大小），如果原大小不为 0，则分配原大小的两倍。必须要有这样的特殊处理，因为 0 的两倍还是 0")]),e._v(" "),_("li",[e._v("调用分配器按照新的大小分配空间")]),e._v(" "),_("li",[e._v("分配空间后，先将原来的 vector 内容拷贝到新的 vector 中，然后再放新数据，并将插入点后的原内容也拷贝过来（因为可能会被"),_("code",[e._v("insert()")]),e._v("调用）")]),e._v(" "),_("li",[e._v("每次空间扩充都会有大量的元素拷贝动作，会调用拷贝构造函数，而原来的数据也要一个个删除，所以也会大量调用析构函数，要注意这些开销")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(898),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("vector 是连续空间，迭代器无需单独设计成 class，指针即可")]),e._v(" "),_("li",[e._v("把迭代器丢入萃取机后，会进入偏特化的版本")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(899),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 的 vector 也变得复杂，但可以发现大小依然是 12")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(900),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 的迭代器，经过层层追踪，发现最后其实和 2.9 实现是差不多的")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(901),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 的迭代器本身是一个对象，不再是单纯的指针，对应类有 typedef 回答问题")])]),e._v(" "),_("h2",{attrs:{id:"_6-4-array"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-array"}},[e._v("#")]),e._v(" 6.4 array")]),e._v(" "),_("p",[_("img",{attrs:{src:a(902),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("比起 vector 更简单，把它包装成容器是为了让它也可以调用算法等")]),e._v(" "),_("li",[e._v("TR1 （C++03）的意思是技术报告，介于 C++98 和 C++11 之间")]),e._v(" "),_("li",[e._v("和其他容器不同，必须指定大小")]),e._v(" "),_("li",[_("code",[e._v("value_type _M_instance[_Nm ? _Nm :1!];")]),e._v("非常直观，定义了数组，并且如果使用者指定的大小是 0，会自动变成 1")]),e._v(" "),_("li",[e._v("没有构造函数和析构函数")]),e._v(" "),_("li",[e._v("直接用指针当迭代器")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(903),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 更复杂")]),e._v(" "),_("li",[e._v("可以"),_("code",[e._v("int a[100];")]),e._v("，不可以"),_("code",[e._v("int[100] b;")]),e._v("，但是可以"),_("code",[e._v("typedef int T[100]; T c;")]),e._v("，G4.9 就是类似这种写法")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(904),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("前面已经介绍过双向链表了，这个只是变成线状单向了而已")])]),e._v(" "),_("h2",{attrs:{id:"_6-5-deque"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-deque"}},[e._v("#")]),e._v(" 6.5 deque")]),e._v(" "),_("p",[_("img",{attrs:{src:a(905),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("分段连续（连续是假象，分段是事实）")]),e._v(" "),_("li",[e._v("结构是分段并用 vector 串接起来，我们将它称为“控制中心”（网络也有人将其称为主控、中控等），vector 里存放的元素是指针，分别指向各个 buffer。往后扩充仅需分配一个新的 buffer 再串到后面即可，往前扩充同理")]),e._v(" "),_("li",[e._v("迭代器中的"),_("code",[e._v("node")]),e._v("指向控制中心，"),_("code",[e._v("first")]),e._v("和"),_("code",[e._v("last")]),e._v("指的是某段 buffer 的头和尾，这样如果走到某个 buffer 的尾部了可以通过控制中心跳到下一个 buffer，"),_("code",[e._v("cur")]),e._v("是迭代器正在指向的元素。同一个 buffer 中"),_("code",[e._v("first")]),e._v("和"),_("code",[e._v("last")]),e._v("都不会变，++ 或 -- 是"),_("code",[e._v("cur")]),e._v("在变，如果去到上一个或下一个"),_("code",[e._v("buffer")]),e._v("，四个参数都会变动")]),e._v(" "),_("li",[e._v("几乎所有的容器都维护着两个迭代器，分别指向头和尾，deque 也不例外，所以图中下方画了两个迭代器")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(906),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("map 是 T**（因为 map 指向的每个元素也都是指针），map_size 是控制中心的大小")]),e._v(" "),_("li",[e._v("每个 iterator 占 4"),_("em",[e._v("4=16 字节，map 和 map_size 各占 4 字节，所以一个 deque 的大小为 16")]),e._v("2+4+4 共 40 字节")]),e._v(" "),_("li",[_("code",[e._v("BufSiz")]),e._v("的默认值是 0，这里会涉及到"),_("code",[e._v("__deque_buf_size()")]),e._v("函数，如果这个值不是 0，比如 5，那么buffer size 就是 5；如果这个值是 0，会看元素大小，如果这个元素很大，大于 512 字节，那么每个缓冲区只放一个元素，即 buffer size 为 1，如果元素大小小于 512，那么 buffer size 就是 512/sz（如元素大小为4，那么就是 512/4）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(907),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("迭代器的 category 是 random_access_iterator_tag，给外界制造连续假象")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(908),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("因为插入元素肯定是要往前推或往后推，deque 聪明的一点是会判断插入位置离哪边更近一些（比方说总共有 10000 个元素，要在第五个位置插入，当然是把前四个往前推更快）")]),e._v(" "),_("li",[e._v("一开始先判断是不是在头尾插入，是的话交给"),_("code",[e._v("push_front()")]),e._v("或"),_("code",[e._v("push_back()")]),e._v("去做，都不满足再调用"),_("code",[e._v("insert_aux()")]),e._v("函数完成")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(909),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("insert_aux()")]),e._v("先判断离头部更近还是离尾部更近，然后执行对应的操作往前推或往后推")])]),e._v(" "),_("h3",{attrs:{id:"_6-5-1-deque-如何模拟连续空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-1-deque-如何模拟连续空间"}},[e._v("#")]),e._v(" 6.5.1 deque 如何模拟连续空间")]),e._v(" "),_("p",[_("img",{attrs:{src:a(910),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("front()")]),e._v("直接返回 start 指的内容，"),_("code",[e._v("back()")]),e._v("返回 finish 指的前一个元素（因为 finish 指的是最后一个元素的后一个），"),_("code",[e._v("size()")]),e._v("是 finish-start，但"),_("code",[e._v("-")]),e._v("肯定是做了重载的")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(911),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("*")]),e._v("是取"),_("code",[e._v("cur")]),e._v("的值。"),_("code",[e._v("->")]),e._v("没什么好说的")]),e._v(" "),_("li",[_("code",[e._v("-")]),e._v("计算两个迭代器间隔了多少元素，"),_("code",[e._v("node - x.node - 1")]),e._v("是两个迭代器在控制中心的距离，然后乘每个缓冲区里的元素个数，最后加上两个迭代器在各自缓冲区内相差的元素数\n"),_("ul",[_("li",[e._v("为什么要 -1？假设一个位置是 1，一个位置是 5，这两个之间其实只有 3 个缓冲区（2、3、4）")])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(912),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("同样分为前置 ++ 和后置 ++，先 +，再检查 + 完之后有没有到达边界，如果到达边界就跳到下一个缓冲区的起点")]),e._v(" "),_("li",[e._v("-- 则是先判断在不在这个缓冲区起点，在的话就跳到前一个缓冲区的最末端")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(913),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("因为是模拟成了连续空间，所以应该可以随意移动位置，于是提供了 + 和 +=")]),e._v(" "),_("li",[e._v("先判断计算完后是否会落在同一个缓冲区，如果要落到别的缓冲区，就计算要跨越多少个缓冲区，然后再退回控制中心切到正确的缓冲区，最后计算到正确的位置")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(914),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-=")]),e._v("相当于"),_("code",[e._v("+=")]),e._v("负的")]),e._v(" "),_("li",[e._v("因为是模拟成连续的，自然也要能用中括号")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(915),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9，和其他几个容器形式差不多")]),e._v(" "),_("li",[e._v("大小依然是 40")]),e._v(" "),_("li",[_("code",[e._v("BufSiz")]),e._v("参数被去掉了，无法自己指定每个 buffer 的大小")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(916),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("补充前面没有提到的，控制中心在空间不足的时候会扩充两倍（毕竟是 vector），但拷贝的时候是拷贝到新空间的中段，这样能够保证前方和后方都有余裕")])]),e._v(" "),_("h3",{attrs:{id:"_6-5-2-queue-和-stack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-2-queue-和-stack"}},[e._v("#")]),e._v(" 6.5.2 queue 和 stack")]),e._v(" "),_("p",[_("img",{attrs:{src:a(917),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("queue 和 stack 无需重写功能，仅需内含一个 deque，再封锁住一些功能即可")]),e._v(" "),_("li",[e._v("它们俩都是转调用"),_("code",[e._v("c")]),e._v("的函数，"),_("code",[e._v("c")]),e._v("就是 deque")]),e._v(" "),_("li",[e._v("从技术上讲，不算容器，算容器适配器")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(918),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("从源代码的角度，如果另外一种容器也能提供这些函数让 queue 和 stack 转调用，那么就可以把 deque 换成别的。根据验证，list 也可以，既然 STL 选择了 deque，说明 deque 性能更好")]),e._v(" "),_("li",[e._v("queue 和 stack "),_("strong",[e._v("都不允许遍历")]),e._v("，也不提供迭代器")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(919),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("stack 可以选择 vector 作为底层，queue 不行，因为 vector 不能 "),_("code",[e._v("pop_front()")]),e._v("。由此可以看出编译器不会对模板做全面检查，这也意味着，如果你不调用 queue 的 "),_("code",[e._v("pop()")]),e._v("，其他函数都可以调用通过")]),e._v(" "),_("li",[e._v("queue 和 stack 都不能选择 set 或 map 作为底层")])]),e._v(" "),_("h2",{attrs:{id:"_6-6-rb-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-rb-tree"}},[e._v("#")]),e._v(" 6.6 rb_tree")]),e._v(" "),_("h3",{attrs:{id:"_6-6-1-rb-tree-深度探索"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1-rb-tree-深度探索"}},[e._v("#")]),e._v(" 6.6.1 RB-tree 深度探索")]),e._v(" "),_("p",[_("img",{attrs:{src:a(920),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("不讲红黑树具体的概念，只讲 STL 如何实现以及一些关键点")]),e._v(" "),_("li",[e._v("红黑树是一种自平衡二叉查找树")]),e._v(" "),_("li",[e._v("遍历红黑树会得到排序状态（sorted）。红黑树从最左边开始，会先走左边，再走右边。对应图，"),_("code",[e._v("begin()")]),e._v("是最左边的 5，"),_("code",[e._v("end()")]),e._v("是最右边的 15")]),e._v(" "),_("li",[_("strong",[e._v("不可以用迭代器赋值")]),e._v("，会破坏红黑树的规则。在编程层面并不禁止这件事，因为用作 map 时，虽然 key 不可改变，但 data 是可以改的")]),e._v(" "),_("li",[e._v("红黑树设计本身并不强制 key 不可重复，它提供"),_("code",[e._v("insert_unique()")]),e._v("和"),_("code",[e._v("insert_equal()")]),e._v("，前者在遇到重复的 key 时不会异常也不会报错，只是不会把它插入进去，后者则允许 key 重复")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(921),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("红黑树有 5 个模板参数，但是好在我们不会直接用它，而是用它更上层的 set、map")]),e._v(" "),_("li",[e._v("我们将 key 和 data 合称为 value")]),e._v(" "),_("li",[_("code",[e._v("KeyOfValue")]),e._v("告诉红黑树在 value 里 key 要怎么拿出来；"),_("code",[e._v("compare")]),e._v("告诉红黑树 key 怎么比大小")]),e._v(" "),_("li",[e._v("红黑树有三个数据，"),_("code",[e._v("node_count")]),e._v("是节点数量，"),_("code",[e._v("header")]),e._v("是指向红黑树节点的指针，"),_("code",[e._v("key_compare")]),e._v("是你传给它的那个比较函数（仿函数）。node_count 是 unsigned int，4 个字节，header 是指针，4 个字节，key_compare 是函数，没有数据，理论大小是 0，但实际上编译器会认为大小为 0 的 class 创建出的对象大小为 1，所以大小是 4+4+1=9。按照 4 的倍数对齐后是 12。")]),e._v(" "),_("li",[e._v("header 就像双向循环链表里的虚空节点一样，是为了实现方便而放进去的")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(922),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("通过编写测试函数验证对红黑树的理解")]),e._v(" "),_("li",[e._v("这里的设计是 key 就是 value，value 就是 key，"),_("code",[e._v("identity<>")]),e._v(" 是仿函数，传什么给它，它就传回来什么，"),_("code",[e._v("less<>")]),e._v("用"),_("code",[e._v("<")]),e._v("比大小")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(923),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("测试用例")]),e._v(" "),_("li",[e._v("通过 size 的可以看出"),_("code",[e._v("insert_unique()")]),e._v("和"),_("code",[e._v("insert_equal()")]),e._v("的区别")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(924),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(925),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("红色是 4.9 改动的地方，类和函数的名称都变了")]),e._v(" "),_("li",[e._v("输出结果一致")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(926),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 有总共四个数据，"),_("code",[e._v("_M_color")]),e._v("是枚举，"),_("code",[e._v("_M_parent``_M_right``_M_left")]),e._v("是三个指针加起来共 24 个字节")])]),e._v(" "),_("h3",{attrs:{id:"_6-6-2-set-和-multiset"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-2-set-和-multiset"}},[e._v("#")]),e._v(" 6.6.2 set 和 multiset")]),e._v(" "),_("p",[_("img",{attrs:{src:a(927),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("set/multiset 的 value 和 key 是合二为一的，key 就是 value，value 就是 key")]),e._v(" "),_("li",[e._v("set/multiset 提供遍历操作和迭代器，遍历后获得的是排序状态")]),e._v(" "),_("li",[e._v("我们无法用 set/multiset 的迭代器改变元素的值，因为不能改 key")]),e._v(" "),_("li",[e._v("区别\n"),_("ul",[_("li",[e._v("set 元素的 key 必须独一无二，因此"),_("code",[e._v("insert()")]),e._v("调用的是 rb_tree 的"),_("code",[e._v("insert_unique()")])]),e._v(" "),_("li",[e._v("multiset 的 key 可以重复，因此"),_("code",[e._v("insert()")]),e._v("调用的是 rb_tree 的"),_("code",[e._v("insert_equal()")])])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(928),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以看到，set 里的迭代器是 "),_("strong",[e._v("const")]),e._v(" iterator，避免使用者改变元素，破坏红黑树")]),e._v(" "),_("li",[e._v("set 所有操作都是转调用底层的 t，t 就是红黑树，可以认为它是容器适配器")])]),e._v(" "),_("h3",{attrs:{id:"_6-6-3-map-和-multimap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-3-map-和-multimap"}},[e._v("#")]),e._v(" 6.6.3 map 和 multimap")]),e._v(" "),_("p",[_("img",{attrs:{src:a(929),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("map/multimap 的排序依据是 key")]),e._v(" "),_("li",[e._v("map/multimap 提供遍历操作和迭代器，遍历后获得的是排序状态")]),e._v(" "),_("li",[e._v("我们无法用 map/multimap 的迭代器改变元素的 key，但可以用它来改变元素的 data")]),e._v(" "),_("li",[e._v("区别\n"),_("ul",[_("li",[e._v("map 元素的 key 必须独一无二，因此"),_("code",[e._v("insert()")]),e._v("调用的是 rb_tree 的"),_("code",[e._v("insert_unique()")])]),e._v(" "),_("li",[e._v("multimap 的 key 可以重复，因此"),_("code",[e._v("insert()")]),e._v("调用的是 rb_tree 的"),_("code",[e._v("insert_equal()")])])])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(930),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("key 和 data 被包成了一个 pair，注意它把 key 设为了 **const **以避免用户修改")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(931),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("map 独有的"),_("code",[e._v("[]")]),e._v("，返回和中括号内值相对应的 key 的 data，如果这个 key 不存在，就创建这个 key")]),e._v(" "),_("li",[e._v("这个"),_("code",[e._v("[]")]),e._v("首先调用"),_("code",[e._v("lower_bound()")]),e._v("算法，这是二分查找\n"),_("ul",[_("li",[e._v("如果有重复元素，"),_("code",[e._v("lower_bound()")]),e._v("会返回其中的第一个；如果找不到，会返回最适合安插这个 key 的点")])])])]),e._v(" "),_("h2",{attrs:{id:"_6-7-hashtable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-hashtable"}},[e._v("#")]),e._v(" 6.7 hashtable")]),e._v(" "),_("h3",{attrs:{id:"_6-7-1-hashtable-深度探索"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-1-hashtable-深度探索"}},[e._v("#")]),e._v(" 6.7.1 hashtable 深度探索")]),e._v(" "),_("p",[_("img",{attrs:{src:a(932),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("假设一个元素有 232 种变化，存储就要分配这种类型元素的大小*232 的空间，这显然不可能，而且这个元素只是可以有这么多种变化，会不会真的有那么多也不好说")]),e._v(" "),_("li",[e._v("如果空间足够大，编号为几的元素就放到几号位置，现在空间不是那么大，就要用编号%空间大小，这时可能会发生碰撞。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(933),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("为了解决碰撞，采用链表把余数相同的串起来，即 Separate Chaining（分离链接法）")]),e._v(" "),_("li",[e._v("hash table 里放的一般都是对象而不是数字，图上的数字是计算得到的 hash code")]),e._v(" "),_("li",[e._v("如果链表太长，也会影响到查找效率，目前采取的做法是，如果元素数量 >= 桶的数量，就将桶的数量增长两倍，然后重新打散")]),e._v(" "),_("li",[e._v("桶的数量一般会选择质数，所以不是严格的两倍，而是选择两倍附近的一个质数，如 53*2=106，最后会选择 97。gcc 2.9 的做法是直接将这些质数写死，参见右上角")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(934),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("六个模板参数，"),_("code",[e._v("Value")]),e._v("和"),_("code",[e._v("Key")]),e._v("和之前一样；"),_("code",[e._v("HashFcn")]),e._v("传进来是一个函数（仿函数），负责把对象转成编号，算出来的这个编号称为 hash code；"),_("code",[e._v("ExtractKey")]),e._v("负责取出 key，因为散列里存放的可能是 pair，需要告诉它怎么从一包东西中取出 key；"),_("code",[e._v("EqualKey")]),e._v("告诉 hashtable 什么叫相等，这样它才知道要落到哪个位置上")]),e._v(" "),_("li",[e._v("hashtable 有五个数据，前三个"),_("code",[e._v("hash")]),e._v(" "),_("code",[e._v("equals")]),e._v(" "),_("code",[e._v("get_key")]),e._v("分别就是模板参数中的"),_("code",[e._v("HashFcn``EqualKey")]),e._v(" "),_("code",[e._v("ExtractKey")]),e._v("，"),_("code",[e._v("buckets")]),e._v("是图片右侧的一堆桶，是 vector，"),_("code",[e._v("num_elements")]),e._v("记录当前有多少个元素。前三个理论大小是 0，实际大小是 1；buckets 是 vector，大小为 12；size_type 是 unsigned int，4个字节，加起来就是 1*3+12+4=19，调整为 4 的倍数后是 20 字节")]),e._v(" "),_("li",[e._v("迭代器在走到一个链表的尾部时必须有能力到下一个桶，有点像 deque。图上绘制的箭头有误，"),_("code",[e._v("cur")]),e._v("应该指向元素")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(935),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("编写测试函数")]),e._v(" "),_("li",[e._v("其中放入的元素都是 C 风格的字符串，value 就是 key，key 就是 value。比较字符串的"),_("code",[e._v("strcmp()")]),e._v("函数返回的是 -1、0、1，但 hashtable 需要的比较函数必须返回 bool 值，所以自己编写了一个函数包装起来。")]),e._v(" "),_("li",[e._v("hashtable 最重要的就是怎么把对象转成编号。用红黑树的时候只需要指定元素类型就可以了，但如果是 hashtable 做成的 set 和 map，必须写一个 hash 函数，这也算一种负担，好消息是标准库提供了一些，见下页")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(936),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("模板的偏特化，对"),_("code",[e._v("()")]),e._v("操作符做重载，如果指明的类型在这里面，这些东西就会成为仿函数")]),e._v(" "),_("li",[e._v("这一页的都是数值，传 x 进去就传 x 出来")]),e._v(" "),_("li",[e._v("如果需要自己写，就要像这页一样，为"),_("code",[e._v("hash{}")]),e._v("写一个特化版本")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(937),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("如果是 C 的字符串，就调用"),_("code",[e._v("__stl_hash_string()")]),e._v("函数计算")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(938),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("左侧是 hashtable 里的部分函数，可以发现它调用了"),_("code",[e._v("bkt_num")]),e._v("和"),_("code",[e._v("bkt_num_key")])]),e._v(" "),_("li",[e._v("看一下箭头，发现这几个函数最后统统来到"),_("code",[e._v("bkt_num_key(const key_type& key, size_t n) const")]),e._v("，它用的是 %。可见决定元素究竟落到哪个桶里用的就是取模")])]),e._v(" "),_("h3",{attrs:{id:"_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap"}},[e._v("#")]),e._v(" 6.7.2 hash_ set, hash_ multiset, hash_ map, hash_ multimap")]),e._v(" "),_("p",[e._v("视频遗失")]),e._v(" "),_("h3",{attrs:{id:"_6-7-3-unordered-容器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-3-unordered-容器"}},[e._v("#")]),e._v(" 6.7.3 unordered 容器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(939),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("就是名字改了")])]),e._v(" "),_("h1",{attrs:{id:"_7-算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-算法"}},[e._v("#")]),e._v(" 7.算法")]),e._v(" "),_("h2",{attrs:{id:"_7-1-算法的形式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-算法的形式"}},[e._v("#")]),e._v(" 7.1 算法的形式")]),e._v(" "),_("p",[_("img",{attrs:{src:a(940),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("从语言层面上看，"),_("strong",[e._v("算法是函数模板")]),e._v("，其他五个都是类模板")]),e._v(" "),_("li",[e._v("算法只能通过迭代器进行运算，虽然算法看不到容器，但是可以通过“问答”了解容器的情况，以便更好的进行操作。")])]),e._v(" "),_("h2",{attrs:{id:"_7-2-迭代器的分类-category"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-迭代器的分类-category"}},[e._v("#")]),e._v(" 7.2 迭代器的分类（category）")]),e._v(" "),_("p",[_("img",{attrs:{src:a(941),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("Array、Vector、Deque 是随机访问迭代器，List 是双向迭代器，Forward-List 是单向迭代器，红黑树是双向迭代器，Unordered 容器视每个桶的链表是单向还是双向而定（代码验证是单向迭代器）")]),e._v(" "),_("li",[e._v("通过源代码可以发现，是 random_access_iterator_tag → bidirectional_iterator_tag → forward_iterator_tag → input_iterator_tag 的继承关系")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(942),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("测试代码，输出函数的模板实现和函数重载值得学习")]),e._v(" "),_("li",[e._v("istream_iterator 和 ostream_iterator 比较特别，后面会专门讲")])]),e._v(" "),_("h2",{attrs:{id:"_7-3-迭代器的分类对算法的影响"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-迭代器的分类对算法的影响"}},[e._v("#")]),e._v(" 7.3 迭代器的分类对算法的影响")]),e._v(" "),_("p",[_("img",{attrs:{src:a(943),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("以"),_("code",[e._v("distance()")]),e._v("举例，它主要是给其他算法使用的，负责计算两个指针的距离")]),e._v(" "),_("li",[e._v("如果是随机访问迭代器就直接减，如果是其他迭代器就从头走到尾并计数")]),e._v(" "),_("li",[e._v("许多算法中都是这样的结构，主函数根据迭代器分类调用次函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(944),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("advance()")]),e._v("，主要也是给其他算法调用的，走 n 个距离")]),e._v(" "),_("li",[e._v("如果可以跳，就直接"),_("code",[e._v("i+=n")]),e._v("；如果是双向，就往前走或往后走；如果是单向，自然就只能往前走")]),e._v(" "),_("li",[e._v("小区别，"),_("code",[e._v("distance()")]),e._v("是直接调用 traits 问，"),_("code",[e._v("advance()")]),e._v("把 traits 封装成了一个小函数再调用这个函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(945),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("copy()")]),e._v("，只有三个参数，来源端的起点和终点，目的端的起点。看起来很简单，里面的实现却很复杂，为了找出一条效率最高的路线，无所不用其极")]),e._v(" "),_("li",[_("code",[e._v("has trivial op=()")]),e._v("这里是检查拷贝赋值重不重要（trivial 的意思是不重要），如果 trivial 的话就跳过拷贝赋值")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(946),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("另一个例子"),_("code",[e._v("destory()")]),e._v("，和"),_("code",[e._v("copy()")]),e._v("类似，要摧毁的对象的析构函数如果 trivial（不重要），就什么都不做")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(947),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("__unique_copy()")]),e._v("，如果没有对 output iterator 做特殊处理，它也会跑到右下角处理 forward iterator 的函数，但是这个函数里面有 read 动作，而 output iterator 是 write-only，这是不允许的。于是标准库要针对 output iterator 单独写一个版本，避免 read 动作")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(948),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("算法是模板函数，不能在语法层面强制要求一定要传给它哪种迭代器，但如果迭代器类型不合适在执行时会报错，为此算法特意修改模板参数名来暗示需要的迭代器。比如"),_("code",[e._v("sort()")]),e._v("函数是需要跳来跳去的，为了暗示，它没有用 T 或 I 命名迭代器的类型，而是用 RandomAccessIterator 命名。图中也列出了一些其他例子。")])]),e._v(" "),_("h2",{attrs:{id:"_7-4-算法源码分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-算法源码分析"}},[e._v("#")]),e._v(" 7.4 算法源码分析")]),e._v(" "),_("p",[_("img",{attrs:{src:a(949),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以看出 C 的算法是传各种参数，C++ 就像我们讲的一样是传迭代器了")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(950),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("accumulate()")]),e._v("，累计，有两个版本")]),e._v(" "),_("li",[e._v("第一个版本就是累加，第二个版本是做传进来的计算")]),e._v(" "),_("li",[e._v("右侧测试也测试了自己写的函数和仿函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(951),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("接受 first、last 和一个函数。调用函数处理从头到尾的每个元素")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(952),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("接受 first、last、旧值、新值，元素如果和旧值相同，就替换成新值")]),e._v(" "),_("li",[_("code",[e._v("replace_if()")]),e._v("，参数多了一个条件（Predicate，判断式，返回真假）")]),e._v(" "),_("li",[_("code",[e._v("replace_copy()")]),e._v("，范围内所有旧值都以新值放到新的区间，其他则以原值放到新的区间")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(953),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("右侧整理了容器中是否带有同名的成员函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(954),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("发现有成员函数的还是这八个容器，因为这八个容器是关联容器，可以用 key 找到 value，所以可以想象它们会有更快地做法")]),e._v(" "),_("li",[e._v("全局这个"),_("code",[e._v("find()")]),e._v("没有特殊的实现，就是一个一个找")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(955),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("sort()")]),e._v("源码有好几百行，这里不给出，只示范用法")]),e._v(" "),_("li",[e._v("注释中的并非屏幕实际输出内容，"),_("code",[e._v("()")]),e._v("的部分是为了说明排序的范围")]),e._v(" "),_("li",[_("code",[e._v("rbegin()")]),e._v("和"),_("code",[e._v("rend()")]),e._v("中的“r”是“reverse”的意思，看输出结果，变成了反向的排序")]),e._v(" "),_("li",[e._v("排序是需要跳的，list 和 forward_list 都不能跳，所以有自己的成员函数实现排序")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(956),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("rbegin()")]),e._v("指的是最后一个元素，"),_("code",[e._v("rend()")]),e._v("指的是第一个元素前一个。因为取数的方式不同，需要套一个适配器")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(957),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("二分查找一定要先排序")]),e._v(" "),_("li",[_("code",[e._v("binary_search()")]),e._v("把工作都交给了"),_("code",[e._v("lower_bound()")])]),e._v(" "),_("li",[_("code",[e._v("lower_bound()")]),e._v("还有个兄弟是"),_("code",[e._v("upper_bound()")]),e._v("，见图片下方，如果序列是 10 10 10 20 20 20 30 30（只是这么表示，实际上可能是红黑树），想要安插 20，"),_("code",[e._v("lower_bound()")]),e._v("会找最低点，把新的 20 放到 10 和 20 之间，"),_("code",[e._v("upper_bound()")]),e._v("则是找最高点，把新的 20 放到 20 和 30 之间。")])]),e._v(" "),_("h1",{attrs:{id:"_7-仿函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-仿函数"}},[e._v("#")]),e._v(" 7.仿函数")]),e._v(" "),_("p",[_("img",{attrs:{src:a(958),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("六大部件里最简单的")]),e._v(" "),_("li",[e._v("如果你希望设定一些额外的准则辅助实现算法，就可以用到函数或仿函数，如"),_("code",[e._v("sort()")]),e._v("里的"),_("code",[e._v("cmp()")])]),e._v(" "),_("li",[e._v("为了模仿函数，这个 class 必须重载"),_("code",[e._v("()")])])]),e._v(" "),_("p",[_("img",{attrs:{src:a(959),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("一些 gcc 独有，非标准的仿函数，好多都是我们之前用过的")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(960),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以看出用函数、用函数对象都可以，用"),_("code",[e._v("()")]),e._v("产生的临时对象也可以")]),e._v(" "),_("li",[e._v("如果自己写仿函数，并希望以后能易于修改，被 adapter 改造，融入 STL，需要继承一些给定的基类。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(961),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("一个参数的继承"),_("code",[e._v("unary_function")]),e._v("，两个参数的继承"),_("code",[e._v("binary_funcation")]),e._v("，根据函数选择适当的来继承")]),e._v(" "),_("li",[e._v("只有继承之后，仿函数才是 adaptable（可适配的），以回答 adapter 的提问")])]),e._v(" "),_("h1",{attrs:{id:"_8-适配器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-适配器"}},[e._v("#")]),e._v(" 8.适配器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(962),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("改造既有的东西，如三个参数的改成两个参数的，修改函数名称等")]),e._v(" "),_("li",[e._v("不是单独的出现在某一块，而是出现在三个地方：容器适配器、仿函数适配器、迭代器适配器")]),e._v(" "),_("li",[e._v("比方说 A（适配器）改造了 B，那么 A 就代表了 B 给大家使用，而 A 做的主要的事都是交给 B 去做，从这个角度来说，适配器像是使用者和隐藏在某后的 B 的桥梁。既然 A 要用 B 的功能，有两种做法：继承和复合。接下来我们要讨论的适配器都是通过复合实现的，如容器适配器会内含一个容器")]),e._v(" "),_("li",[e._v("适配器改造什么，自己就要变现成什么，如它是容器适配器，表现出来就应该是容器的样子")]),e._v(" "),_("li",[e._v("之前迭代器用 5 个 typedef 回应算法的问题，仿函数也要用 2 个或 3 个 typedef 回应适配器的问题")])]),e._v(" "),_("h2",{attrs:{id:"_8-1-容器适配器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-容器适配器"}},[e._v("#")]),e._v(" 8.1 容器适配器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(963),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("最简单的适配器")]),e._v(" "),_("li",[e._v("stack 和 queue 都内含 deque，选择性的封闭了一些接口，并且改了名字，如stack 把"),_("code",[e._v("push_back()")]),e._v("改名为了"),_("code",[e._v("pop()")])])]),e._v(" "),_("h2",{attrs:{id:"_8-2-仿函数适配器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-仿函数适配器"}},[e._v("#")]),e._v(" 8.2 仿函数适配器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(964),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("less(x,y)")]),e._v("本来是比较 x 和 y，但是现在我希望找出小于 40 的数，也就是我想让它和 40 比，就可以用"),_("code",[e._v("bind2nd()")]),e._v("函数将第二参数绑定为 40")]),e._v(" "),_("li",[_("code",[e._v("bind2nd()")]),e._v("实际是用"),_("code",[e._v("binder2nd")]),e._v("执行操作，代码在图片右侧")]),e._v(" "),_("li",[e._v("构造函数会将函数对象记录到 op，将数值记录到 value，等后面它被调用的时候，它才会调用 op 并将 value 作为第二参数")]),e._v(" "),_("li",[e._v("它是仿函数适配器，要表现成一个仿函数的样子，所以也要重载"),_("code",[e._v("()")])]),e._v(" "),_("li",[_("code",[e._v("binder2nd")]),e._v("是一个类模板，但很多人可能写不出"),_("code",[e._v("less<int>()")]),e._v("的类型，为了方便用户，STL 在外面包了一个"),_("code",[e._v("bind2nd()")]),e._v("给用户调用。因为在函数模板中编译器可以自动推导 op 的类型，所以它就可以把推导结果传给"),_("code",[e._v("binder2nd")]),e._v("作为模板参数")]),e._v(" "),_("li",[e._v("灰色的代码就是问答环节。因为是"),_("code",[e._v("less<int>")]),e._v("，后面绑定的第二实参应该是整数，为了做到检查，左侧"),_("code",[e._v("bind2nd()")]),e._v("中的"),_("code",[e._v("Operation::second_argument_type")]),e._v("就会问第二实参是什么类型，然后看 x 能不能转为这个类型，如果不能，这里就会编译失败，避免运行时才报错。右侧同理，"),_("code",[e._v("binder2nd")]),e._v("返回的应该是"),_("code",[e._v("less<int>")]),e._v("返回的类型，毕竟它只是适配器，不应该连返回类型都变了，所以它会问"),_("code",[e._v("Operation::result_type")]),e._v("，包括传进来的参数类型也不能乱，所以问"),_("code",[e._v("Operation::first_argument_type")]),e._v("。一个函数必须能回答这三个问题，才能和这个适配器搭配")]),e._v(" "),_("li",[_("code",[e._v("binder2nd")]),e._v("如果还要被其他适配器修饰，依然要回答问题，所以它继承了"),_("code",[e._v("unary_function")]),e._v("，很正规的写法")]),e._v(" "),_("li",[e._v("设计模式：适配器模式")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(965),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("binder1st")]),e._v(" "),_("code",[e._v("binder2nd")]),e._v(" "),_("code",[e._v("bind1st")]),e._v(" "),_("code",[e._v("bind2nd")]),e._v("现在都过时了，通通用"),_("code",[e._v("bind")]),e._v("取代。但因为之前也是标准里的，所以要用也依然可以用")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(966),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("not1()")]),e._v("继续修饰右边的东西")]),e._v(" "),_("li",[e._v("整个分析和上面完全一样，不过它只用记一个东西：pred")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(967),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("bind()")]),e._v("可以绑定\n"),_("ul",[_("li",[e._v("函数")]),e._v(" "),_("li",[e._v("函数对象（仿函数）")]),e._v(" "),_("li",[e._v("成员函数")]),e._v(" "),_("li",[e._v("data member（类里的 data）")])])]),e._v(" "),_("li",[_("code",[e._v("auto fn_half = bind(my_divide,_1,2);")]),e._v("绑定第二个参数为 2，第 1 个参数则没有绑定，因此调用的时候必须给 1 个参数。其中"),_("code",[e._v("_1")]),e._v("是占位符（place holder），意味着实际调用的第 1 参数")]),e._v(" "),_("li",[_("code",[e._v("auto fn_invert = bind(my_divide,_2,_1);")]),e._v("两个参数都空出来没有绑定，并且将顺序反了过来，用的时候第 1 实参会落到"),_("code",[e._v("_1")]),e._v("的位置，第 2 实参会落到"),_("code",[e._v("_2")]),e._v("的位置上")]),e._v(" "),_("li",[_("code",[e._v("auto fn_rounding = bind<int>(my_divide,_1,_2);")]),e._v("指定了模板参数（也只能指定一个），这个参数代表了返回类型。前面几个都没指定，return type 就是它绑定的东西的 return type，即 double")]),e._v(" "),_("li",[_("code",[e._v("MyPair ten_two{10,2};")]),e._v("是 C++11 的写法，代表着给初值")]),e._v(" "),_("li",[e._v("成员函数其实有一个看不见的实参：this，所以要么写上占位符："),_("code",[e._v("auto bound_memfn = bind(&MyPair::multiply, _1);")]),e._v("要么写上绑定谁："),_("code",[e._v("auto bound_memdata = bind(&MyPair::a, ten_two);")])]),e._v(" "),_("li",[_("code",[e._v("int n = count_if(v.cbegin(), v.cend(), not1(bind2nd(less<int>(),50)));")]),e._v("其中的"),_("code",[e._v("cbegin()")]),e._v("和"),_("code",[e._v("cend()")]),e._v("意味着 const，传回来的迭代器是 const，不修改内容。返回的是不小于 50 的，即大于等于 50 的，有 5 个")]),e._v(" "),_("li",[_("code",[e._v("bind()")]),e._v("分两行。"),_("code",[e._v("auto fn_ = bind(less<int>(), _1, 50);")]),e._v(" "),_("code",[e._v("cout << count_if(v.cbegin(), v.cend(), fn_)<< end1;")]),e._v("，返回小于 50 的，有 3 个。")])]),e._v(" "),_("h2",{attrs:{id:"_8-3-迭代器适配器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-迭代器适配器"}},[e._v("#")]),e._v(" 8.3 迭代器适配器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(968),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("逆向迭代器的 5 个 associated types 都与正向迭代器相同")]),e._v(" "),_("li",[e._v("关键是取值的部分，逆向迭代器取值就是正向迭代器退一个取值。因为"),_("code",[e._v("rbegin()")]),e._v("其实和"),_("code",[e._v("end()")]),e._v("差了一格")]),e._v(" "),_("li",[e._v("逆向的"),_("code",[e._v("++")]),e._v("就是正向的"),_("code",[e._v("--")]),e._v("，反之亦然。逆向的"),_("code",[e._v("+n")]),e._v("就是正向的"),_("code",[e._v("-n")]),e._v("。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(969),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("copy()")]),e._v("只管赋值，不管目的端空间充不充足，所以如果目的端空间不够，就可能赋值到不该赋的地方。而如果加入"),_("code",[e._v("inserter()")]),e._v("，就可以自己弄出一块空间来")]),e._v(" "),_("li",[e._v("因为链表不是连续空间，所以这里不能直接迭代器+3，而是调用了"),_("code",[e._v("advance()")]),e._v("函数")]),e._v(" "),_("li",[e._v("这里非常巧妙地使用了操作符重载，解决 copy 已经写死了，只能赋值的问题")]),e._v(" "),_("li",[e._v("实际执行的是"),_("code",[e._v("insert_iterator")]),e._v(", 巧妙在"),_("code",[e._v("=")]),e._v("是作用在 result 身上的，而 result 现在是"),_("code",[e._v("inserter(foo,it)")]),e._v("，我们将赋值操作接管了，接管后改成调用这个容器的"),_("code",[e._v("insert()")])])]),e._v(" "),_("h2",{attrs:{id:"_8-4-未知适配器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-未知适配器"}},[e._v("#")]),e._v(" 8.4 未知适配器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(970),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("istream_iterator 和 ostream_iterator 都不属于前面的三种适配器，所以算未知")]),e._v(" "),_("li",[_("code",[e._v('std::ostream_iterator<int> out_it(std::cout, ",");')]),e._v("第二参数的"),_("code",[e._v(",")]),e._v("是分割符号")]),e._v(" "),_("li",[e._v("同样通过操作符重载。先将"),_("code",[e._v("cout")]),e._v("存到"),_("code",[e._v("s")]),e._v("，将"),_("code",[e._v(",")]),e._v("存到"),_("code",[e._v("delimiter")]),e._v("，赋值的时候把"),_("code",[e._v("value")]),e._v("丢到"),_("code",[e._v("cout")]),e._v("，如果存在分隔符，把分割符也丢出去")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(971),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("使用 istream_iterator 定义出两个对象，eos 和 iit。eos 是 end of steam，作用类似标兵，没有参数，意味着 cin 的结束。iit 有参数，参数为 cin，根据源码，这个有参数的对象一旦创建，就会开始等待用户输入了")]),e._v(" "),_("li",[_("code",[e._v("++iit")]),e._v("的意思就是再读一个输入（见"),_("code",[e._v("++")]),e._v("的重载）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(972),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("copy()")]),e._v("把从"),_("code",[e._v("cin()")]),e._v("读到的数据不断放到容器里")])]),e._v(" "),_("h1",{attrs:{id:"_9-stl-周边技术与应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-stl-周边技术与应用"}},[e._v("#")]),e._v(" 9.STL 周边技术与应用")]),e._v(" "),_("h2",{attrs:{id:"_9-1-一个万用的哈希函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-一个万用的哈希函数"}},[e._v("#")]),e._v(" 9.1 一个万用的哈希函数")]),e._v(" "),_("p",[_("img",{attrs:{src:a(973),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("基本的数据类型无非就是数字、字符串，既然它们都已经有了哈希函数，有没有可能把我们自己设计的数据结构拆分成这些，然后把它们各自的 hash code 加起来作为这种元素的哈希值？")]),e._v(" "),_("li",[e._v("两种形式都可以，左侧是类里的成员函数，右侧是普通的函数，重要的是函数内部怎么做。"),_("code",[e._v("size_t(*)(const Customer&)")]),e._v("意思是函数的类型")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(974),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("假设 Customer 里有三个数据，fname、lname（意味 first name 和 last name）和 no")]),e._v(" "),_("li",[e._v("左上角的写法不是不行，但经验认为这样写太天真，可能会产生较多的碰撞")]),e._v(" "),_("li",[e._v("TR1 开始提供了"),_("code",[e._v("hash_val()")]),e._v("，比直接加要好\n"),_("ul",[_("li",[e._v("① 接受的模板参数是任意个（因为用户调用的时候传入的参数是不确定的）")]),e._v(" "),_("li",[e._v("② 接受的模板参数也是任意个，但是函数的第一个参数是"),_("code",[e._v("size_t")]),e._v("类型的")]),e._v(" "),_("li",[e._v("③ 函数的前两个参数和 ② 相同，但没有第三个参数")]),e._v(" "),_("li",[e._v("④ 是改变种子，本质就是越乱越好")])])]),e._v(" "),_("li",[_("code",[e._v("hash_val(c.fname, c.lname, c.no);")]),e._v("的第一个参数不是"),_("code",[e._v("size_t")]),e._v("类型，所以会调用到 ①。① 给参数加上一个 seed 参数后传给 ②。② 先对 seed 调用 ④，再继续调用 seed 和参数，每次 ② 都会把参数拆成 1 个和多个，如果参数依然还剩多个就递归调用自己，只剩一个参数的话就调用 ③，简单来说就是逐一取 val 改变 seed。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(975),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("那个神奇的 0x9e3779b9 其实是黄金比例")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(976),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("4.9 下编写的测试代码，6 后面应该是 7、8、9、10，图上抄错了，不影响结果")]),e._v(" "),_("li",[e._v("hh 代表哈希函数")]),e._v(" "),_("li",[_("code",[e._v("%11")]),e._v("是因为桶有 11 个，这样可以输出落到哪个桶里")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(977),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("除了开头说的两个形式，还有第三个形式，为自己的元素类型写一个偏特化版本")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(978),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("为 MyString 写特化版本，参考标准库中 string 的形式（2.9 里没有 string 的哈希函数实现，只有 char* 的，但 4.9 有）")])]),e._v(" "),_("h2",{attrs:{id:"_9-2-tuple"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-tuple"}},[e._v("#")]),e._v(" 9.2 tuple")]),e._v(" "),_("p",[_("img",{attrs:{src:a(979),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("能组合任意数量的任意类型")]),e._v(" "),_("li",[_("code",[e._v("tuple<string,int,int,complex<double>> t;")]),e._v("有趣的是，t 的大小并非是 4+4+4+16=28，而是 32，原因未知")]),e._v(" "),_("li",[_("code",[e._v("tuple<int,float,string> t1;")]),e._v("的大小是 12，符合预期")]),e._v(" "),_("li",[_("code",[e._v("get<0>(t1)")]),e._v("是把 t1 的元素的第一个元素取出来")]),e._v(" "),_("li",[e._v("也可以用"),_("code",[e._v("make_tuple()")]),e._v("配合 auto 来创建一个 tuple，无需指定类型，编译器会为我们自动推导")]),e._v(" "),_("li",[e._v("tuple 可以比大小，可以整体赋值。")]),e._v(" "),_("li",[_("code",[e._v("tie")]),e._v('是把这三样东西和 tuple 捆绑在一起，类型要一一对应，捆绑之后 i1、f1、s1 就等同于 t3 中的 77、1.1、"more light"')]),e._v(" "),_("li",[e._v("typedef 后可以用"),_("code",[e._v("tuple_size")]),e._v("获取元素个数，用"),_("code",[e._v("tuple_element")]),e._v("获取第 n 个元素，这些都不是调用参数，而是对类型做操作，算是 meta programming（元编程）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(980),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("同样用到了参数可变模板配合递归，非常漂亮")]),e._v(" "),_("li",[e._v("但是哈希函数的递归是不断调用，这里的递归是不断继承，头部继承尾部。到最后没有参数可以继承的时候就会走到最上方的特化版本（空类），结束递归")]),e._v(" "),_("li",[_("code",[e._v("head()")]),e._v("和"),_("code",[e._v("tail()")]),e._v("的分析见图片中间")])]),e._v(" "),_("h2",{attrs:{id:"_9-3-type-traits"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-type-traits"}},[e._v("#")]),e._v(" 9.3 type traits")]),e._v(" "),_("h3",{attrs:{id:"_9-3-1-type-traits-测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-1-type-traits-测试"}},[e._v("#")]),e._v(" 9.3.1 type traits 测试")]),e._v(" "),_("p",[_("img",{attrs:{src:a(981),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("2.9 的 type traits 比较平淡")]),e._v(" "),_("li",[e._v("六个 typedef\n"),_("ul",[_("li",[_("code",[e._v("this_dummy_member_must_be_first")]),e._v(" 和实现有关，不细讲")]),e._v(" "),_("li",[_("code",[e._v("has_trivial_default_constructor")]),e._v("默认构造函数重不重要")]),e._v(" "),_("li",[_("code",[e._v("has_trivial_copy_constructor")]),e._v("拷贝构造重不重要")]),e._v(" "),_("li",[_("code",[e._v("has_trivial_assignment_operator")]),e._v("拷贝赋值重不重要")]),e._v(" "),_("li",[_("code",[e._v("has_trivial_destructor")]),e._v("析构函数重不重要")]),e._v(" "),_("li",[_("code",[e._v("is_POD_type")]),e._v("是否为 C 风格的 struct")])])]),e._v(" "),_("li",[e._v("后面五个默认回答都是 false，即重要。如果你自己写一个类型，你知道哪个不重要，就可以为这个泛化的设计写出特化的版本。如下面两个示例，int 和 double 这五个都不重要，它们本来也没有这些构造函数之类的")]),e._v(" "),_("li",[_("code",[e._v("__type_traits<Foo>::has_trivial_destructor")]),e._v("就是提问的方式")]),e._v(" "),_("li",[e._v("实用性不是很高，许多人在写自己的类的时候都想不到还要特化一个 traits")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(982),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("C++11 提供了几十个 type traits，可以发现有和之前对应的，但是改名了")]),e._v(" "),_("li",[e._v("不再需要用户自己实现偏特化，只要把类丢给它它就能回答问题")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(983),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("测试代码")]),e._v(" "),_("li",[e._v("丢了一个 string 进去")]),e._v(" "),_("li",[e._v("一个类如果有指针，大概率是要写析构函数的，string 里有指针，也有析构函数（图中 546 行）。根据 OO，如果一个类要成为父类，析构函数就应该是 virtual 的，设计上 string 没有打算成为父类，所以析构函数就不是 virtual 的。然后看输出结果"),_("code",[e._v("has_virtual_destructor")]),e._v("是 0，可见 traits 真的知道它有没有虚析构函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(984),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("很单纯，只有 int，没有成员函数，其实等同于 C 的 struct。果然，输出的"),_("code",[e._v("is_pod")]),e._v("是 1")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(985),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("特意放了一个虚析构函数。"),_("code",[e._v("has_virtual_destructor")]),e._v("是 1")]),e._v(" "),_("li",[_("code",[e._v("is_polymorphic（多态）")]),e._v("是 1，polymorphic class 是一个有声明或继承了虚函数的 class，它确实有虚函数")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(986),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("Zoo 有构造函数、移动构造（move_construtor）、拷贝赋值")]),e._v(" "),_("li",[_("code",[e._v("Zoo(const Zoo&) = delete")]),e._v("的意思是不要拷贝构造函数，如果不这么写编译器会默认生成，同理，移动赋值也没要")]),e._v(" "),_("li",[_("code",[e._v("is_default_constructible")]),e._v("是 0，因为已经自己写了构造函数，编译器不会再给你默认构造函数；"),_("code",[e._v("is_copy_constructible")]),e._v("是 0，因为拷贝构造被 delete 了；"),_("code",[e._v("is_move_constructible")]),e._v("是 1，确实有移动构造，"),_("code",[e._v("is_copy_assignable")]),e._v("是 1，确实有拷贝赋值；"),_("code",[e._v("is_move_assignable")]),e._v("是 0，因为移动赋值被 delete 了。都可以对应上。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(987),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("复数只有实部虚部，没有指针，所以析构函数不重要。"),_("code",[e._v("__has_trivial_destructor")]),e._v("是 1")]),e._v(" "),_("li",[e._v("注意，复数中不是没有析构函数，编译器会给它默认的析构函数，但那个里面什么都没做，所以不重要")])]),e._v(" "),_("h3",{attrs:{id:"_9-3-2-type-traits-实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-2-type-traits-实现"}},[e._v("#")]),e._v(" 9.3.2 type traits 实现")]),e._v(" "),_("p",[_("img",{attrs:{src:a(988),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("从最简单的"),_("code",[e._v("is_void")]),e._v("开始，这里都是通过模板对类型做操作")]),e._v(" "),_("li",[e._v("它先把对判断没帮助的 const 和 volatile 关键字去掉（借助"),_("code",[e._v("remove_cv")]),e._v("）。可以发现每个实际执行的地方都是一个泛化和一个偏特化，如"),_("code",[e._v("remove_const")]),e._v("，泛化就是传给 T 就返回（严格来讲不叫返回，更像是回答、回应） T，有 const 则会传给偏特化，返回去掉 const 的。")]),e._v(" "),_("li",[e._v("去掉 const 和 volatile 之后它会把东西丢给"),_("code",[e._v("__is_void_helper")]),e._v("，它的泛化版本都回答假，如果是 void 特化就回答真。")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(989),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("is_integral")]),e._v("也是先拿掉 cv，再丢给 helper，泛化回答假，偏特化回答真")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(990),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("蓝色都是没有出现在 C++ 标准库源码中的，推测是编译器实现的")])]),e._v(" "),_("h2",{attrs:{id:"_9-4-cout"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-4-cout"}},[e._v("#")]),e._v(" 9.4 cout")]),e._v(" "),_("p",[_("img",{attrs:{src:a(991),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("cout 之所以可以接受那么多类对象，是因为标准对操作符"),_("code",[e._v("<<")]),e._v("做出了非常多的重载")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(992),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("如果是自己写的类型，想要 cout，就要自己对"),_("code",[e._v("<<")]),e._v("做重载")])]),e._v(" "),_("h2",{attrs:{id:"_9-5-move"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-5-move"}},[e._v("#")]),e._v(" 9.5 move")]),e._v(" "),_("p",[_("img",{attrs:{src:a(993),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("move 是 C++11 中加入的，主要在另一门课中讲解")]),e._v(" "),_("li",[e._v("放到容器里的元素加不加 move 功能会对速度有很大的影响")]),e._v(" "),_("li",[e._v("每个画面的上半部分是 moveable 元素的测试结果，下半部分是 non-moveable 元素的测试结果，数量都是三百万。可以发现 moveable 元素会快很多")]),e._v(" "),_("li",[e._v("为什么三百万元素需要七百多万的拷贝构造？因为 Vector 双倍扩容的时候也要拷贝构造")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(451),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(452),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(453),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(454),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("list、deque、multiset、unordered_multiset 在构造时差别都不大，因为它们都是节点式的，不像 Vector 一样是连续的，一定要两倍扩容")]),e._v(" "),_("li",[e._v("当然，它的影响不只存在于构造的时候，后面的操作都会影响，所以 2.0 很强调 move")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(994),alt:"image.png"}}),e._v(" "),_("img",{attrs:{src:a(995),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("静态的要在类外给初值")]),e._v(" "),_("li",[e._v("copy 是深拷贝，不只把指针拷贝过来，还把指针指向的对象也拷贝过来。")]),e._v(" "),_("li",[e._v("浅拷贝就是 move 的动作，差别在于"),_("code",[e._v("&&")]),e._v("上，其实就是把指针指过来，再把原来的指针断掉")]),e._v(" "),_("li",[e._v("moveable 版本的析构函数要把指针删掉，并且为了避免同一个指针被删掉两次，要提前做检查")]),e._v(" "),_("li",[e._v("但是浅拷贝更危险，move 不能乱用，自己写代码的时候一定要确认之前的东西不会再使用了才能 move")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(996),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[_("code",[e._v("M c11(c1)")]),e._v("是 copy，"),_("code",[e._v("M c12(std::move(c1))")]),e._v("是 move")]),e._v(" "),_("li",[_("code",[e._v("c1.insert(ite, V1type(buf))")]),e._v("是右值，临时对象，编译器知道不会再用了，就会自动去找 move 版本。而下面的 c1 不是临时对象，编译器不敢自作主张调用 move 版本，所以需要用"),_("code",[e._v("M c12(std::move(c1))")]),e._v("告诉编译器用 move 版本")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(455),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("vector 的深拷贝就是把来源端拷贝一份到目的端")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(997),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("浅拷贝是调用"),_("code",[e._v("vector(vector && __x)")]),e._v("，做的事就是把来源端和目的端的三根指针交换（swap）")])]),e._v(" "),_("p",[_("img",{attrs:{src:a(998),alt:"image.png"}})]),e._v(" "),_("ul",[_("li",[e._v("可以看到 string 有 move 版本，可以安心使用")])]),e._v(" "),_("p",[e._v("其他参考：")])])}),[],!1,null,null,null);t.default=s.exports},451:function(e,t,a){e.exports=a.p+"assets/img/1672314355323-9fa36a58-cd57-42f9-9342-3e8f14d3d4f9.f9a61345.png"},452:function(e,t,a){e.exports=a.p+"assets/img/1672314505115-ef1c3323-52fd-4a14-8c32-24d7a6e20cb7.c030d684.png"},453:function(e,t,a){e.exports=a.p+"assets/img/1672314519805-5a23b668-55de-4fd5-9e2d-19be5566ed58.95db14c0.png"},454:function(e,t,a){e.exports=a.p+"assets/img/1672314532277-48a57200-1eda-42bb-9044-12885cb2e563.78c68ce5.png"},455:function(e,t,a){e.exports=a.p+"assets/img/1672316873506-cb634a22-2c4d-4b2d-92ef-dbcb73c1410f.ccc3a34b.png"},832:function(e,t,a){e.exports=a.p+"assets/img/1671937924009-d369aad9-bac1-494d-856f-991123010aa9.5ace11c4.png"},833:function(e,t,a){e.exports=a.p+"assets/img/1671938612663-ac5cdf36-34b5-44d2-acd9-791476db9a48.f8aac979.png"},834:function(e,t,a){e.exports=a.p+"assets/img/1671939056153-5481d357-715e-4cb7-a546-26ce857c1b27.29331cd1.png"},835:function(e,t,a){e.exports=a.p+"assets/img/1671940472571-1eff96f8-1bf1-4d7f-bacb-0e21a7202ae0.7cf0b4d4.png"},836:function(e,t,a){e.exports=a.p+"assets/img/1671940886963-47153361-2566-4f95-8e05-61a4e798e63c.cf39650e.png"},837:function(e,t,a){e.exports=a.p+"assets/img/1671941278979-93a481e1-748a-46b0-ac3d-e54c6aa31325.b959c1e8.png"},838:function(e,t,a){e.exports=a.p+"assets/img/1671951365785-8b76147b-b855-451b-a510-707088b0e90e.4b092025.png"},839:function(e,t,a){e.exports=a.p+"assets/img/1671951791384-fcf1f2f2-8c46-4761-8c00-f2eda96306c2.a89a06fd.png"},840:function(e,t,a){e.exports=a.p+"assets/img/1671952522004-87181ffd-ef12-4433-a399-e0b09eb2af1b.77bb6314.png"},841:function(e,t,a){e.exports=a.p+"assets/img/1671952999977-c7cb4440-8347-48f4-9297-92f8fd70359c.12f713e4.png"},842:function(e,t,a){e.exports=a.p+"assets/img/1671953511523-6094b739-f64f-4153-af08-e3c6ead1c594.ddd866e5.png"},843:function(e,t,a){e.exports=a.p+"assets/img/1671954024758-b5de775b-01f5-4588-bb95-5351861b5904.6eca91d7.png"},844:function(e,t,a){e.exports=a.p+"assets/img/1671954513988-bf32cf88-96d3-4ebf-bee3-116fe94a2fdb.d7bf6540.png"},845:function(e,t,a){e.exports=a.p+"assets/img/1671954824703-c025102a-eb34-477e-b39f-4d28dc5c5f41.aa32da2f.png"},846:function(e,t,a){e.exports=a.p+"assets/img/1671955086632-5ea3cf6e-319e-44f3-906e-ecd2fabe5a6e.cb6ab4f5.png"},847:function(e,t,a){e.exports=a.p+"assets/img/1671955460040-149ec184-5a52-491d-9d11-835ca83c019a.5631bedd.png"},848:function(e,t,a){e.exports=a.p+"assets/img/1671955912416-e9e883af-1410-41a1-8dae-91091a97cee9.0f80ef5e.png"},849:function(e,t,a){e.exports=a.p+"assets/img/1671956243594-6284f5fd-a03b-49c3-8560-cef2b8fff1a6.eae3fed7.png"},850:function(e,t,a){e.exports=a.p+"assets/img/1671956591401-e2730775-324f-44e3-8427-25cce37e5fe9.05a46bc2.png"},851:function(e,t,a){e.exports=a.p+"assets/img/1671956645060-d8907688-dc82-4bd7-a65f-8ed8577cc159.ce1c6b12.png"},852:function(e,t,a){e.exports=a.p+"assets/img/1671956742157-adef8654-689f-4fec-b924-7850f8aa2e6a.281632bb.png"},853:function(e,t,a){e.exports=a.p+"assets/img/1671956851535-f394ad0a-cccb-4337-91d4-ce35835bad97.d8dd2178.png"},854:function(e,t,a){e.exports=a.p+"assets/img/1671957061981-0828c110-f4a8-4465-89b5-8ac328df70a3.37467ee7.png"},855:function(e,t,a){e.exports=a.p+"assets/img/1671957112137-40a54adc-9091-4987-b91c-358926949e67.f8b52e47.png"},856:function(e,t,a){e.exports=a.p+"assets/img/1671958016644-0f0a15b6-47a1-4607-9416-52a6ffd8f8fe.05324331.png"},857:function(e,t,a){e.exports=a.p+"assets/img/1671958172096-19b62b46-da7e-401f-89df-24b121eaecd9.1a21e143.png"},858:function(e,t,a){e.exports=a.p+"assets/img/1671958417959-4c256149-7b25-4aff-8eea-350a44fa1a44.ab8bda20.png"},859:function(e,t,a){e.exports=a.p+"assets/img/1671959177941-e3596b71-bfac-4cbb-8717-d4eb378b9730.d36cfe83.png"},860:function(e,t,a){e.exports=a.p+"assets/img/1671959337381-9c7c8ddd-ef24-4ec5-b6d0-8baf36ae2727.d8a5668d.png"},861:function(e,t,a){e.exports=a.p+"assets/img/1671959461806-a1127b20-ba45-486e-b66d-9165c1ed67c4.e3b23b9c.png"},862:function(e,t,a){e.exports=a.p+"assets/img/1671959665240-ba01dfae-cad2-499e-bc91-3180e63b135f.bdeb944a.png"},863:function(e,t,a){e.exports=a.p+"assets/img/1671960270240-2f7afa90-9199-4f07-ae8a-e90b2096bd7b.b42eeeaa.png"},864:function(e,t,a){e.exports=a.p+"assets/img/1671960700765-9023ce7a-3004-4a22-9522-0736aa6d7ebb.9f2f1866.png"},865:function(e,t,a){e.exports=a.p+"assets/img/1672022939376-725a3c6f-4839-4848-b7b7-b3a0d870c3a6.ee6a2e95.png"},866:function(e,t,a){e.exports=a.p+"assets/img/1672023074818-eeacf5e6-cfe0-4026-b45c-2a288945aa70.4e76e82d.png"},867:function(e,t,a){e.exports=a.p+"assets/img/1672023195430-344681f6-1236-4e16-8a42-09aa4ad75516.8450f78d.png"},868:function(e,t,a){e.exports=a.p+"assets/img/1672023347202-ca362a0a-1025-41ef-ae13-3499051a3f3f.be543a60.png"},869:function(e,t,a){e.exports=a.p+"assets/img/1672023592766-c76fd45e-f237-4448-b4e8-07076261e1d8.8625c915.png"},870:function(e,t,a){e.exports=a.p+"assets/img/1672023673890-2485ba11-f820-41ac-8f1b-069071d96270.7d33c999.png"},871:function(e,t,a){e.exports=a.p+"assets/img/1672024109996-9729a1d9-e1d9-4b48-9aba-0ca24d7d99b0.d7adfa99.png"},872:function(e,t,a){e.exports=a.p+"assets/img/1672024214148-63013c19-6b44-47bd-90e6-e94d12daedef.5b2e4bdc.png"},873:function(e,t,a){e.exports=a.p+"assets/img/1672024282095-ed15fca1-18bb-4ef3-8707-362ed7682d21.91da0ad7.png"},874:function(e,t,a){e.exports=a.p+"assets/img/1672024711597-3a7438f7-4249-412a-a6e0-39959657e405.e6421321.png"},875:function(e,t,a){e.exports=a.p+"assets/img/1672024942626-5cf00014-8be8-4c79-b943-6d3402a6e40d.424fda18.png"},876:function(e,t,a){e.exports=a.p+"assets/img/1672025032006-7b413860-ce7d-46c2-bf3e-4600beb0b07b.e6f908d6.png"},877:function(e,t,a){e.exports=a.p+"assets/img/1672026315224-35798b4e-c052-413e-aa52-bfd1a76e53e6.e3086dea.png"},878:function(e,t,a){e.exports=a.p+"assets/img/1672026329280-32943528-cb43-4f1e-a4f1-1d52ac25c5ae.908fcfad.png"},879:function(e,t,a){e.exports=a.p+"assets/img/1672026424836-f72b0158-7e86-4f35-8710-aa07b0e278b7.df91976a.png"},880:function(e,t,a){e.exports=a.p+"assets/img/1672027009646-9cf73072-653e-4f89-be7a-35150898345a.fc14e96e.png"},881:function(e,t,a){e.exports=a.p+"assets/img/1672027021778-4f8377fa-c20b-495f-8827-09d0fc00f9db.ab7f031e.png"},882:function(e,t,a){e.exports=a.p+"assets/img/1672027212868-5b4aebfd-4e0b-4817-ac9e-0a4e0cebd123.2f185fbb.png"},883:function(e,t,a){e.exports=a.p+"assets/img/1672029268090-5c800e49-efe3-459d-b67c-e963cba87731.42763ecb.png"},884:function(e,t,a){e.exports=a.p+"assets/img/1672030067303-cca58cff-7f25-4122-b712-770267f93e91.f0a658a2.png"},885:function(e,t,a){e.exports=a.p+"assets/img/1672030194311-cd33b381-b1ff-4139-9d56-a52ace7e5a98.e927f23e.png"},886:function(e,t,a){e.exports=a.p+"assets/img/1672041739959-139a0171-d4ba-42ad-b879-6c5cf514d034.9442b653.png"},887:function(e,t,a){e.exports=a.p+"assets/img/1672041988056-cbc92e21-9843-443c-b424-45d61786825a.20e94d11.png"},888:function(e,t,a){e.exports=a.p+"assets/img/1672042556733-d8cdd7b3-596f-45d0-be4c-0944d601b6d2.de3e665d.png"},889:function(e,t,a){e.exports=a.p+"assets/img/1672043094683-b209f206-8e15-4c03-a5aa-3556083e6207.659f4e32.png"},890:function(e,t,a){e.exports=a.p+"assets/img/1672044165114-1bdc3967-8335-4834-af6a-383587d65081.75149771.png"},891:function(e,t,a){e.exports=a.p+"assets/img/1672044712589-343173d2-4199-4b77-be72-30e29c7794c8.a0663fa9.png"},892:function(e,t,a){e.exports=a.p+"assets/img/1672045108880-5ccd6e60-9c80-417d-824f-6f52ba63ce62.b9551f6c.png"},893:function(e,t,a){e.exports=a.p+"assets/img/1672045902635-8059001d-f1a0-42df-8803-4287448361db.a16ce5b8.png"},894:function(e,t,a){e.exports=a.p+"assets/img/1672046164324-5916fced-4fb3-4a91-9f9b-f1385c8ce991.444a3f42.png"},895:function(e,t,a){e.exports=a.p+"assets/img/1672109700681-e6ad927e-8c59-4a12-b65a-a2e602722c2b.8fc18632.png"},896:function(e,t,a){e.exports=a.p+"assets/img/1672110533376-ecf31a30-e61f-458f-b955-21519b37f884.7b5d2b7e.png"},897:function(e,t,a){e.exports=a.p+"assets/img/1672110826016-021be495-7739-44a4-a49e-a31c840ea29f.1b62730d.png"},898:function(e,t,a){e.exports=a.p+"assets/img/1672111425152-21625f0a-ef39-4415-801d-dcc4d8b52321.8a23d32b.png"},899:function(e,t,a){e.exports=a.p+"assets/img/1672111811550-48204f80-78b5-41ea-873e-13cc1e8455c3.a642e678.png"},900:function(e,t,a){e.exports=a.p+"assets/img/1672112030075-0b310e4f-db73-4faa-abb8-d83b83c2ca88.9bd8fa78.png"},901:function(e,t,a){e.exports=a.p+"assets/img/1672112227315-557f9762-c59b-446c-82f1-a053f2fa9703.cc47970d.png"},902:function(e,t,a){e.exports=a.p+"assets/img/1672114200703-1cbf2b07-8957-4611-8717-add911678785.f35e58bf.png"},903:function(e,t,a){e.exports=a.p+"assets/img/1672114679854-1bdb6157-5fae-4dad-99a4-e20f1d89dbd4.da0e5dcd.png"},904:function(e,t,a){e.exports=a.p+"assets/img/1672114870063-e1a3e0c2-9831-4476-abe9-c840c176291e.4f340d24.png"},905:function(e,t,a){e.exports=a.p+"assets/img/1672114942275-4157b668-3c2b-46d3-88cb-934682c5e172.f1d23e2e.png"},906:function(e,t,a){e.exports=a.p+"assets/img/1672122037058-65b62534-13c1-4152-9e10-c952871fed3d.701d2826.png"},907:function(e,t,a){e.exports=a.p+"assets/img/1672123581547-07b6a7f5-5b76-48cd-9799-43f7f6657bcb.eab50dae.png"},908:function(e,t,a){e.exports=a.p+"assets/img/1672123734892-0069be43-a2d7-4594-8fe5-21b9b19b6291.f3c48e22.png"},909:function(e,t,a){e.exports=a.p+"assets/img/1672124064406-03c45542-94c6-4867-b543-d51708d2ccd3.969153b7.png"},910:function(e,t,a){e.exports=a.p+"assets/img/1672124297398-77e91264-d935-47b0-8ad0-d0621fe5abb5.df95a171.png"},911:function(e,t,a){e.exports=a.p+"assets/img/1672124589413-b6bd3c51-a515-4a01-86c5-ce53f8b35eb3.caac51db.png"},912:function(e,t,a){e.exports=a.p+"assets/img/1672125106289-ed0c3f0d-a5e7-4782-b091-775285e66417.8d59fd7e.png"},913:function(e,t,a){e.exports=a.p+"assets/img/1672125072404-7c6d11a7-a37c-456c-97e8-fc67a48b9b64.c5d6f537.png"},914:function(e,t,a){e.exports=a.p+"assets/img/1672125757463-15e36fb1-4561-4743-80d3-b1ec07650b5d.192f2c4f.png"},915:function(e,t,a){e.exports=a.p+"assets/img/1672125876222-f9f6b541-b9e1-4b6f-bd14-51d81ffa2eee.505548b6.png"},916:function(e,t,a){e.exports=a.p+"assets/img/1672126102465-fde31926-5989-4bf9-bbfc-df109ca8b627.7d0f455d.png"},917:function(e,t,a){e.exports=a.p+"assets/img/1672126267375-2acc80f9-74c4-44d4-87da-f767650fc8e3.e7e457bb.png"},918:function(e,t,a){e.exports=a.p+"assets/img/1672126549864-fb373895-d21f-43cf-ab68-5d6568279543.5bc62d94.png"},919:function(e,t,a){e.exports=a.p+"assets/img/1672126785129-5b1967f9-3808-4b13-b0bd-48b97fc3c76b.4c692122.png"},920:function(e,t,a){e.exports=a.p+"assets/img/1672127292327-79a92ef8-f779-4ae6-a246-6a1de5ede7af.73a1f5c3.png"},921:function(e,t,a){e.exports=a.p+"assets/img/1672128416937-6937e6d4-f060-4718-8693-47ed94e3c3ef.c1805e60.png"},922:function(e,t,a){e.exports=a.p+"assets/img/1672129983271-15f29d21-087e-4dc6-b70b-2db3bb3831aa.ba851826.png"},923:function(e,t,a){e.exports=a.p+"assets/img/1672130739879-e9316080-95c5-4fe8-b2a9-bd67460194d7.9bc2d7fe.png"},924:function(e,t,a){e.exports=a.p+"assets/img/1672131005024-1c74251c-b63a-4931-bfff-865ac7ec45c4.20f0ecb9.png"},925:function(e,t,a){e.exports=a.p+"assets/img/1672131097855-efe2f61c-a3cd-4210-96e2-3aed7703fdd4.df26f1c5.png"},926:function(e,t,a){e.exports=a.p+"assets/img/1672131154542-e4d6c0c8-0a2b-4034-b627-02b251565cfe.89dda999.png"},927:function(e,t,a){e.exports=a.p+"assets/img/1672131661454-4e0f60a1-0182-45ef-8047-669b319bb511.7e435c12.png"},928:function(e,t,a){e.exports=a.p+"assets/img/1672132156706-8b659b87-da3b-45d2-8320-14fb4f868e08.b4e661e0.png"},929:function(e,t,a){e.exports=a.p+"assets/img/1672133022978-4a791f25-812f-4ce2-ad9c-0e390a930caa.22e50ad9.png"},930:function(e,t,a){e.exports=a.p+"assets/img/1672133260208-e84fa800-2600-4b1c-8bfd-1b2814d1eea3.97cf7d21.png"},931:function(e,t,a){e.exports=a.p+"assets/img/1672133918295-7050d461-38dc-49ba-b360-a78b136705f0.f9ba044c.png"},932:function(e,t,a){e.exports=a.p+"assets/img/1672138829214-3a242c02-8877-4367-87c0-a2d7bd1b85dd.4f4f7ddb.png"},933:function(e,t,a){e.exports=a.p+"assets/img/1672139328888-df7932d4-dbfc-4668-90a1-5dfa2c59e9ec.540bbd13.png"},934:function(e,t,a){e.exports=a.p+"assets/img/1672139899887-0ab475f4-6a0d-4d8a-a89e-fedfbc1ec1c7.f2feebe5.png"},935:function(e,t,a){e.exports=a.p+"assets/img/1672141090756-7b46aa0f-a4b0-4c2b-80c3-7c4130115703.f15a33d9.png"},936:function(e,t,a){e.exports=a.p+"assets/img/1672141523443-31ad7558-c963-46d7-acfd-51fcdba07fb1.21c9983a.png"},937:function(e,t,a){e.exports=a.p+"assets/img/1672141817668-27fb09a9-cfc9-4bc7-b898-644a96dbb90d.565af761.png"},938:function(e,t,a){e.exports=a.p+"assets/img/1672142275233-6e7c55e9-f83c-435f-bee2-b979e15da3a2.09513366.png"},939:function(e,t,a){e.exports=a.p+"assets/img/1672143101159-af474467-3e8f-4c46-829b-bcbecc2c6566.330cff38.png"},940:function(e,t,a){e.exports=a.p+"assets/img/1672192719386-672be406-34d2-46ea-a886-f9c2b7d5e64f.fd79cd8e.png"},941:function(e,t,a){e.exports=a.p+"assets/img/1672193090677-a925d8b6-45c1-4a4d-a2fe-b755c018cfce.abafd52a.png"},942:function(e,t,a){e.exports=a.p+"assets/img/1672193591337-f0349bd3-6704-455a-a651-af27d0318e82.f791e3cf.png"},943:function(e,t,a){e.exports=a.p+"assets/img/1672194517022-0adbb136-a354-4dfe-8c46-ec458951eee1.1a499877.png"},944:function(e,t,a){e.exports=a.p+"assets/img/1672195059664-a1aed7d0-27f4-4a89-a99f-6786b1c63419.37a37453.png"},945:function(e,t,a){e.exports=a.p+"assets/img/1672195518969-9fff7f6d-9778-41e4-91d3-a8bbcaaf1430.fc74176d.png"},946:function(e,t,a){e.exports=a.p+"assets/img/1672196617151-e3e778b6-1c7d-435c-8e3a-045a75ac9a1f.7d321865.png"},947:function(e,t,a){e.exports=a.p+"assets/img/1672196702798-96c5b540-786e-4bf0-bc36-09cfa4a2cdf8.ba7b3a91.png"},948:function(e,t,a){e.exports=a.p+"assets/img/1672197151521-f349f82f-9121-4c62-aca2-77df60bca9e3.b64488a5.png"},949:function(e,t,a){e.exports=a.p+"assets/img/1672197797381-bbcf540d-2a2c-4859-a3f5-103ba9178876.352d589a.png"},950:function(e,t,a){e.exports=a.p+"assets/img/1672197890901-9e897ef0-e41a-46a9-a353-9aae9554e6ea.bef419ca.png"},951:function(e,t,a){e.exports=a.p+"assets/img/1672198492248-73047e10-e0b8-46d4-82aa-6d77b40ed993.ea4a464a.png"},952:function(e,t,a){e.exports=a.p+"assets/img/1672198784031-1c24adf5-89f1-409f-b7a6-0125cf65c5d7.e0a5ceaf.png"},953:function(e,t,a){e.exports=a.p+"assets/img/1672199018903-26dfe5e7-9c65-4015-a7bb-97e6248bbe53.b57bb6c9.png"},954:function(e,t,a){e.exports=a.p+"assets/img/1672199842389-9195ae37-8938-4263-9e7e-6059daf2b262.edcc09af.png"},955:function(e,t,a){e.exports=a.p+"assets/img/1672199856095-8568177f-b3f5-405e-99d2-8c87d4554e54.0f8dbeac.png"},956:function(e,t,a){e.exports=a.p+"assets/img/1672213894714-58030e4d-6873-40cc-b432-68a7ee5a9f04.a1039fd6.png"},957:function(e,t,a){e.exports=a.p+"assets/img/1672214157962-1f7a2c0f-792a-4876-b504-b9a43225441d.3b4e6fd3.png"},958:function(e,t,a){e.exports=a.p+"assets/img/1672214770003-8339cee2-0065-4849-b29d-56bdf75b568c.b9e4a108.png"},959:function(e,t,a){e.exports=a.p+"assets/img/1672215105543-94990fc8-190a-4cc9-81f4-ee2e6c3749ed.a29433b4.png"},960:function(e,t,a){e.exports=a.p+"assets/img/1672215469909-9ca9f9f9-c2c8-47ee-b64d-8d7c4803414f.968df8ed.png"},961:function(e,t,a){e.exports=a.p+"assets/img/1672215808713-aafa72a9-1510-4817-b15b-8a9e1cb16974.ce47ef1d.png"},962:function(e,t,a){e.exports=a.p+"assets/img/1672216773931-d57d49ee-37e0-407b-afd2-63902233d0da.b8e4ea82.png"},963:function(e,t,a){e.exports=a.p+"assets/img/1672216944313-39be3f72-9cb7-43d1-9186-429237a04436.df95c872.png"},964:function(e,t,a){e.exports=a.p+"assets/img/1672217528466-cf8cf3bc-220c-4e1e-86d4-8b9d24658ac2.dcfd0820.png"},965:function(e,t,a){e.exports=a.p+"assets/img/1672219940798-bcd0f201-b564-4c98-965d-d43e6c4b2bf3.44f8c318.png"},966:function(e,t,a){e.exports=a.p+"assets/img/1672223141625-59fce124-1201-45e7-aec8-3d7ae1e9a5be.00149fd0.png"},967:function(e,t,a){e.exports=a.p+"assets/img/1672223615894-d12179a4-f3cb-4ce4-8006-9d680e0d5348.b3d34b5e.png"},968:function(e,t,a){e.exports=a.p+"assets/img/1672225322260-c517e056-0a26-4f6d-8c44-c46ade94e699.a7b43f1e.png"},969:function(e,t,a){e.exports=a.p+"assets/img/1672226172433-dccf1dc3-17f8-4ced-a763-55141f1ab2bf.8ba3efa0.png"},970:function(e,t,a){e.exports=a.p+"assets/img/1672227031681-02e91fa5-62b9-4be4-ad47-7497aa4d2f39.ebeb0724.png"},971:function(e,t,a){e.exports=a.p+"assets/img/1672227885431-fc39681b-697b-4229-a227-58125124b4b4.6a57705d.png"},972:function(e,t,a){e.exports=a.p+"assets/img/1672227787236-bac30b8d-43c5-4b61-ae0a-84ba4b126bce.f63ef172.png"},973:function(e,t,a){e.exports=a.p+"assets/img/1672294168615-55ade354-74aa-4701-801b-2398e9744480.9926d2d1.png"},974:function(e,t,a){e.exports=a.p+"assets/img/1672294514663-d300aceb-577c-4456-8a72-1ce45d860483.79995bd8.png"},975:function(e,t,a){e.exports=a.p+"assets/img/1672295916718-35131563-c7b2-444a-a86a-389511268ffa.5af91b0b.png"},976:function(e,t,a){e.exports=a.p+"assets/img/1672296055188-16e1e6af-b928-4866-8f12-dc828c83260c.f9068047.png"},977:function(e,t,a){e.exports=a.p+"assets/img/1672296350188-95fda60f-06a8-4fbb-a544-e4f6be97393f.f327b14a.png"},978:function(e,t,a){e.exports=a.p+"assets/img/1672296417799-987621f1-7b8f-4c2f-838f-e7640ea2342d.a21e1e38.png"},979:function(e,t,a){e.exports=a.p+"assets/img/1672303760272-3c964989-2249-4fef-9d6a-813d7af32b43.1fc20e26.png"},980:function(e,t,a){e.exports=a.p+"assets/img/1672304925722-63a6f585-7357-4248-875e-b804fbd1fc05.3111fb28.png"},981:function(e,t,a){e.exports=a.p+"assets/img/1672306214945-fc9978ec-be40-44aa-82ce-b1e32588289e.dbbb10f4.png"},982:function(e,t,a){e.exports=a.p+"assets/img/1672309261211-d5b5c00d-8f35-404a-9e75-af7c81729d4c.908fe072.png"},983:function(e,t,a){e.exports=a.p+"assets/img/1672309626643-87a14aa8-7085-432a-89ab-4e534a375f70.10b0f51a.png"},984:function(e,t,a){e.exports=a.p+"assets/img/1672310383806-42bbddd0-e7ad-4918-a99c-cd1028c6d0fe.92cd5c61.png"},985:function(e,t,a){e.exports=a.p+"assets/img/1672310648864-20c866f6-029c-4248-877c-5e488b664b88.649b4fd2.png"},986:function(e,t,a){e.exports=a.p+"assets/img/1672310851448-5bdc4941-1fc7-4efc-9c79-5046d48ed4f5.a53eac06.png"},987:function(e,t,a){e.exports=a.p+"assets/img/1672311259828-e3f9440c-d086-4898-afe3-fd9198b09a73.a2a4d9f3.png"},988:function(e,t,a){e.exports=a.p+"assets/img/1672311408487-5b233c42-8761-4f11-91d7-aff33c77be77.81797a77.png"},989:function(e,t,a){e.exports=a.p+"assets/img/1672312115856-cb837da8-66f1-4a37-ab34-837c0523fdff.e98fd5f6.png"},990:function(e,t,a){e.exports=a.p+"assets/img/1672312309252-d95a63f4-f779-43d9-ae39-65f01c2d4c3f.90d2cdc4.png"},991:function(e,t,a){e.exports=a.p+"assets/img/1672312730056-36a1f718-c7d1-48fc-85d0-1443bdb86a7a.edf32faf.png"},992:function(e,t,a){e.exports=a.p+"assets/img/1672312752526-10c86097-01ba-4681-bfcd-75153a9655de.ad0ad5be.png"},993:function(e,t,a){e.exports=a.p+"assets/img/1672313174950-c147e48d-0594-47ec-8d8f-2cf7856e35f3.fcab5ab5.png"},994:function(e,t,a){e.exports=a.p+"assets/img/1672314641309-c91ca75f-d9dc-457a-b5e7-7a4ca89bef25.6f0de911.png"},995:function(e,t,a){e.exports=a.p+"assets/img/1672314709320-e2e15880-ecce-4f47-9eb6-9514cf9b6fd8.ed2563cf.png"},996:function(e,t,a){e.exports=a.p+"assets/img/1672315281877-50629708-2c04-46ae-997c-8614bdf381f7.b4663fda.png"},997:function(e,t,a){e.exports=a.p+"assets/img/1672316951023-207bbaf5-3799-43de-821b-a29daef65cac.58517150.png"},998:function(e,t,a){e.exports=a.p+"assets/img/1672317138933-4c6c8b46-5094-44d4-9ae7-9ff2336fd864.163c3da7.png"}}]);