<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>侯捷 C++ STL 标准库与泛型编程 | 飞&#39;s Space</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="keep Advancing">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.de4ca4d0.css" as="style"><link rel="preload" href="/assets/js/app.6240a449.js" as="script"><link rel="preload" href="/assets/js/8.9d998bdf.js" as="script"><link rel="preload" href="/assets/js/1.c70aaa24.js" as="script"><link rel="preload" href="/assets/js/3.73702826.js" as="script"><link rel="preload" href="/assets/js/18.7965e7af.js" as="script"><link rel="prefetch" href="/assets/js/10.a746ca24.js"><link rel="prefetch" href="/assets/js/11.37b96bc6.js"><link rel="prefetch" href="/assets/js/12.0e620898.js"><link rel="prefetch" href="/assets/js/13.a1c573f5.js"><link rel="prefetch" href="/assets/js/14.6467db82.js"><link rel="prefetch" href="/assets/js/15.5fcfb8d3.js"><link rel="prefetch" href="/assets/js/16.06ad1c2e.js"><link rel="prefetch" href="/assets/js/17.ca9e6d13.js"><link rel="prefetch" href="/assets/js/19.8605ea14.js"><link rel="prefetch" href="/assets/js/20.88777038.js"><link rel="prefetch" href="/assets/js/21.142a739e.js"><link rel="prefetch" href="/assets/js/22.230bba9e.js"><link rel="prefetch" href="/assets/js/23.85d00b1e.js"><link rel="prefetch" href="/assets/js/24.2e093bb4.js"><link rel="prefetch" href="/assets/js/25.d93ef571.js"><link rel="prefetch" href="/assets/js/26.f48e6be4.js"><link rel="prefetch" href="/assets/js/27.b2000fa2.js"><link rel="prefetch" href="/assets/js/28.b033a1a5.js"><link rel="prefetch" href="/assets/js/29.9f4f42e0.js"><link rel="prefetch" href="/assets/js/30.a4cb1200.js"><link rel="prefetch" href="/assets/js/31.3b4dd163.js"><link rel="prefetch" href="/assets/js/32.a6617dc8.js"><link rel="prefetch" href="/assets/js/33.233d6c4e.js"><link rel="prefetch" href="/assets/js/34.9b6b8a8b.js"><link rel="prefetch" href="/assets/js/35.6af2c493.js"><link rel="prefetch" href="/assets/js/36.819b6ce9.js"><link rel="prefetch" href="/assets/js/37.ca2e1e69.js"><link rel="prefetch" href="/assets/js/38.8faca71a.js"><link rel="prefetch" href="/assets/js/39.65a0135e.js"><link rel="prefetch" href="/assets/js/4.8d3c60e4.js"><link rel="prefetch" href="/assets/js/40.487eb8c2.js"><link rel="prefetch" href="/assets/js/41.b86e9661.js"><link rel="prefetch" href="/assets/js/42.aeefaf21.js"><link rel="prefetch" href="/assets/js/43.8849cd8c.js"><link rel="prefetch" href="/assets/js/5.3406c297.js"><link rel="prefetch" href="/assets/js/6.c78de8db.js"><link rel="prefetch" href="/assets/js/7.4db18221.js"><link rel="prefetch" href="/assets/js/9.7a339055.js">
    <link rel="stylesheet" href="/assets/css/0.styles.de4ca4d0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><LoadingPage class="loading-wrapper" data-v-1156296a data-v-1156296a></LoadingPage> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>飞's Space</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>keep Advancing</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">飞's Space</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    duolanda
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>0</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>侯捷 C++ STL 标准库与泛型编程</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">侯捷 C++ STL 标准库与泛型编程</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>duolanda</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2022/12/29</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/blogs/xue-xi-bi-ji/2023/020303.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="_1-stl-体系结构基础介绍"><a href="#_1-stl-体系结构基础介绍" class="header-anchor">#</a> 1.STL 体系结构基础介绍</h1> <h2 id="_1-1-认识-headers、版本、重要资源"><a href="#_1-1-认识-headers、版本、重要资源" class="header-anchor">#</a> 1.1 认识 headers、版本、重要资源</h2> <ul><li>Generic Programming（GP，泛型编程），使用template模板为主要工具来编写程序。</li> <li>STL 是泛型编程最成功的作品。</li></ul> <p><img src="/assets/img/1671937924009-d369aad9-bac1-494d-856f-991123010aa9.5ace11c4.png" alt="image.png"></p> <ul><li>C++标准库（C++ Standard Library）；C++标准库 .h 文件编译器自带，可以看到源代码</li> <li>可以认为标准库中 70% 都是 STL，二者是包含关系</li> <li>新式 include C header 的写法是把 .h 去掉，开头加上 c，如<code>#include&lt;stdio.h&gt;</code>写成<code>#include&lt;cstdio&gt;</code></li> <li>新式头文件都封装在 std 名称空间中，<code>using namespace std;</code></li></ul> <h2 id="_1-2-stl-体系结构基础介绍"><a href="#_1-2-stl-体系结构基础介绍" class="header-anchor">#</a> 1.2 STL 体系结构基础介绍</h2> <h2 id=""><a href="#" class="header-anchor">#</a> <img src="/assets/img/1671938612663-ac5cdf36-34b5-44d2-acd9-791476db9a48.f8aac979.png" alt="image.png"></h2> <ul><li>STL六大部件
<ul><li>容器（Container）</li> <li>分配器（Allocators）</li> <li>算法（Algorithms）</li> <li>迭代器（Iterators）</li> <li>适配器（Adapters）</li> <li>仿函数（Functors）</li></ul></li> <li>容器帮我们把内存的事情都解决掉，所以背后要有分配器来支持；有一些操作是容器里面做的，还有更多东西独立出来，成为算法；算法为了处理容器里的内容，需要有访问的方式，这个桥梁就是迭代器（可以认为是泛化的指针）；仿函数的作用像是函数；适配器可以帮我们做一些转换，容器、仿函数、迭代器都可以做转换</li></ul> <p><img src="/assets/img/1671939056153-5481d357-715e-4cb7-a546-26ce857c1b27.29331cd1.png" alt="image.png"></p> <ul><li>其实大部分人都可以不用操心分配器，因为容器的源码里默认参数会指明分配器，这里为了教学才写出来</li> <li><code>count_if</code> 算法帮我们计算符合条件的元素有几个，这里是计算大于等于 40 的元素有几个；为了告诉它元素的范围，我们用迭代器给它头和尾；我们找到了仿函数 <code>less</code>，并用适配器<code>bind2nd</code>将第二参数绑定为 40；<code>not1</code> 适配器是反义，会判断是否大于等于 40，返回 true false。
<ul><li>最后代码输出为 4</li></ul></li></ul> <p><img src="/assets/img/1671940472571-1eff96f8-1bf1-4d7f-bacb-0e21a7202ae0.7cf0b4d4.png" alt="image.png"></p> <ul><li>标准库采用前闭后开区间</li> <li><code>begin()</code> 要指向第一个元素，<code>end()</code> 不是指向最后一个元素，而是指向最后一个元素的下一个位置</li> <li>因为迭代器是泛化的指针，所以指针能做的迭代器都能做，ite 可以 <code>++``--``*``-&gt;</code>，上面的例子是习惯的遍历写法</li></ul> <p><img src="/assets/img/1671940886963-47153361-2566-4f95-8e05-61a4e798e63c.cf39650e.png" alt="image.png"></p> <ul><li>现在更推荐这种新写法（range-based for statement）</li></ul> <h1 id="_2-容器分类与各种测试"><a href="#_2-容器分类与各种测试" class="header-anchor">#</a> 2.容器分类与各种测试</h1> <h2 id="_2-1-结构与分类"><a href="#_2-1-结构与分类" class="header-anchor">#</a> 2.1 结构与分类</h2> <p><img src="/assets/img/1671941278979-93a481e1-748a-46b0-ac3d-e54c6aa31325.b959c1e8.png" alt="image.png"></p> <ul><li>容器分为序列式容器（Sequence Containers）、关联式容器（Associative Containers）。无序容器（Unordered Containers）其实也算是关联式容器</li> <li>红色框代表是 C++11 新增的</li> <li>序列式容器
<ul><li>Array 是把语言中的数组包装为 class</li> <li>Vector 在空间不够时会自动扩充</li> <li>Deque 双向队列，前后都可扩充</li> <li>List 链表，每个元素用双向指针连接</li> <li>Forward-List 单向链表，比 List 更省内存（少一个指针就省 4 个字节）</li></ul></li> <li>关联式容器
<ul><li>能够高速查找，底层用红黑树实现（一种自平衡二叉查找树）</li> <li>Set 不分 key 和 value，Map 的每一个节点有 key 和 value</li> <li>Set 和 Map 的 key 都不能重复，但 Multiset 和 Multimap 可以</li> <li>无序容器的底层实现是 HashTable，标准库的实现方式是 Separate Chaining（分离链接法），将具有同一个 hash 值的 key 存到一个链表中，解决碰撞（冲突）</li></ul></li></ul> <p><img src="/assets/img/1671951365785-8b76147b-b855-451b-a510-707088b0e90e.4b092025.png" alt="image.png"></p> <ul><li>以下是后面测试程序会用到的辅助函数</li> <li><code>get_a_target_long()</code>用交互方式让使用者输入要查找的元素；<code>get_a_target_string()</code>把输入的数字转成字符串，为了体现实际使用中容器不会只存储数值；<code>compareLongs()</code>和<code>compareStrings()</code>比较 long 或字符串的大小，未来传给 qsort 快速排序函数使用。</li></ul> <h2 id="_2-2-序列式容器"><a href="#_2-2-序列式容器" class="header-anchor">#</a> 2.2 序列式容器</h2> <h3 id="_2-2-1-array"><a href="#_2-2-1-array" class="header-anchor">#</a> 2.2.1 array</h3> <p><img src="/assets/img/1671951791384-fcf1f2f2-8c46-4761-8c00-f2eda96306c2.a89a06fd.png" alt="image.png"></p> <ul><li>ASIZE 告诉 array 数组长度为五十万（这个参数不能省略）</li> <li><code>array.data()</code>会返回这个数组在内存中的起点地址</li> <li><code>qsort()</code> 的四个参数：起点地址、多少个元素、每个元素大小、怎么比大小</li> <li>使用二分查找之前一定要先排序</li></ul> <h3 id="_2-2-2-vector"><a href="#_2-2-2-vector" class="header-anchor">#</a> 2.2.2 vector</h3> <p><img src="/assets/img/1671952522004-87181ffd-ef12-4433-a399-e0b09eb2af1b.77bb6314.png" alt="image.png"></p> <ul><li>插入一百万个数据</li> <li>只有<code>push_back()</code>，插入到数据尾部，因为只能往后扩展。每次<code>push_back</code>申请的空间以两倍增长，会申请预留空间；size 是大小，capacity 是申请的内存空间大小（两倍增长那个）。</li> <li>try 和 catch 捕获异常，以防输入测试数量过大，内存空间不足</li></ul> <p><img src="/assets/img/1671952999977-c7cb4440-8347-48f4-9297-92f8fd70359c.12f713e4.png" alt="image.png"></p> <ul><li>找 23456 没什么特殊意义，随便打的数</li> <li><code>find()</code>是标准库的算法，模板函数，按顺序查找。不加<code>::</code>编译器也会自动从全局找，写上是为了更清晰</li> <li><code>sort()</code>是 C++ 标准库提供的，<code>bsearch()</code>是 C 库里的</li></ul> <h3 id="_2-2-3-list"><a href="#_2-2-3-list" class="header-anchor">#</a> 2.2.3 list</h3> <p><img src="/assets/img/1671953511523-6094b739-f64f-4153-af08-e3c6ead1c594.ddd866e5.png" alt="image.png"></p> <ul><li>list 每次<code>push_back</code>只需在空间中找一个节点大小
<ul><li>相比之下 vector 每次扩充不光要先开出两倍的空间，还要把之前的数据都移到新的空间，步骤更多</li></ul></li> <li>list 有<code>max_size()</code>， forward_list 和 deque 也有。为什么会有 max_size()？后面我们再看</li> <li>这里使用的不是全局的<code>sort()</code>，而是 list 容器自己的<code>sort()</code>当容器自己提供<code>sort()</code>的时候，建议使用自带的</li></ul> <h3 id="_2-2-4-forward-list"><a href="#_2-2-4-forward-list" class="header-anchor">#</a> 2.2.4 forward_list</h3> <p><img src="/assets/img/1671954024758-b5de775b-01f5-4588-bb95-5351861b5904.6eca91d7.png" alt="image.png"></p> <ul><li>没有<code>push_back()</code>，只有<code>push_front()</code>，因为是单向的，只能在头部插入元素</li> <li>在 C++11 之前还有<code>slist</code>，不在标准规范中，用法等完全相同</li></ul> <h3 id="_2-2-5-deque"><a href="#_2-2-5-deque" class="header-anchor">#</a> 2.2.5 deque</h3> <p><img src="/assets/img/1671954513988-bf32cf88-96d3-4ebf-bee3-116fe94a2fdb.d7bf6540.png" alt="image.png"></p> <ul><li>这张图详细描述了它的结构</li> <li>可以发现 deque 是分成一段一段的，每段内部是连续的，即分段连续，使用者感觉起来会是连续的</li> <li>空间用完时，每次会扩充一个 buffer，相比之下 vector 的扩充可能会有很大的浪费</li></ul> <p><img src="/assets/img/1671954824703-c025102a-eb34-477e-b39f-4d28dc5c5f41.aa32da2f.png" alt="image.png"></p> <h3 id="_2-2-6-stack"><a href="#_2-2-6-stack" class="header-anchor">#</a> 2.2.6 stack</h3> <p><img src="/assets/img/1671955086632-5ea3cf6e-319e-44f3-906e-ecd2fabe5a6e.cb6ab4f5.png" alt="image.png"></p> <ul><li>deque 涵盖 stack 和 queue，源代码也是如此，stack 和 queue 内部其实都是用 deque 实现的</li> <li>因为这两个容器没有自己的数据结构，所以很多人在技术上不认为这两个是容器，而是将它们称为容器适配器</li> <li>stack 先进后出，queue 先进先出</li> <li>不提供 iterator，因为可能会破坏先进先出或先进后出的机制，所以这里没有示范<code>find()</code></li></ul> <h2 id="_2-3-关联式容器"><a href="#_2-3-关联式容器" class="header-anchor">#</a> 2.3 关联式容器</h2> <h3 id="_2-3-1-multiset"><a href="#_2-3-1-multiset" class="header-anchor">#</a> 2.3.1 multiset</h3> <p><img src="/assets/img/1671955460040-149ec184-5a52-491d-9d11-835ca83c019a.5631bedd.png" alt="image.png"></p> <ul><li>因为一百万次极大概率会出现重复数据，所以测试 multiset</li> <li>数据并不是插入到头或尾，而是根据一定规则插入（自动排序），不需要用户操心</li> <li>自己的<code>find()</code>比全局<code>find()</code>快很多，是 0，可见关联式容器查找速度很快，相应地在数据插入时会慢一些</li></ul> <h3 id="_2-3-2-multimap"><a href="#_2-3-2-multimap" class="header-anchor">#</a> 2.3.2 multimap</h3> <p><img src="/assets/img/1671955912416-e9e883af-1410-41a1-8dae-91091a97cee9.0f80ef5e.png" alt="image.png"></p> <ul><li><code>insert()</code>时要自己用 pair 把 key 和 value 组合起来</li> <li>用容器自己的<code>find()</code>，同样很快</li></ul> <h3 id="_2-3-3-unordered-multiset"><a href="#_2-3-3-unordered-multiset" class="header-anchor">#</a> 2.3.3 unordered_multiset</h3> <p><img src="/assets/img/1671956243594-6284f5fd-a03b-49c3-8560-cef2b8fff1a6.eae3fed7.png" alt="image.png"></p> <ul><li><code>bucker_count()</code>桶的数量，桶的数量一定比现有元素数量还多，因为每个桶出去的链表不能太长，如果元素数量 &gt;= 桶的数量，桶的数量就会扩充到原来的两倍（原有元素也会重新打散分配）</li></ul> <p><img src="/assets/img/1671956591401-e2730775-324f-44e3-8427-25cce37e5fe9.05a46bc2.png" alt="image.png"></p> <ul><li>同样的，自己的<code>find()</code>很快</li></ul> <h3 id="_2-3-4-unordered-multimap"><a href="#_2-3-4-unordered-multimap" class="header-anchor">#</a> 2.3.4 unordered_multimap</h3> <p><img src="/assets/img/1671956645060-d8907688-dc82-4bd7-a65f-8ed8577cc159.ce1c6b12.png" alt="image.png"></p> <ul><li>没什么好说的</li></ul> <h3 id="_2-3-5-set"><a href="#_2-3-5-set" class="header-anchor">#</a> 2.3.5 set</h3> <p><img src="/assets/img/1671956742157-adef8654-689f-4fec-b924-7850f8aa2e6a.281632bb.png" alt="image.png"></p> <ul><li>key 不可以重复，真正放进去的数据不会有一百万个，图中显示，只有 32768（随机数产生刚好是 0~32767）</li></ul> <h3 id="_2-3-6-map"><a href="#_2-3-6-map" class="header-anchor">#</a> 2.3.6 map</h3> <p><img src="/assets/img/1671956851535-f394ad0a-cccb-4337-91d4-ce35835bad97.d8dd2178.png" alt="image.png"></p> <ul><li>multimap 不可以用<code>[]</code>做插入，但 map 可以：<code>c[i]=string(buf);</code>，i 和 map 会自动合成 pair</li> <li>map 真正放进去的数据依然有一百万个，因为 key 其实没有重复，只有 value 重复了</li></ul> <h3 id="_2-3-7-unordered-set-和-unordered-map"><a href="#_2-3-7-unordered-set-和-unordered-map" class="header-anchor">#</a> 2.3.7 unordered_set 和 unordered_map</h3> <p><img src="/assets/img/1671957061981-0828c110-f4a8-4465-89b5-8ac328df70a3.37467ee7.png" alt="image.png"></p> <p><img src="/assets/img/1671957112137-40a54adc-9091-4987-b91c-358926949e67.f8b52e47.png" alt="image.png"></p> <ul><li>底层为哈希表，没有什么可说的</li></ul> <h2 id="_2-4-其他补充"><a href="#_2-4-其他补充" class="header-anchor">#</a> 2.4 其他补充</h2> <ul><li>还有叫作 priority_queue 和 heap 的容器，一个是用的比较少，二是底层实现为其他容器，所以这里不做测试</li> <li>早期有 hash_set、hash_map、hash_multiset、hash_multimap，（现在改名为 unordered_... 后加入到标准库了）就像 slist 一样，如果你想让使用它们的旧程序依然可以正常编译，需要在导入头文件时加上 ext，如<code>#include &lt;ext\slist&gt;</code></li></ul> <h1 id="_3-分配器测试"><a href="#_3-分配器测试" class="header-anchor">#</a> 3.分配器测试</h1> <p><img src="/assets/img/1671958016644-0f0a15b6-47a1-4607-9416-52a6ffd8f8fe.05324331.png" alt="image.png"></p> <ul><li>不同编译器的分配器设计可能有所不同</li> <li>每个容器类都有默认的容器分配器（红色部分）</li></ul> <p><img src="/assets/img/1671958172096-19b62b46-da7e-401f-89df-24b121eaecd9.1a21e143.png" alt="image.png"></p> <ul><li>以上是 gcc 编译器的测试代码</li> <li>测试中选择 list 作为容器，搭配不同的分配器，这些分配器定义在<code>__gnu:cxx</code>命名空间下</li></ul> <p><img src="/assets/img/1671958417959-4c256149-7b25-4aff-8eea-350a44fa1a44.ab8bda20.png" alt="image.png"></p> <ul><li>可以自行调用<code>allocate()</code>和<code>deallocate()</code>，但没有必要。尽量使用容器，容器之外小量内存申请就用 new、delete 或 malloc、free；不需要记住当时申请内存的大小，这才是对的、好的。直接用分配器在释放（<code>deallocate()</code>）的时候不仅需要指针，还要指明申请时的大小，记忆负担重，并不好用</li></ul> <h1 id="_4-源码分布及技术基础"><a href="#_4-源码分布及技术基础" class="header-anchor">#</a> 4.源码分布及技术基础</h1> <h2 id="_4-1-源码分布"><a href="#_4-1-源码分布" class="header-anchor">#</a> 4.1 源码分布</h2> <p><img src="/assets/img/1671959177941-e3596b71-bfac-4cbb-8717-d4eb378b9730.d36cfe83.png" alt="image.png"></p> <ul><li>vc 很直白，gcc 更复杂一些</li></ul> <h2 id="_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程"><a href="#_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程" class="header-anchor">#</a> 4.2 OOP(Object-Oriented programming，面向对象编程) vs. GP(Genic Programming，泛型编程)</h2> <p><img src="/assets/img/1671959337381-9c7c8ddd-ef24-4ec5-b6d0-8baf36ae2727.d8a5668d.png" alt="image.png"></p> <ul><li>许多大型 OOP 库会有很复杂的继承关系，很多虚函数，标准库中则很少有这种构造</li> <li>OOP = 数据 + 操作</li> <li>list 类中有自己的<code>sort()</code> <ul><li>原因是能够符合<code>first+(last-first/2)</code>中 + - / 运算的迭代器一定是 RandomAccessIterator（随机访问迭代器），而 list 在内存中是不连续的，它具备的迭代器只能向前或向后走，不能跳到特定的位置，所以 list 不能使用全局的 sort 排序</li></ul></li></ul> <p><img src="/assets/img/1671959461806-a1127b20-ba45-486e-b66d-9165c1ed67c4.e3b23b9c.png" alt="image.png"></p> <ul><li>GP 是将 data 和 method 分开来。</li> <li>vector 和 deque 类中都没有排序的操作，操作被单独的设计到一个全局的<code>sort()</code>函数中，使用时通过迭代器传入头尾</li></ul> <p><img src="/assets/img/1671959665240-ba01dfae-cad2-499e-bc91-3180e63b135f.bdeb944a.png" alt="image.png"></p> <ul><li>GP 有以下两个好处：
<ul><li>Container 和 Alogorithm 团队可以各自闭门造车，然后用 iterator 沟通即可</li> <li>Alogorithm 通过 Iterator 确定操作范围，并通过 Iterator 取用 Continer 元素</li></ul></li> <li>如右上角的例子，函数只负责返回 a 和 b 里更小的那一个，至于 a 和 b 怎么比大小，应该是 a 和 b 的那种东西去定（它俩肯定是一种东西），这个思路也代表着操作符重载很重要</li></ul> <p><img src="/assets/img/1671960270240-2f7afa90-9199-4f07-ae8a-e90b2096bd7b.b42eeeaa.png" alt="image.png"></p> <ul><li>所谓算法，其内最终设计元素本身的操作，无非就是比大小。找一个东西是相等，不小于也不大于就是等于，排序也是类似的道理</li> <li><code>max(string(&quot;zoo&quot;), string(&quot;hello&quot;))</code>调用的是第一个版本的<code>max()</code>，字符串对于<code>&lt;</code>的定义是，b 比 a 大，c 比 b 大，z 最大，不管长度，所以输出是 zoo 更大</li> <li><code>max(string(&quot;zoo&quot;), string(&quot;hello&quot;, strLonger))</code>使用了自己的比较方式，根据长度比大小，调用<code>max()</code>的第二个版本，得出 hello 更大</li></ul> <h2 id="_4-3-技术基础-操作符重载和模板"><a href="#_4-3-技术基础-操作符重载和模板" class="header-anchor">#</a> 4.3 技术基础（操作符重载和模板）</h2> <h3 id="_4-3-1-操作符重载"><a href="#_4-3-1-操作符重载" class="header-anchor">#</a> 4.3.1 操作符重载</h3> <p><img src="/assets/img/1671960700765-9023ce7a-3004-4a22-9522-0736aa6d7ebb.9f2f1866.png" alt="image.png"> <img src="/assets/img/1672022939376-725a3c6f-4839-4848-b7b7-b3a0d870c3a6.ee6a2e95.png" alt="image.png"></p> <ul><li>第一页总结的很好</li> <li>第二页的限制不需要记，写的时候翻资料即可</li></ul> <p><img src="/assets/img/1672023074818-eeacf5e6-cfe0-4026-b45c-2a288945aa70.4e76e82d.png" alt="image.png"></p> <ul><li>这个是链表迭代器的代码</li></ul> <h3 id="_4-3-2-模板"><a href="#_4-3-2-模板" class="header-anchor">#</a> 4.3.2 模板</h3> <p>模板分为三大类：类模板，函数模板，成员模板
<img src="/assets/img/1672023195430-344681f6-1236-4e16-8a42-09aa4ad75516.8450f78d.png" alt="image.png"></p> <ul><li>类模板</li></ul> <p><img src="/assets/img/1672023347202-ca362a0a-1025-41ef-ae13-3499051a3f3f.be543a60.png" alt="image.png"></p> <ul><li>函数模板</li> <li>这里的 class 可以写成 typename，class 是早期的写法</li></ul> <p><img src="/assets/img/1672023592766-c76fd45e-f237-4448-b4e8-07076261e1d8.8625c915.png" alt="image.png"></p> <ul><li>成员模板</li> <li>后面我们的标准库源代码暂时看不到这个，所以不讲</li></ul> <p><img src="/assets/img/1672023673890-2485ba11-f820-41ac-8f1b-069071d96270.7d33c999.png" alt="image.png"></p> <ul><li>特化的语法 <code>template&lt;&gt; struct __type_traits&lt;int&gt;</code>，由于泛化的 T 已经绑定为 int 了，所以后面要写上 int，前面的 template&lt;&gt; 中是空的</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//泛化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__type_traits</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="/assets/img/1672024109996-9729a1d9-e1d9-4b48-9aba-0ca24d7d99b0.d7adfa99.png" alt="image.png"></p> <ul><li><code>__STL_TEMPLATE_NULL</code> 就是 <code>template&lt;&gt;</code>，所以看到它出现就意味着要特化了</li></ul> <p><img src="/assets/img/1672024214148-63013c19-6b44-47bd-90e6-e94d12daedef.5b2e4bdc.png" alt="image.png"></p> <ul><li>上面的特化也可以称为全特化</li></ul> <p><img src="/assets/img/1672024282095-ed15fca1-18bb-4ef3-8707-362ed7682d21.91da0ad7.png" alt="image.png"></p> <ul><li>有两个模板参数，绑定其中一个</li> <li>右边的例子是范围上的“偏”，范围限定为指针</li></ul> <h1 id="_5-分配器源码分析"><a href="#_5-分配器源码分析" class="header-anchor">#</a> 5.分配器源码分析</h1> <p>幕后英雄，分配器好不好影响容器的性能好不好
<img src="/assets/img/1672024711597-3a7438f7-4249-412a-a6e0-39959657e405.e6421321.png" alt="image.png"></p> <ul><li><code>operator new()</code>底层都会调用到<code>malloc()</code></li> <li><code>malloc()</code>分配出的内存如右图所示。用户要求的大小是浅蓝色部分（size），<code>malloc()</code>实际分配了更多的东西，细节会在内存管理课讲
<ul><li>附加的部分大小几乎是差不多的，所以你要求分配的空间越大，附加部分所占比例越小</li></ul></li></ul> <p><img src="/assets/img/1672024942626-5cf00014-8be8-4c79-b943-6d3402a6e40d.424fda18.png" alt="image.png"></p> <ul><li>这里列举了四个容器，其他也差不多，它们默认的分配器都是<code>allocator</code>，所以下面我们将分析<code>allocator</code>的源码</li></ul> <p><img src="/assets/img/1672025032006-7b413860-ce7d-46c2-bf3e-4600beb0b07b.e6f908d6.png" alt="image.png"></p> <ul><li>分配器最重要的两个函数：<code>allocate()</code>和<code>deallocate()</code>，而<code>allocate()</code>调用的是<code>operator new()</code>，<code>operator new()</code>调用的是<code>malloc()</code>;<code>deallocate()</code>调用<code>operator delete()</code>，最终调用<code>free()</code></li> <li>可见，VC6 的 allocator 只是用<code>operator new()</code>和<code>operator delete()</code>完成<code>allocate()</code>和<code>deallocate()</code>，没有任何特殊设计</li> <li>我们通常放的元素都不大，像 string 只有四字节，而这就意味着额外开销（malloc 多分配的内容）很大，甚至有可能比元素本身还大，如果元素有几百万个，会是很可怕的事情，但 vc 就是这么做的</li> <li>右下角的代码证明我们也可以直接调用分配器，但不鼓励，因为没有人有心思记当时分配的内存有多大，大家只会记指针。但是容器去用没有问题，未来讲细节</li></ul> <p><img src="/assets/img/1672026315224-35798b4e-c052-413e-aa52-bfd1a76e53e6.e3086dea.png" alt="image.png"> <img src="/assets/img/1672026329280-32943528-cb43-4f1e-a4f1-1d52ac25c5ae.908fcfad.png" alt="image.png"></p> <ul><li>gcc 2.9 直接写出，虽然实现了分配器，但是容器并没有用这个实现的分配器，可以看出，容器用的是 alloc 分配器而不是 allocator</li></ul> <p><img src="/assets/img/1672026424836-f72b0158-7e86-4f35-8710-aa07b0e278b7.df91976a.png" alt="image.png"></p> <ul><li>gcc 的 alloc 分配器源码将在内存管理课上分析</li> <li>思路是尽量减少<code>malloc()</code>次数，设计了 16 条链表，每条链表负责特定大小的区块，如链表 0 负责八字节大小，链表 7 负责六十四字节大小。容器的大小会被调整到 8 的倍数大小，如 60 会调整到 64，分配器 <code>malloc()</code> 一大块内存，每块用单向链表做切割，切出来的每一块都不带 cookie（额外开销主要体现在 cookie 上，cookie 消耗 8 个字节）</li> <li>它也有缺点，内存管理时讲</li></ul> <p><img src="/assets/img/1672027009646-9cf73072-653e-4f89-be7a-35150898345a.fc14e96e.png" alt="image.png"> <img src="/assets/img/1672027021778-4f8377fa-c20b-495f-8827-09d0fc00f9db.ab7f031e.png" alt="image.png"></p> <ul><li>gcc 4.9 （不一定是 4.9 开始，可能之前就改了）中容器又改用了另一个分配器。变成和 vc 的情况差不多了，直接 <code>malloc()</code></li></ul> <p><img src="/assets/img/1672027212868-5b4aebfd-4e0b-4817-ac9e-0a4e0cebd123.2f185fbb.png" alt="image.png"></p> <ul><li>根据源代码，gcc 4.9 提供的众多 extension allocators 中的 __pool_allocate 就是之前 gcc 2.9 的 alloc</li> <li>如果想使用它，把它指定为容器的第二个模板参数即可 <code>vector&lt;string, __gnu_cxx::__pool_alloc&lt;string&gt;&gt; vec;</code></li></ul> <h1 id="_6-容器源码分析"><a href="#_6-容器源码分析" class="header-anchor">#</a> 6.容器源码分析</h1> <h2 id="_6-1-list"><a href="#_6-1-list" class="header-anchor">#</a> 6.1 list</h2> <p><img src="/assets/img/1672029268090-5c800e49-efe3-459d-b67c-e963cba87731.42763ecb.png" alt="image.png"></p> <ul><li>不是最简单的，但是是最具代表性的</li> <li>容器大小，指的是本身控制操作所需的大小（如需要几根指针），与控制的数据多少无关</li> <li>整个 list 里的数据只有一个：node，是 list_node 指针，大小为 4 字节，所以 gcc 2.9 里 list 的大小就是 4</li> <li>list_node 有三个变量，向前指的指针、向后指的指针、数据，因此算占用内存的时候不能只计算数据大小，还要加上两个指针</li> <li>为了满足前闭后开，最后一个元素并非指向第一个元素，而是指向一个空白节点，<code>begin()</code>返回的是第一个节点，<code>end()</code>返回的是最后一个元素后面的空白节点</li></ul> <p><img src="/assets/img/1672030067303-cca58cff-7f25-4122-b712-770267f93e91.f0a658a2.png" alt="image.png"></p> <ul><li>除了 array 和 vector，其他容器的 iterator 都要是 class 才能设计出聪明的动作，比方说 list 的 iterator++ 需要改成去找 next 指针，而不是真的直接找下一个内存地址</li> <li>所有容器的 iterator 都会有一大堆的 typedef 和一大组操作符重载</li></ul> <p><img src="/assets/img/1672030194311-cd33b381-b1ff-4139-9d56-a52ace7e5a98.e927f23e.png" alt="image.png"></p> <ul><li><code>++</code>分为前置和后置的，<code>++i</code>是前置，<code>i++</code>是后置，为了区分，带参数的<code>operator++(int)</code>为后置，<code>operator++()</code>为前置；</li> <li>先看前置 ++ 的<code>operator++()</code>，取出 node 指的 next 的值并赋给 node</li> <li>再看后置 ++ 的<code>operator++(int)</code>，先记住原来的值，然后进行++操作，最后返回原值。第一步里的<code>self tmp = *this;</code>并不会唤起 * 的重载，而是先来到被重载的 =，即拷贝构造，<code>*this</code>被解释为拷贝构造函数的参数。第二步的 ++ 唤起前 ++ 的 <code>operator++()</code></li> <li>在重载 ++ 时，设计者会向整数的 ++ 看齐，C++ 不允许后置 ++ 两次，即整数不可以<code>i++++</code>，所以 iterator 的<code>operator++(int)</code>为了阻止两次 ++，返回的是数值 self，而非前 ++ 的引用 self&amp;</li></ul> <p><img src="/assets/img/1672041739959-139a0171-d4ba-42ad-b879-6c5cf514d034.9442b653.png" alt="image.png"></p> <ul><li>除了 ++ --，另一个很重要的动作是获取数值</li> <li><code>*</code>，使用者想要取得 data，所以返回<code>(*node).data</code></li> <li><code>-&gt;</code>，思路类似，右侧有说明</li></ul> <p><img src="/assets/img/1672041988056-cbc92e21-9843-443c-b424-45d61786825a.20e94d11.png" alt="image.png"></p> <ul><li>刚才看 gcc 2.9 的一些细节有点奇怪，一个是<code>__list_node</code>中向前向后的指针类型都是<code>void*</code>，还有就是<code>__list_iterator</code>要传三个参数，按道理来说只传一个 T（数据本身类型）就够了，第二个和三个在函数里生成即可</li> <li>这里将 2.9 和 4.9 的代码上下并置</li> <li>4.9 的<code>__list_iterator</code>只需要传入一个参数，传入之后再取<code>*</code>和<code>&amp;</code>定义出 pointer 和 reference</li> <li>4.9 节点的设计分为了两块，指针不再是<code>void*</code>，而是指向自己的类型，这也是我们在学校学到的最好的做法</li></ul> <p><img src="/assets/img/1672042556733-d8cdd7b3-596f-45d0-be4c-0944d601b6d2.de3e665d.png" alt="image.png"></p> <ul><li>可以看出 4.9 的 list 变复杂了许多</li> <li>4.9 的 list 里没有数据，他的大小就是父类的数据大小，父类数据有两个指针<code>_M_next</code>和<code>_M_prev</code>，所以 4.9 的大小是 8 字节
<ul><li>2.9 是一个 node 指针，大小为 4</li></ul></li></ul> <h2 id="_6-2-迭代器的设计规则和-iterator-traits-的作用与设计"><a href="#_6-2-迭代器的设计规则和-iterator-traits-的作用与设计" class="header-anchor">#</a> 6.2 <strong>迭代器的设计规则和 Iterator Traits 的作用与设计</strong></h2> <p><img src="/assets/img/1672043094683-b209f206-8e15-4c03-a5aa-3556083e6207.659f4e32.png" alt="image.png"></p> <ul><li>Traits 的中文是特征。Traits 是人为设计制造的一种萃取机，萃取出你丢给它的东西的特征。标准库中有很多种 Traits，除了 iterator Traits 还有 Type Traits、Character Traits 等等</li> <li>iterator 是容器和算法之间的桥梁，以<code>rotate()</code>算法举例，看它想要知道 iterator 的哪些属性</li> <li><code>return typename iterator traits&lt;_Iter&gt;::iterator_category();}</code>想要萃取出 iterator 的 category。这个 category 指的是 Iterator 的移动性质，有的 Iterator 可以 ++，有的还能 --，有的可以跳着走（随机访问） +=3。所以<code>rotate()</code>想要知道它的 category，以便采取最佳的操作方式</li> <li><code>rotate()</code>还想知道 iterator 的 difference_type 和 value_type。
<ul><li>value_type：iterator 指的东西是什么 type，如容器里存的是字符串，这个 type 就是 string</li> <li>difference_type：两个 iterator 之间的距离应该用什么 type 来表示，比方说容器中两个离得最远的指针相减范围也不超过 232-1，就可以用 unsigned int</li></ul></li> <li>类似这样的提问在 C++ 标准库中有 5 种，本例给出了三种，剩下两种为 reference 和 pointer（但这两种未曾在标准库中使用），我们称这 5 个 type 为 iterator 的 associated type，迭代器必须定义出来，以便回答算法提问</li></ul> <p><img src="/assets/img/1672044165114-1bdc3967-8335-4834-af6a-383587d65081.75149771.png" alt="image.png"></p> <ul><li>右侧是提问的写法（直接问）</li> <li>大部分实现都用<code>ptrdiff_t</code>定义 difference_type，它通常被定义为 long int</li> <li>iterator_catefory 选择的是双向的标签，很合理</li></ul> <p><img src="/assets/img/1672044712589-343173d2-4199-4b77-be72-30e29c7794c8.a0663fa9.png" alt="image.png"></p> <ul><li>有时候传入算法的可能是一个指针，而非迭代器（泛化的指针），指针无法回答算法的问题，这时候就需要 traits 了（可以理解为加中间层）</li> <li>traits 可以区分是 class 设计出的 iterator 还是一般的指针
<ul><li>如果是 class 形式的 iterator，就直接用<code>::</code>问</li> <li>如果是指针，就用另外一种方式得到答案</li></ul></li></ul> <p><img src="/assets/img/1672045108880-5ccd6e60-9c80-417d-824f-6f52ba63ce62.b9551f6c.png" alt="image.png"></p> <ul><li>我们写一个 iterator_traits，如果传入的是 class iterator 就直接问，如果传入的是指针就进入偏特化的版本</li> <li>注意两个偏特化的 valut_type 都是 T，为什么后面那个不加 const 呢？我们需要 value_type 的主要目的是用它声明变量，声明一个无法被赋值的变量没什么用，所以两个都是 T</li> <li>下方框中的算法想要知道 iterator 的 value_type 时，通过把 iterator 放到 traits 中，间接问</li></ul> <p><img src="/assets/img/1672045902635-8059001d-f1a0-42df-8803-4287448361db.a16ce5b8.png" alt="image.png"></p> <ul><li>指针的 category 是 random_access_iterator_tag</li> <li>可以看出，算法发现手上是指针的时候，同样能回答五个问题</li></ul> <p><img src="/assets/img/1672046164324-5916fced-4fb3-4a91-9f9b-f1385c8ce991.444a3f42.png" alt="image.png"></p> <ul><li>后面会讲其他 traits</li></ul> <h2 id="_6-3-vector"><a href="#_6-3-vector" class="header-anchor">#</a> 6.3 vector</h2> <p><img src="/assets/img/1672109700681-e6ad927e-8c59-4a12-b65a-a2e602722c2b.8fc18632.png" alt="image.png"></p> <ul><li>如果空间不足，不可能原地扩充，都是重新找一个两倍大的地方</li> <li>用三个指针控制整个容器，<strong>start</strong>：起点，<strong>finish</strong>：终点，<strong>end_of_storage</strong>：整个空间的终点。所以 vector 的大小是 12 字节</li> <li>前闭后开，finish 指向最后一个元素的后面一个</li> <li>为什么<code>size()</code>的实现是<code>end()-begin()</code>而不是<code>finish-start</code>呢？因为未来 vector 的实现方式会改变，不再只有 start、finish、end_of_storage，但 size 是 end()-begin() 这点不会改变</li></ul> <p><img src="/assets/img/1672110533376-ecf31a30-e61f-458f-b955-21519b37f884.7b5d2b7e.png" alt="image.png"></p> <ul><li>两倍增长一定发生在放元素进去的时候，所以这里找了最具代表性的<code>push_back()</code></li> <li>如果没有空间了，就调用<code>insert_aux()</code>，<code>insert_aux()</code>上来依然要先检查有没有空间，因为它不光被<code>push_back</code>调用，还会被其他函数调用</li></ul> <p><img src="/assets/img/1672110826016-021be495-7739-44a4-a49e-a31c840ea29f.1b62730d.png" alt="image.png"></p> <ul><li>两倍增长的代码</li> <li>如果原大小为 0，则分配 1（个元素大小），如果原大小不为 0，则分配原大小的两倍。必须要有这样的特殊处理，因为 0 的两倍还是 0</li> <li>调用分配器按照新的大小分配空间</li> <li>分配空间后，先将原来的 vector 内容拷贝到新的 vector 中，然后再放新数据，并将插入点后的原内容也拷贝过来（因为可能会被<code>insert()</code>调用）</li> <li>每次空间扩充都会有大量的元素拷贝动作，会调用拷贝构造函数，而原来的数据也要一个个删除，所以也会大量调用析构函数，要注意这些开销</li></ul> <p><img src="/assets/img/1672111425152-21625f0a-ef39-4415-801d-dcc4d8b52321.8a23d32b.png" alt="image.png"></p> <ul><li>vector 是连续空间，迭代器无需单独设计成 class，指针即可</li> <li>把迭代器丢入萃取机后，会进入偏特化的版本</li></ul> <p><img src="/assets/img/1672111811550-48204f80-78b5-41ea-873e-13cc1e8455c3.a642e678.png" alt="image.png"></p> <ul><li>4.9 的 vector 也变得复杂，但可以发现大小依然是 12</li></ul> <p><img src="/assets/img/1672112030075-0b310e4f-db73-4faa-abb8-d83b83c2ca88.9bd8fa78.png" alt="image.png"></p> <ul><li>4.9 的迭代器，经过层层追踪，发现最后其实和 2.9 实现是差不多的</li></ul> <p><img src="/assets/img/1672112227315-557f9762-c59b-446c-82f1-a053f2fa9703.cc47970d.png" alt="image.png"></p> <ul><li>4.9 的迭代器本身是一个对象，不再是单纯的指针，对应类有 typedef 回答问题</li></ul> <h2 id="_6-4-array"><a href="#_6-4-array" class="header-anchor">#</a> 6.4 array</h2> <p><img src="/assets/img/1672114200703-1cbf2b07-8957-4611-8717-add911678785.f35e58bf.png" alt="image.png"></p> <ul><li>比起 vector 更简单，把它包装成容器是为了让它也可以调用算法等</li> <li>TR1 （C++03）的意思是技术报告，介于 C++98 和 C++11 之间</li> <li>和其他容器不同，必须指定大小</li> <li><code>value_type _M_instance[_Nm ? _Nm :1!];</code>非常直观，定义了数组，并且如果使用者指定的大小是 0，会自动变成 1</li> <li>没有构造函数和析构函数</li> <li>直接用指针当迭代器</li></ul> <p><img src="/assets/img/1672114679854-1bdb6157-5fae-4dad-99a4-e20f1d89dbd4.da0e5dcd.png" alt="image.png"></p> <ul><li>4.9 更复杂</li> <li>可以<code>int a[100];</code>，不可以<code>int[100] b;</code>，但是可以<code>typedef int T[100]; T c;</code>，G4.9 就是类似这种写法</li></ul> <p><img src="/assets/img/1672114870063-e1a3e0c2-9831-4476-abe9-c840c176291e.4f340d24.png" alt="image.png"></p> <ul><li>前面已经介绍过双向链表了，这个只是变成线状单向了而已</li></ul> <h2 id="_6-5-deque"><a href="#_6-5-deque" class="header-anchor">#</a> 6.5 deque</h2> <p><img src="/assets/img/1672114942275-4157b668-3c2b-46d3-88cb-934682c5e172.f1d23e2e.png" alt="image.png"></p> <ul><li>分段连续（连续是假象，分段是事实）</li> <li>结构是分段并用 vector 串接起来，我们将它称为“控制中心”（网络也有人将其称为主控、中控等），vector 里存放的元素是指针，分别指向各个 buffer。往后扩充仅需分配一个新的 buffer 再串到后面即可，往前扩充同理</li> <li>迭代器中的<code>node</code>指向控制中心，<code>first</code>和<code>last</code>指的是某段 buffer 的头和尾，这样如果走到某个 buffer 的尾部了可以通过控制中心跳到下一个 buffer，<code>cur</code>是迭代器正在指向的元素。同一个 buffer 中<code>first</code>和<code>last</code>都不会变，++ 或 -- 是<code>cur</code>在变，如果去到上一个或下一个<code>buffer</code>，四个参数都会变动</li> <li>几乎所有的容器都维护着两个迭代器，分别指向头和尾，deque 也不例外，所以图中下方画了两个迭代器</li></ul> <p><img src="/assets/img/1672122037058-65b62534-13c1-4152-9e10-c952871fed3d.701d2826.png" alt="image.png"></p> <ul><li>map 是 T**（因为 map 指向的每个元素也都是指针），map_size 是控制中心的大小</li> <li>每个 iterator 占 4<em>4=16 字节，map 和 map_size 各占 4 字节，所以一个 deque 的大小为 16</em>2+4+4 共 40 字节</li> <li><code>BufSiz</code>的默认值是 0，这里会涉及到<code>__deque_buf_size()</code>函数，如果这个值不是 0，比如 5，那么buffer size 就是 5；如果这个值是 0，会看元素大小，如果这个元素很大，大于 512 字节，那么每个缓冲区只放一个元素，即 buffer size 为 1，如果元素大小小于 512，那么 buffer size 就是 512/sz（如元素大小为4，那么就是 512/4）</li></ul> <p><img src="/assets/img/1672123581547-07b6a7f5-5b76-48cd-9799-43f7f6657bcb.eab50dae.png" alt="image.png"></p> <ul><li>迭代器的 category 是 random_access_iterator_tag，给外界制造连续假象</li></ul> <p><img src="/assets/img/1672123734892-0069be43-a2d7-4594-8fe5-21b9b19b6291.f3c48e22.png" alt="image.png"></p> <ul><li>因为插入元素肯定是要往前推或往后推，deque 聪明的一点是会判断插入位置离哪边更近一些（比方说总共有 10000 个元素，要在第五个位置插入，当然是把前四个往前推更快）</li> <li>一开始先判断是不是在头尾插入，是的话交给<code>push_front()</code>或<code>push_back()</code>去做，都不满足再调用<code>insert_aux()</code>函数完成</li></ul> <p><img src="/assets/img/1672124064406-03c45542-94c6-4867-b543-d51708d2ccd3.969153b7.png" alt="image.png"></p> <ul><li><code>insert_aux()</code>先判断离头部更近还是离尾部更近，然后执行对应的操作往前推或往后推</li></ul> <h3 id="_6-5-1-deque-如何模拟连续空间"><a href="#_6-5-1-deque-如何模拟连续空间" class="header-anchor">#</a> 6.5.1 deque 如何模拟连续空间</h3> <p><img src="/assets/img/1672124297398-77e91264-d935-47b0-8ad0-d0621fe5abb5.df95a171.png" alt="image.png"></p> <ul><li><code>front()</code>直接返回 start 指的内容，<code>back()</code>返回 finish 指的前一个元素（因为 finish 指的是最后一个元素的后一个），<code>size()</code>是 finish-start，但<code>-</code>肯定是做了重载的</li></ul> <p><img src="/assets/img/1672124589413-b6bd3c51-a515-4a01-86c5-ce53f8b35eb3.caac51db.png" alt="image.png"></p> <ul><li><code>*</code>是取<code>cur</code>的值。<code>-&gt;</code>没什么好说的</li> <li><code>-</code>计算两个迭代器间隔了多少元素，<code>node - x.node - 1</code>是两个迭代器在控制中心的距离，然后乘每个缓冲区里的元素个数，最后加上两个迭代器在各自缓冲区内相差的元素数
<ul><li>为什么要 -1？假设一个位置是 1，一个位置是 5，这两个之间其实只有 3 个缓冲区（2、3、4）</li></ul></li></ul> <p><img src="/assets/img/1672125106289-ed0c3f0d-a5e7-4782-b091-775285e66417.8d59fd7e.png" alt="image.png"></p> <ul><li>同样分为前置 ++ 和后置 ++，先 +，再检查 + 完之后有没有到达边界，如果到达边界就跳到下一个缓冲区的起点</li> <li>-- 则是先判断在不在这个缓冲区起点，在的话就跳到前一个缓冲区的最末端</li></ul> <p><img src="/assets/img/1672125072404-7c6d11a7-a37c-456c-97e8-fc67a48b9b64.c5d6f537.png" alt="image.png"></p> <ul><li>因为是模拟成了连续空间，所以应该可以随意移动位置，于是提供了 + 和 +=</li> <li>先判断计算完后是否会落在同一个缓冲区，如果要落到别的缓冲区，就计算要跨越多少个缓冲区，然后再退回控制中心切到正确的缓冲区，最后计算到正确的位置</li></ul> <p><img src="/assets/img/1672125757463-15e36fb1-4561-4743-80d3-b1ec07650b5d.192f2c4f.png" alt="image.png"></p> <ul><li><code>-=</code>相当于<code>+=</code>负的</li> <li>因为是模拟成连续的，自然也要能用中括号</li></ul> <p><img src="/assets/img/1672125876222-f9f6b541-b9e1-4b6f-bd14-51d81ffa2eee.505548b6.png" alt="image.png"></p> <ul><li>4.9，和其他几个容器形式差不多</li> <li>大小依然是 40</li> <li><code>BufSiz</code>参数被去掉了，无法自己指定每个 buffer 的大小</li></ul> <p><img src="/assets/img/1672126102465-fde31926-5989-4bf9-bbfc-df109ca8b627.7d0f455d.png" alt="image.png"></p> <ul><li>补充前面没有提到的，控制中心在空间不足的时候会扩充两倍（毕竟是 vector），但拷贝的时候是拷贝到新空间的中段，这样能够保证前方和后方都有余裕</li></ul> <h3 id="_6-5-2-queue-和-stack"><a href="#_6-5-2-queue-和-stack" class="header-anchor">#</a> 6.5.2 queue 和 stack</h3> <p><img src="/assets/img/1672126267375-2acc80f9-74c4-44d4-87da-f767650fc8e3.e7e457bb.png" alt="image.png"></p> <ul><li>queue 和 stack 无需重写功能，仅需内含一个 deque，再封锁住一些功能即可</li> <li>它们俩都是转调用<code>c</code>的函数，<code>c</code>就是 deque</li> <li>从技术上讲，不算容器，算容器适配器</li></ul> <p><img src="/assets/img/1672126549864-fb373895-d21f-43cf-ab68-5d6568279543.5bc62d94.png" alt="image.png"></p> <ul><li>从源代码的角度，如果另外一种容器也能提供这些函数让 queue 和 stack 转调用，那么就可以把 deque 换成别的。根据验证，list 也可以，既然 STL 选择了 deque，说明 deque 性能更好</li> <li>queue 和 stack <strong>都不允许遍历</strong>，也不提供迭代器</li></ul> <p><img src="/assets/img/1672126785129-5b1967f9-3808-4b13-b0bd-48b97fc3c76b.4c692122.png" alt="image.png"></p> <ul><li>stack 可以选择 vector 作为底层，queue 不行，因为 vector 不能 <code>pop_front()</code>。由此可以看出编译器不会对模板做全面检查，这也意味着，如果你不调用 queue 的 <code>pop()</code>，其他函数都可以调用通过</li> <li>queue 和 stack 都不能选择 set 或 map 作为底层</li></ul> <h2 id="_6-6-rb-tree"><a href="#_6-6-rb-tree" class="header-anchor">#</a> 6.6 rb_tree</h2> <h3 id="_6-6-1-rb-tree-深度探索"><a href="#_6-6-1-rb-tree-深度探索" class="header-anchor">#</a> 6.6.1 RB-tree 深度探索</h3> <p><img src="/assets/img/1672127292327-79a92ef8-f779-4ae6-a246-6a1de5ede7af.73a1f5c3.png" alt="image.png"></p> <ul><li>不讲红黑树具体的概念，只讲 STL 如何实现以及一些关键点</li> <li>红黑树是一种自平衡二叉查找树</li> <li>遍历红黑树会得到排序状态（sorted）。红黑树从最左边开始，会先走左边，再走右边。对应图，<code>begin()</code>是最左边的 5，<code>end()</code>是最右边的 15</li> <li><strong>不可以用迭代器赋值</strong>，会破坏红黑树的规则。在编程层面并不禁止这件事，因为用作 map 时，虽然 key 不可改变，但 data 是可以改的</li> <li>红黑树设计本身并不强制 key 不可重复，它提供<code>insert_unique()</code>和<code>insert_equal()</code>，前者在遇到重复的 key 时不会异常也不会报错，只是不会把它插入进去，后者则允许 key 重复</li></ul> <p><img src="/assets/img/1672128416937-6937e6d4-f060-4718-8693-47ed94e3c3ef.c1805e60.png" alt="image.png"></p> <ul><li>红黑树有 5 个模板参数，但是好在我们不会直接用它，而是用它更上层的 set、map</li> <li>我们将 key 和 data 合称为 value</li> <li><code>KeyOfValue</code>告诉红黑树在 value 里 key 要怎么拿出来；<code>compare</code>告诉红黑树 key 怎么比大小</li> <li>红黑树有三个数据，<code>node_count</code>是节点数量，<code>header</code>是指向红黑树节点的指针，<code>key_compare</code>是你传给它的那个比较函数（仿函数）。node_count 是 unsigned int，4 个字节，header 是指针，4 个字节，key_compare 是函数，没有数据，理论大小是 0，但实际上编译器会认为大小为 0 的 class 创建出的对象大小为 1，所以大小是 4+4+1=9。按照 4 的倍数对齐后是 12。</li> <li>header 就像双向循环链表里的虚空节点一样，是为了实现方便而放进去的</li></ul> <p><img src="/assets/img/1672129983271-15f29d21-087e-4dc6-b70b-2db3bb3831aa.ba851826.png" alt="image.png"></p> <ul><li>通过编写测试函数验证对红黑树的理解</li> <li>这里的设计是 key 就是 value，value 就是 key，<code>identity&lt;&gt;</code> 是仿函数，传什么给它，它就传回来什么，<code>less&lt;&gt;</code>用<code>&lt;</code>比大小</li></ul> <p><img src="/assets/img/1672130739879-e9316080-95c5-4fe8-b2a9-bd67460194d7.9bc2d7fe.png" alt="image.png"></p> <ul><li>测试用例</li> <li>通过 size 的可以看出<code>insert_unique()</code>和<code>insert_equal()</code>的区别</li></ul> <p><img src="/assets/img/1672131005024-1c74251c-b63a-4931-bfff-865ac7ec45c4.20f0ecb9.png" alt="image.png"> <img src="/assets/img/1672131097855-efe2f61c-a3cd-4210-96e2-3aed7703fdd4.df26f1c5.png" alt="image.png"></p> <ul><li>红色是 4.9 改动的地方，类和函数的名称都变了</li> <li>输出结果一致</li></ul> <p><img src="/assets/img/1672131154542-e4d6c0c8-0a2b-4034-b627-02b251565cfe.89dda999.png" alt="image.png"></p> <ul><li>4.9 有总共四个数据，<code>_M_color</code>是枚举，<code>_M_parent``_M_right``_M_left</code>是三个指针加起来共 24 个字节</li></ul> <h3 id="_6-6-2-set-和-multiset"><a href="#_6-6-2-set-和-multiset" class="header-anchor">#</a> 6.6.2 set 和 multiset</h3> <p><img src="/assets/img/1672131661454-4e0f60a1-0182-45ef-8047-669b319bb511.7e435c12.png" alt="image.png"></p> <ul><li>set/multiset 的 value 和 key 是合二为一的，key 就是 value，value 就是 key</li> <li>set/multiset 提供遍历操作和迭代器，遍历后获得的是排序状态</li> <li>我们无法用 set/multiset 的迭代器改变元素的值，因为不能改 key</li> <li>区别
<ul><li>set 元素的 key 必须独一无二，因此<code>insert()</code>调用的是 rb_tree 的<code>insert_unique()</code></li> <li>multiset 的 key 可以重复，因此<code>insert()</code>调用的是 rb_tree 的<code>insert_equal()</code></li></ul></li></ul> <p><img src="/assets/img/1672132156706-8b659b87-da3b-45d2-8320-14fb4f868e08.b4e661e0.png" alt="image.png"></p> <ul><li>可以看到，set 里的迭代器是 <strong>const</strong> iterator，避免使用者改变元素，破坏红黑树</li> <li>set 所有操作都是转调用底层的 t，t 就是红黑树，可以认为它是容器适配器</li></ul> <h3 id="_6-6-3-map-和-multimap"><a href="#_6-6-3-map-和-multimap" class="header-anchor">#</a> 6.6.3 map 和 multimap</h3> <p><img src="/assets/img/1672133022978-4a791f25-812f-4ce2-ad9c-0e390a930caa.22e50ad9.png" alt="image.png"></p> <ul><li>map/multimap 的排序依据是 key</li> <li>map/multimap 提供遍历操作和迭代器，遍历后获得的是排序状态</li> <li>我们无法用 map/multimap 的迭代器改变元素的 key，但可以用它来改变元素的 data</li> <li>区别
<ul><li>map 元素的 key 必须独一无二，因此<code>insert()</code>调用的是 rb_tree 的<code>insert_unique()</code></li> <li>multimap 的 key 可以重复，因此<code>insert()</code>调用的是 rb_tree 的<code>insert_equal()</code></li></ul></li></ul> <p><img src="/assets/img/1672133260208-e84fa800-2600-4b1c-8bfd-1b2814d1eea3.97cf7d21.png" alt="image.png"></p> <ul><li>key 和 data 被包成了一个 pair，注意它把 key 设为了 **const **以避免用户修改</li></ul> <p><img src="/assets/img/1672133918295-7050d461-38dc-49ba-b360-a78b136705f0.f9ba044c.png" alt="image.png"></p> <ul><li>map 独有的<code>[]</code>，返回和中括号内值相对应的 key 的 data，如果这个 key 不存在，就创建这个 key</li> <li>这个<code>[]</code>首先调用<code>lower_bound()</code>算法，这是二分查找
<ul><li>如果有重复元素，<code>lower_bound()</code>会返回其中的第一个；如果找不到，会返回最适合安插这个 key 的点</li></ul></li></ul> <h2 id="_6-7-hashtable"><a href="#_6-7-hashtable" class="header-anchor">#</a> 6.7 hashtable</h2> <h3 id="_6-7-1-hashtable-深度探索"><a href="#_6-7-1-hashtable-深度探索" class="header-anchor">#</a> 6.7.1 hashtable 深度探索</h3> <p><img src="/assets/img/1672138829214-3a242c02-8877-4367-87c0-a2d7bd1b85dd.4f4f7ddb.png" alt="image.png"></p> <ul><li>假设一个元素有 232 种变化，存储就要分配这种类型元素的大小*232 的空间，这显然不可能，而且这个元素只是可以有这么多种变化，会不会真的有那么多也不好说</li> <li>如果空间足够大，编号为几的元素就放到几号位置，现在空间不是那么大，就要用编号%空间大小，这时可能会发生碰撞。</li></ul> <p><img src="/assets/img/1672139328888-df7932d4-dbfc-4668-90a1-5dfa2c59e9ec.540bbd13.png" alt="image.png"></p> <ul><li>为了解决碰撞，采用链表把余数相同的串起来，即 Separate Chaining（分离链接法）</li> <li>hash table 里放的一般都是对象而不是数字，图上的数字是计算得到的 hash code</li> <li>如果链表太长，也会影响到查找效率，目前采取的做法是，如果元素数量 &gt;= 桶的数量，就将桶的数量增长两倍，然后重新打散</li> <li>桶的数量一般会选择质数，所以不是严格的两倍，而是选择两倍附近的一个质数，如 53*2=106，最后会选择 97。gcc 2.9 的做法是直接将这些质数写死，参见右上角</li></ul> <p><img src="/assets/img/1672139899887-0ab475f4-6a0d-4d8a-a89e-fedfbc1ec1c7.f2feebe5.png" alt="image.png"></p> <ul><li>六个模板参数，<code>Value</code>和<code>Key</code>和之前一样；<code>HashFcn</code>传进来是一个函数（仿函数），负责把对象转成编号，算出来的这个编号称为 hash code；<code>ExtractKey</code>负责取出 key，因为散列里存放的可能是 pair，需要告诉它怎么从一包东西中取出 key；<code>EqualKey</code>告诉 hashtable 什么叫相等，这样它才知道要落到哪个位置上</li> <li>hashtable 有五个数据，前三个<code>hash</code> <code>equals</code> <code>get_key</code>分别就是模板参数中的<code>HashFcn``EqualKey</code> <code>ExtractKey</code>，<code>buckets</code>是图片右侧的一堆桶，是 vector，<code>num_elements</code>记录当前有多少个元素。前三个理论大小是 0，实际大小是 1；buckets 是 vector，大小为 12；size_type 是 unsigned int，4个字节，加起来就是 1*3+12+4=19，调整为 4 的倍数后是 20 字节</li> <li>迭代器在走到一个链表的尾部时必须有能力到下一个桶，有点像 deque。图上绘制的箭头有误，<code>cur</code>应该指向元素</li></ul> <p><img src="/assets/img/1672141090756-7b46aa0f-a4b0-4c2b-80c3-7c4130115703.f15a33d9.png" alt="image.png"></p> <ul><li>编写测试函数</li> <li>其中放入的元素都是 C 风格的字符串，value 就是 key，key 就是 value。比较字符串的<code>strcmp()</code>函数返回的是 -1、0、1，但 hashtable 需要的比较函数必须返回 bool 值，所以自己编写了一个函数包装起来。</li> <li>hashtable 最重要的就是怎么把对象转成编号。用红黑树的时候只需要指定元素类型就可以了，但如果是 hashtable 做成的 set 和 map，必须写一个 hash 函数，这也算一种负担，好消息是标准库提供了一些，见下页</li></ul> <p><img src="/assets/img/1672141523443-31ad7558-c963-46d7-acfd-51fcdba07fb1.21c9983a.png" alt="image.png"></p> <ul><li>模板的偏特化，对<code>()</code>操作符做重载，如果指明的类型在这里面，这些东西就会成为仿函数</li> <li>这一页的都是数值，传 x 进去就传 x 出来</li> <li>如果需要自己写，就要像这页一样，为<code>hash{}</code>写一个特化版本</li></ul> <p><img src="/assets/img/1672141817668-27fb09a9-cfc9-4bc7-b898-644a96dbb90d.565af761.png" alt="image.png"></p> <ul><li>如果是 C 的字符串，就调用<code>__stl_hash_string()</code>函数计算</li></ul> <p><img src="/assets/img/1672142275233-6e7c55e9-f83c-435f-bee2-b979e15da3a2.09513366.png" alt="image.png"></p> <ul><li>左侧是 hashtable 里的部分函数，可以发现它调用了<code>bkt_num</code>和<code>bkt_num_key</code></li> <li>看一下箭头，发现这几个函数最后统统来到<code>bkt_num_key(const key_type&amp; key, size_t n) const</code>，它用的是 %。可见决定元素究竟落到哪个桶里用的就是取模</li></ul> <h3 id="_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap"><a href="#_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap" class="header-anchor">#</a> 6.7.2 hash_ set, hash_ multiset, hash_ map, hash_ multimap</h3> <p>视频遗失</p> <h3 id="_6-7-3-unordered-容器"><a href="#_6-7-3-unordered-容器" class="header-anchor">#</a> 6.7.3 unordered 容器</h3> <p><img src="/assets/img/1672143101159-af474467-3e8f-4c46-829b-bcbecc2c6566.330cff38.png" alt="image.png"></p> <ul><li>就是名字改了</li></ul> <h1 id="_7-算法"><a href="#_7-算法" class="header-anchor">#</a> 7.算法</h1> <h2 id="_7-1-算法的形式"><a href="#_7-1-算法的形式" class="header-anchor">#</a> 7.1 算法的形式</h2> <p><img src="/assets/img/1672192719386-672be406-34d2-46ea-a886-f9c2b7d5e64f.fd79cd8e.png" alt="image.png"></p> <ul><li>从语言层面上看，<strong>算法是函数模板</strong>，其他五个都是类模板</li> <li>算法只能通过迭代器进行运算，虽然算法看不到容器，但是可以通过“问答”了解容器的情况，以便更好的进行操作。</li></ul> <h2 id="_7-2-迭代器的分类-category"><a href="#_7-2-迭代器的分类-category" class="header-anchor">#</a> 7.2 迭代器的分类（category）</h2> <p><img src="/assets/img/1672193090677-a925d8b6-45c1-4a4d-a2fe-b755c018cfce.abafd52a.png" alt="image.png"></p> <ul><li>Array、Vector、Deque 是随机访问迭代器，List 是双向迭代器，Forward-List 是单向迭代器，红黑树是双向迭代器，Unordered 容器视每个桶的链表是单向还是双向而定（代码验证是单向迭代器）</li> <li>通过源代码可以发现，是 random_access_iterator_tag → bidirectional_iterator_tag → forward_iterator_tag → input_iterator_tag 的继承关系</li></ul> <p><img src="/assets/img/1672193591337-f0349bd3-6704-455a-a651-af27d0318e82.f791e3cf.png" alt="image.png"></p> <ul><li>测试代码，输出函数的模板实现和函数重载值得学习</li> <li>istream_iterator 和 ostream_iterator 比较特别，后面会专门讲</li></ul> <h2 id="_7-3-迭代器的分类对算法的影响"><a href="#_7-3-迭代器的分类对算法的影响" class="header-anchor">#</a> 7.3 迭代器的分类对算法的影响</h2> <p><img src="/assets/img/1672194517022-0adbb136-a354-4dfe-8c46-ec458951eee1.1a499877.png" alt="image.png"></p> <ul><li>以<code>distance()</code>举例，它主要是给其他算法使用的，负责计算两个指针的距离</li> <li>如果是随机访问迭代器就直接减，如果是其他迭代器就从头走到尾并计数</li> <li>许多算法中都是这样的结构，主函数根据迭代器分类调用次函数</li></ul> <p><img src="/assets/img/1672195059664-a1aed7d0-27f4-4a89-a99f-6786b1c63419.37a37453.png" alt="image.png"></p> <ul><li><code>advance()</code>，主要也是给其他算法调用的，走 n 个距离</li> <li>如果可以跳，就直接<code>i+=n</code>；如果是双向，就往前走或往后走；如果是单向，自然就只能往前走</li> <li>小区别，<code>distance()</code>是直接调用 traits 问，<code>advance()</code>把 traits 封装成了一个小函数再调用这个函数</li></ul> <p><img src="/assets/img/1672195518969-9fff7f6d-9778-41e4-91d3-a8bbcaaf1430.fc74176d.png" alt="image.png"></p> <ul><li><code>copy()</code>，只有三个参数，来源端的起点和终点，目的端的起点。看起来很简单，里面的实现却很复杂，为了找出一条效率最高的路线，无所不用其极</li> <li><code>has trivial op=()</code>这里是检查拷贝赋值重不重要（trivial 的意思是不重要），如果 trivial 的话就跳过拷贝赋值</li></ul> <p><img src="/assets/img/1672196617151-e3e778b6-1c7d-435c-8e3a-045a75ac9a1f.7d321865.png" alt="image.png"></p> <ul><li>另一个例子<code>destory()</code>，和<code>copy()</code>类似，要摧毁的对象的析构函数如果 trivial（不重要），就什么都不做</li></ul> <p><img src="/assets/img/1672196702798-96c5b540-786e-4bf0-bc36-09cfa4a2cdf8.ba7b3a91.png" alt="image.png"></p> <ul><li><code>__unique_copy()</code>，如果没有对 output iterator 做特殊处理，它也会跑到右下角处理 forward iterator 的函数，但是这个函数里面有 read 动作，而 output iterator 是 write-only，这是不允许的。于是标准库要针对 output iterator 单独写一个版本，避免 read 动作</li></ul> <p><img src="/assets/img/1672197151521-f349f82f-9121-4c62-aca2-77df60bca9e3.b64488a5.png" alt="image.png"></p> <ul><li>算法是模板函数，不能在语法层面强制要求一定要传给它哪种迭代器，但如果迭代器类型不合适在执行时会报错，为此算法特意修改模板参数名来暗示需要的迭代器。比如<code>sort()</code>函数是需要跳来跳去的，为了暗示，它没有用 T 或 I 命名迭代器的类型，而是用 RandomAccessIterator 命名。图中也列出了一些其他例子。</li></ul> <h2 id="_7-4-算法源码分析"><a href="#_7-4-算法源码分析" class="header-anchor">#</a> 7.4 算法源码分析</h2> <p><img src="/assets/img/1672197797381-bbcf540d-2a2c-4859-a3f5-103ba9178876.352d589a.png" alt="image.png"></p> <ul><li>可以看出 C 的算法是传各种参数，C++ 就像我们讲的一样是传迭代器了</li></ul> <p><img src="/assets/img/1672197890901-9e897ef0-e41a-46a9-a353-9aae9554e6ea.bef419ca.png" alt="image.png"></p> <ul><li><code>accumulate()</code>，累计，有两个版本</li> <li>第一个版本就是累加，第二个版本是做传进来的计算</li> <li>右侧测试也测试了自己写的函数和仿函数</li></ul> <p><img src="/assets/img/1672198492248-73047e10-e0b8-46d4-82aa-6d77b40ed993.ea4a464a.png" alt="image.png"></p> <ul><li>接受 first、last 和一个函数。调用函数处理从头到尾的每个元素</li></ul> <p><img src="/assets/img/1672198784031-1c24adf5-89f1-409f-b7a6-0125cf65c5d7.e0a5ceaf.png" alt="image.png"></p> <ul><li>接受 first、last、旧值、新值，元素如果和旧值相同，就替换成新值</li> <li><code>replace_if()</code>，参数多了一个条件（Predicate，判断式，返回真假）</li> <li><code>replace_copy()</code>，范围内所有旧值都以新值放到新的区间，其他则以原值放到新的区间</li></ul> <p><img src="/assets/img/1672199018903-26dfe5e7-9c65-4015-a7bb-97e6248bbe53.b57bb6c9.png" alt="image.png"></p> <ul><li>右侧整理了容器中是否带有同名的成员函数</li></ul> <p><img src="/assets/img/1672199842389-9195ae37-8938-4263-9e7e-6059daf2b262.edcc09af.png" alt="image.png"></p> <ul><li>发现有成员函数的还是这八个容器，因为这八个容器是关联容器，可以用 key 找到 value，所以可以想象它们会有更快地做法</li> <li>全局这个<code>find()</code>没有特殊的实现，就是一个一个找</li></ul> <p><img src="/assets/img/1672199856095-8568177f-b3f5-405e-99d2-8c87d4554e54.0f8dbeac.png" alt="image.png"></p> <ul><li><code>sort()</code>源码有好几百行，这里不给出，只示范用法</li> <li>注释中的并非屏幕实际输出内容，<code>()</code>的部分是为了说明排序的范围</li> <li><code>rbegin()</code>和<code>rend()</code>中的“r”是“reverse”的意思，看输出结果，变成了反向的排序</li> <li>排序是需要跳的，list 和 forward_list 都不能跳，所以有自己的成员函数实现排序</li></ul> <p><img src="/assets/img/1672213894714-58030e4d-6873-40cc-b432-68a7ee5a9f04.a1039fd6.png" alt="image.png"></p> <ul><li><code>rbegin()</code>指的是最后一个元素，<code>rend()</code>指的是第一个元素前一个。因为取数的方式不同，需要套一个适配器</li></ul> <p><img src="/assets/img/1672214157962-1f7a2c0f-792a-4876-b504-b9a43225441d.3b4e6fd3.png" alt="image.png"></p> <ul><li>二分查找一定要先排序</li> <li><code>binary_search()</code>把工作都交给了<code>lower_bound()</code></li> <li><code>lower_bound()</code>还有个兄弟是<code>upper_bound()</code>，见图片下方，如果序列是 10 10 10 20 20 20 30 30（只是这么表示，实际上可能是红黑树），想要安插 20，<code>lower_bound()</code>会找最低点，把新的 20 放到 10 和 20 之间，<code>upper_bound()</code>则是找最高点，把新的 20 放到 20 和 30 之间。</li></ul> <h1 id="_7-仿函数"><a href="#_7-仿函数" class="header-anchor">#</a> 7.仿函数</h1> <p><img src="/assets/img/1672214770003-8339cee2-0065-4849-b29d-56bdf75b568c.b9e4a108.png" alt="image.png"></p> <ul><li>六大部件里最简单的</li> <li>如果你希望设定一些额外的准则辅助实现算法，就可以用到函数或仿函数，如<code>sort()</code>里的<code>cmp()</code></li> <li>为了模仿函数，这个 class 必须重载<code>()</code></li></ul> <p><img src="/assets/img/1672215105543-94990fc8-190a-4cc9-81f4-ee2e6c3749ed.a29433b4.png" alt="image.png"></p> <ul><li>一些 gcc 独有，非标准的仿函数，好多都是我们之前用过的</li></ul> <p><img src="/assets/img/1672215469909-9ca9f9f9-c2c8-47ee-b64d-8d7c4803414f.968df8ed.png" alt="image.png"></p> <ul><li>可以看出用函数、用函数对象都可以，用<code>()</code>产生的临时对象也可以</li> <li>如果自己写仿函数，并希望以后能易于修改，被 adapter 改造，融入 STL，需要继承一些给定的基类。</li></ul> <p><img src="/assets/img/1672215808713-aafa72a9-1510-4817-b15b-8a9e1cb16974.ce47ef1d.png" alt="image.png"></p> <ul><li>一个参数的继承<code>unary_function</code>，两个参数的继承<code>binary_funcation</code>，根据函数选择适当的来继承</li> <li>只有继承之后，仿函数才是 adaptable（可适配的），以回答 adapter 的提问</li></ul> <h1 id="_8-适配器"><a href="#_8-适配器" class="header-anchor">#</a> 8.适配器</h1> <p><img src="/assets/img/1672216773931-d57d49ee-37e0-407b-afd2-63902233d0da.b8e4ea82.png" alt="image.png"></p> <ul><li>改造既有的东西，如三个参数的改成两个参数的，修改函数名称等</li> <li>不是单独的出现在某一块，而是出现在三个地方：容器适配器、仿函数适配器、迭代器适配器</li> <li>比方说 A（适配器）改造了 B，那么 A 就代表了 B 给大家使用，而 A 做的主要的事都是交给 B 去做，从这个角度来说，适配器像是使用者和隐藏在某后的 B 的桥梁。既然 A 要用 B 的功能，有两种做法：继承和复合。接下来我们要讨论的适配器都是通过复合实现的，如容器适配器会内含一个容器</li> <li>适配器改造什么，自己就要变现成什么，如它是容器适配器，表现出来就应该是容器的样子</li> <li>之前迭代器用 5 个 typedef 回应算法的问题，仿函数也要用 2 个或 3 个 typedef 回应适配器的问题</li></ul> <h2 id="_8-1-容器适配器"><a href="#_8-1-容器适配器" class="header-anchor">#</a> 8.1 容器适配器</h2> <p><img src="/assets/img/1672216944313-39be3f72-9cb7-43d1-9186-429237a04436.df95c872.png" alt="image.png"></p> <ul><li>最简单的适配器</li> <li>stack 和 queue 都内含 deque，选择性的封闭了一些接口，并且改了名字，如stack 把<code>push_back()</code>改名为了<code>pop()</code></li></ul> <h2 id="_8-2-仿函数适配器"><a href="#_8-2-仿函数适配器" class="header-anchor">#</a> 8.2 仿函数适配器</h2> <p><img src="/assets/img/1672217528466-cf8cf3bc-220c-4e1e-86d4-8b9d24658ac2.dcfd0820.png" alt="image.png"></p> <ul><li><code>less(x,y)</code>本来是比较 x 和 y，但是现在我希望找出小于 40 的数，也就是我想让它和 40 比，就可以用<code>bind2nd()</code>函数将第二参数绑定为 40</li> <li><code>bind2nd()</code>实际是用<code>binder2nd</code>执行操作，代码在图片右侧</li> <li>构造函数会将函数对象记录到 op，将数值记录到 value，等后面它被调用的时候，它才会调用 op 并将 value 作为第二参数</li> <li>它是仿函数适配器，要表现成一个仿函数的样子，所以也要重载<code>()</code></li> <li><code>binder2nd</code>是一个类模板，但很多人可能写不出<code>less&lt;int&gt;()</code>的类型，为了方便用户，STL 在外面包了一个<code>bind2nd()</code>给用户调用。因为在函数模板中编译器可以自动推导 op 的类型，所以它就可以把推导结果传给<code>binder2nd</code>作为模板参数</li> <li>灰色的代码就是问答环节。因为是<code>less&lt;int&gt;</code>，后面绑定的第二实参应该是整数，为了做到检查，左侧<code>bind2nd()</code>中的<code>Operation::second_argument_type</code>就会问第二实参是什么类型，然后看 x 能不能转为这个类型，如果不能，这里就会编译失败，避免运行时才报错。右侧同理，<code>binder2nd</code>返回的应该是<code>less&lt;int&gt;</code>返回的类型，毕竟它只是适配器，不应该连返回类型都变了，所以它会问<code>Operation::result_type</code>，包括传进来的参数类型也不能乱，所以问<code>Operation::first_argument_type</code>。一个函数必须能回答这三个问题，才能和这个适配器搭配</li> <li><code>binder2nd</code>如果还要被其他适配器修饰，依然要回答问题，所以它继承了<code>unary_function</code>，很正规的写法</li> <li>设计模式：适配器模式</li></ul> <p><img src="/assets/img/1672219940798-bcd0f201-b564-4c98-965d-d43e6c4b2bf3.44f8c318.png" alt="image.png"></p> <ul><li><code>binder1st</code> <code>binder2nd</code> <code>bind1st</code> <code>bind2nd</code>现在都过时了，通通用<code>bind</code>取代。但因为之前也是标准里的，所以要用也依然可以用</li></ul> <p><img src="/assets/img/1672223141625-59fce124-1201-45e7-aec8-3d7ae1e9a5be.00149fd0.png" alt="image.png"></p> <ul><li><code>not1()</code>继续修饰右边的东西</li> <li>整个分析和上面完全一样，不过它只用记一个东西：pred</li></ul> <p><img src="/assets/img/1672223615894-d12179a4-f3cb-4ce4-8006-9d680e0d5348.b3d34b5e.png" alt="image.png"></p> <ul><li><code>bind()</code>可以绑定
<ul><li>函数</li> <li>函数对象（仿函数）</li> <li>成员函数</li> <li>data member（类里的 data）</li></ul></li> <li><code>auto fn_half = bind(my_divide,_1,2);</code>绑定第二个参数为 2，第 1 个参数则没有绑定，因此调用的时候必须给 1 个参数。其中<code>_1</code>是占位符（place holder），意味着实际调用的第 1 参数</li> <li><code>auto fn_invert = bind(my_divide,_2,_1);</code>两个参数都空出来没有绑定，并且将顺序反了过来，用的时候第 1 实参会落到<code>_1</code>的位置，第 2 实参会落到<code>_2</code>的位置上</li> <li><code>auto fn_rounding = bind&lt;int&gt;(my_divide,_1,_2);</code>指定了模板参数（也只能指定一个），这个参数代表了返回类型。前面几个都没指定，return type 就是它绑定的东西的 return type，即 double</li> <li><code>MyPair ten_two{10,2};</code>是 C++11 的写法，代表着给初值</li> <li>成员函数其实有一个看不见的实参：this，所以要么写上占位符：<code>auto bound_memfn = bind(&amp;MyPair::multiply, _1);</code>要么写上绑定谁：<code>auto bound_memdata = bind(&amp;MyPair::a, ten_two);</code></li> <li><code>int n = count_if(v.cbegin(), v.cend(), not1(bind2nd(less&lt;int&gt;(),50)));</code>其中的<code>cbegin()</code>和<code>cend()</code>意味着 const，传回来的迭代器是 const，不修改内容。返回的是不小于 50 的，即大于等于 50 的，有 5 个</li> <li><code>bind()</code>分两行。<code>auto fn_ = bind(less&lt;int&gt;(), _1, 50);</code> <code>cout &lt;&lt; count_if(v.cbegin(), v.cend(), fn_)&lt;&lt; end1;</code>，返回小于 50 的，有 3 个。</li></ul> <h2 id="_8-3-迭代器适配器"><a href="#_8-3-迭代器适配器" class="header-anchor">#</a> 8.3 迭代器适配器</h2> <p><img src="/assets/img/1672225322260-c517e056-0a26-4f6d-8c44-c46ade94e699.a7b43f1e.png" alt="image.png"></p> <ul><li>逆向迭代器的 5 个 associated types 都与正向迭代器相同</li> <li>关键是取值的部分，逆向迭代器取值就是正向迭代器退一个取值。因为<code>rbegin()</code>其实和<code>end()</code>差了一格</li> <li>逆向的<code>++</code>就是正向的<code>--</code>，反之亦然。逆向的<code>+n</code>就是正向的<code>-n</code>。</li></ul> <p><img src="/assets/img/1672226172433-dccf1dc3-17f8-4ced-a763-55141f1ab2bf.8ba3efa0.png" alt="image.png"></p> <ul><li><code>copy()</code>只管赋值，不管目的端空间充不充足，所以如果目的端空间不够，就可能赋值到不该赋的地方。而如果加入<code>inserter()</code>，就可以自己弄出一块空间来</li> <li>因为链表不是连续空间，所以这里不能直接迭代器+3，而是调用了<code>advance()</code>函数</li> <li>这里非常巧妙地使用了操作符重载，解决 copy 已经写死了，只能赋值的问题</li> <li>实际执行的是<code>insert_iterator</code>, 巧妙在<code>=</code>是作用在 result 身上的，而 result 现在是<code>inserter(foo,it)</code>，我们将赋值操作接管了，接管后改成调用这个容器的<code>insert()</code></li></ul> <h2 id="_8-4-未知适配器"><a href="#_8-4-未知适配器" class="header-anchor">#</a> 8.4 未知适配器</h2> <p><img src="/assets/img/1672227031681-02e91fa5-62b9-4be4-ad47-7497aa4d2f39.ebeb0724.png" alt="image.png"></p> <ul><li>istream_iterator 和 ostream_iterator 都不属于前面的三种适配器，所以算未知</li> <li><code>std::ostream_iterator&lt;int&gt; out_it(std::cout, &quot;,&quot;);</code>第二参数的<code>,</code>是分割符号</li> <li>同样通过操作符重载。先将<code>cout</code>存到<code>s</code>，将<code>,</code>存到<code>delimiter</code>，赋值的时候把<code>value</code>丢到<code>cout</code>，如果存在分隔符，把分割符也丢出去</li></ul> <p><img src="/assets/img/1672227885431-fc39681b-697b-4229-a227-58125124b4b4.6a57705d.png" alt="image.png"></p> <ul><li>使用 istream_iterator 定义出两个对象，eos 和 iit。eos 是 end of steam，作用类似标兵，没有参数，意味着 cin 的结束。iit 有参数，参数为 cin，根据源码，这个有参数的对象一旦创建，就会开始等待用户输入了</li> <li><code>++iit</code>的意思就是再读一个输入（见<code>++</code>的重载）</li></ul> <p><img src="/assets/img/1672227787236-bac30b8d-43c5-4b61-ae0a-84ba4b126bce.f63ef172.png" alt="image.png"></p> <ul><li><code>copy()</code>把从<code>cin()</code>读到的数据不断放到容器里</li></ul> <h1 id="_9-stl-周边技术与应用"><a href="#_9-stl-周边技术与应用" class="header-anchor">#</a> 9.STL 周边技术与应用</h1> <h2 id="_9-1-一个万用的哈希函数"><a href="#_9-1-一个万用的哈希函数" class="header-anchor">#</a> 9.1 一个万用的哈希函数</h2> <p><img src="/assets/img/1672294168615-55ade354-74aa-4701-801b-2398e9744480.9926d2d1.png" alt="image.png"></p> <ul><li>基本的数据类型无非就是数字、字符串，既然它们都已经有了哈希函数，有没有可能把我们自己设计的数据结构拆分成这些，然后把它们各自的 hash code 加起来作为这种元素的哈希值？</li> <li>两种形式都可以，左侧是类里的成员函数，右侧是普通的函数，重要的是函数内部怎么做。<code>size_t(*)(const Customer&amp;)</code>意思是函数的类型</li></ul> <p><img src="/assets/img/1672294514663-d300aceb-577c-4456-8a72-1ce45d860483.79995bd8.png" alt="image.png"></p> <ul><li>假设 Customer 里有三个数据，fname、lname（意味 first name 和 last name）和 no</li> <li>左上角的写法不是不行，但经验认为这样写太天真，可能会产生较多的碰撞</li> <li>TR1 开始提供了<code>hash_val()</code>，比直接加要好
<ul><li>① 接受的模板参数是任意个（因为用户调用的时候传入的参数是不确定的）</li> <li>② 接受的模板参数也是任意个，但是函数的第一个参数是<code>size_t</code>类型的</li> <li>③ 函数的前两个参数和 ② 相同，但没有第三个参数</li> <li>④ 是改变种子，本质就是越乱越好</li></ul></li> <li><code>hash_val(c.fname, c.lname, c.no);</code>的第一个参数不是<code>size_t</code>类型，所以会调用到 ①。① 给参数加上一个 seed 参数后传给 ②。② 先对 seed 调用 ④，再继续调用 seed 和参数，每次 ② 都会把参数拆成 1 个和多个，如果参数依然还剩多个就递归调用自己，只剩一个参数的话就调用 ③，简单来说就是逐一取 val 改变 seed。</li></ul> <p><img src="/assets/img/1672295916718-35131563-c7b2-444a-a86a-389511268ffa.5af91b0b.png" alt="image.png"></p> <ul><li>那个神奇的 0x9e3779b9 其实是黄金比例</li></ul> <p><img src="/assets/img/1672296055188-16e1e6af-b928-4866-8f12-dc828c83260c.f9068047.png" alt="image.png"></p> <ul><li>4.9 下编写的测试代码，6 后面应该是 7、8、9、10，图上抄错了，不影响结果</li> <li>hh 代表哈希函数</li> <li><code>%11</code>是因为桶有 11 个，这样可以输出落到哪个桶里</li></ul> <p><img src="/assets/img/1672296350188-95fda60f-06a8-4fbb-a544-e4f6be97393f.f327b14a.png" alt="image.png"></p> <ul><li>除了开头说的两个形式，还有第三个形式，为自己的元素类型写一个偏特化版本</li></ul> <p><img src="/assets/img/1672296417799-987621f1-7b8f-4c2f-838f-e7640ea2342d.a21e1e38.png" alt="image.png"></p> <ul><li>为 MyString 写特化版本，参考标准库中 string 的形式（2.9 里没有 string 的哈希函数实现，只有 char* 的，但 4.9 有）</li></ul> <h2 id="_9-2-tuple"><a href="#_9-2-tuple" class="header-anchor">#</a> 9.2 tuple</h2> <p><img src="/assets/img/1672303760272-3c964989-2249-4fef-9d6a-813d7af32b43.1fc20e26.png" alt="image.png"></p> <ul><li>能组合任意数量的任意类型</li> <li><code>tuple&lt;string,int,int,complex&lt;double&gt;&gt; t;</code>有趣的是，t 的大小并非是 4+4+4+16=28，而是 32，原因未知</li> <li><code>tuple&lt;int,float,string&gt; t1;</code>的大小是 12，符合预期</li> <li><code>get&lt;0&gt;(t1)</code>是把 t1 的元素的第一个元素取出来</li> <li>也可以用<code>make_tuple()</code>配合 auto 来创建一个 tuple，无需指定类型，编译器会为我们自动推导</li> <li>tuple 可以比大小，可以整体赋值。</li> <li><code>tie</code>是把这三样东西和 tuple 捆绑在一起，类型要一一对应，捆绑之后 i1、f1、s1 就等同于 t3 中的 77、1.1、&quot;more light&quot;</li> <li>typedef 后可以用<code>tuple_size</code>获取元素个数，用<code>tuple_element</code>获取第 n 个元素，这些都不是调用参数，而是对类型做操作，算是 meta programming（元编程）</li></ul> <p><img src="/assets/img/1672304925722-63a6f585-7357-4248-875e-b804fbd1fc05.3111fb28.png" alt="image.png"></p> <ul><li>同样用到了参数可变模板配合递归，非常漂亮</li> <li>但是哈希函数的递归是不断调用，这里的递归是不断继承，头部继承尾部。到最后没有参数可以继承的时候就会走到最上方的特化版本（空类），结束递归</li> <li><code>head()</code>和<code>tail()</code>的分析见图片中间</li></ul> <h2 id="_9-3-type-traits"><a href="#_9-3-type-traits" class="header-anchor">#</a> 9.3 type traits</h2> <h3 id="_9-3-1-type-traits-测试"><a href="#_9-3-1-type-traits-测试" class="header-anchor">#</a> 9.3.1 type traits 测试</h3> <p><img src="/assets/img/1672306214945-fc9978ec-be40-44aa-82ce-b1e32588289e.dbbb10f4.png" alt="image.png"></p> <ul><li>2.9 的 type traits 比较平淡</li> <li>六个 typedef
<ul><li><code>this_dummy_member_must_be_first</code> 和实现有关，不细讲</li> <li><code>has_trivial_default_constructor</code>默认构造函数重不重要</li> <li><code>has_trivial_copy_constructor</code>拷贝构造重不重要</li> <li><code>has_trivial_assignment_operator</code>拷贝赋值重不重要</li> <li><code>has_trivial_destructor</code>析构函数重不重要</li> <li><code>is_POD_type</code>是否为 C 风格的 struct</li></ul></li> <li>后面五个默认回答都是 false，即重要。如果你自己写一个类型，你知道哪个不重要，就可以为这个泛化的设计写出特化的版本。如下面两个示例，int 和 double 这五个都不重要，它们本来也没有这些构造函数之类的</li> <li><code>__type_traits&lt;Foo&gt;::has_trivial_destructor</code>就是提问的方式</li> <li>实用性不是很高，许多人在写自己的类的时候都想不到还要特化一个 traits</li></ul> <p><img src="/assets/img/1672309261211-d5b5c00d-8f35-404a-9e75-af7c81729d4c.908fe072.png" alt="image.png"></p> <ul><li>C++11 提供了几十个 type traits，可以发现有和之前对应的，但是改名了</li> <li>不再需要用户自己实现偏特化，只要把类丢给它它就能回答问题</li></ul> <p><img src="/assets/img/1672309626643-87a14aa8-7085-432a-89ab-4e534a375f70.10b0f51a.png" alt="image.png"></p> <ul><li>测试代码</li> <li>丢了一个 string 进去</li> <li>一个类如果有指针，大概率是要写析构函数的，string 里有指针，也有析构函数（图中 546 行）。根据 OO，如果一个类要成为父类，析构函数就应该是 virtual 的，设计上 string 没有打算成为父类，所以析构函数就不是 virtual 的。然后看输出结果<code>has_virtual_destructor</code>是 0，可见 traits 真的知道它有没有虚析构函数</li></ul> <p><img src="/assets/img/1672310383806-42bbddd0-e7ad-4918-a99c-cd1028c6d0fe.92cd5c61.png" alt="image.png"></p> <ul><li>很单纯，只有 int，没有成员函数，其实等同于 C 的 struct。果然，输出的<code>is_pod</code>是 1</li></ul> <p><img src="/assets/img/1672310648864-20c866f6-029c-4248-877c-5e488b664b88.649b4fd2.png" alt="image.png"></p> <ul><li>特意放了一个虚析构函数。<code>has_virtual_destructor</code>是 1</li> <li><code>is_polymorphic（多态）</code>是 1，polymorphic class 是一个有声明或继承了虚函数的 class，它确实有虚函数</li></ul> <p><img src="/assets/img/1672310851448-5bdc4941-1fc7-4efc-9c79-5046d48ed4f5.a53eac06.png" alt="image.png"></p> <ul><li>Zoo 有构造函数、移动构造（move_construtor）、拷贝赋值</li> <li><code>Zoo(const Zoo&amp;) = delete</code>的意思是不要拷贝构造函数，如果不这么写编译器会默认生成，同理，移动赋值也没要</li> <li><code>is_default_constructible</code>是 0，因为已经自己写了构造函数，编译器不会再给你默认构造函数；<code>is_copy_constructible</code>是 0，因为拷贝构造被 delete 了；<code>is_move_constructible</code>是 1，确实有移动构造，<code>is_copy_assignable</code>是 1，确实有拷贝赋值；<code>is_move_assignable</code>是 0，因为移动赋值被 delete 了。都可以对应上。</li></ul> <p><img src="/assets/img/1672311259828-e3f9440c-d086-4898-afe3-fd9198b09a73.a2a4d9f3.png" alt="image.png"></p> <ul><li>复数只有实部虚部，没有指针，所以析构函数不重要。<code>__has_trivial_destructor</code>是 1</li> <li>注意，复数中不是没有析构函数，编译器会给它默认的析构函数，但那个里面什么都没做，所以不重要</li></ul> <h3 id="_9-3-2-type-traits-实现"><a href="#_9-3-2-type-traits-实现" class="header-anchor">#</a> 9.3.2 type traits 实现</h3> <p><img src="/assets/img/1672311408487-5b233c42-8761-4f11-91d7-aff33c77be77.81797a77.png" alt="image.png"></p> <ul><li>从最简单的<code>is_void</code>开始，这里都是通过模板对类型做操作</li> <li>它先把对判断没帮助的 const 和 volatile 关键字去掉（借助<code>remove_cv</code>）。可以发现每个实际执行的地方都是一个泛化和一个偏特化，如<code>remove_const</code>，泛化就是传给 T 就返回（严格来讲不叫返回，更像是回答、回应） T，有 const 则会传给偏特化，返回去掉 const 的。</li> <li>去掉 const 和 volatile 之后它会把东西丢给<code>__is_void_helper</code>，它的泛化版本都回答假，如果是 void 特化就回答真。</li></ul> <p><img src="/assets/img/1672312115856-cb837da8-66f1-4a37-ab34-837c0523fdff.e98fd5f6.png" alt="image.png"></p> <ul><li><code>is_integral</code>也是先拿掉 cv，再丢给 helper，泛化回答假，偏特化回答真</li></ul> <p><img src="/assets/img/1672312309252-d95a63f4-f779-43d9-ae39-65f01c2d4c3f.90d2cdc4.png" alt="image.png"></p> <ul><li>蓝色都是没有出现在 C++ 标准库源码中的，推测是编译器实现的</li></ul> <h2 id="_9-4-cout"><a href="#_9-4-cout" class="header-anchor">#</a> 9.4 cout</h2> <p><img src="/assets/img/1672312730056-36a1f718-c7d1-48fc-85d0-1443bdb86a7a.edf32faf.png" alt="image.png"></p> <ul><li>cout 之所以可以接受那么多类对象，是因为标准对操作符<code>&lt;&lt;</code>做出了非常多的重载</li></ul> <p><img src="/assets/img/1672312752526-10c86097-01ba-4681-bfcd-75153a9655de.ad0ad5be.png" alt="image.png"></p> <ul><li>如果是自己写的类型，想要 cout，就要自己对<code>&lt;&lt;</code>做重载</li></ul> <h2 id="_9-5-move"><a href="#_9-5-move" class="header-anchor">#</a> 9.5 move</h2> <p><img src="/assets/img/1672313174950-c147e48d-0594-47ec-8d8f-2cf7856e35f3.fcab5ab5.png" alt="image.png"></p> <ul><li>move 是 C++11 中加入的，主要在另一门课中讲解</li> <li>放到容器里的元素加不加 move 功能会对速度有很大的影响</li> <li>每个画面的上半部分是 moveable 元素的测试结果，下半部分是 non-moveable 元素的测试结果，数量都是三百万。可以发现 moveable 元素会快很多</li> <li>为什么三百万元素需要七百多万的拷贝构造？因为 Vector 双倍扩容的时候也要拷贝构造</li></ul> <p><img src="/assets/img/1672314355323-9fa36a58-cd57-42f9-9342-3e8f14d3d4f9.f9a61345.png" alt="image.png"> <img src="/assets/img/1672314505115-ef1c3323-52fd-4a14-8c32-24d7a6e20cb7.c030d684.png" alt="image.png"> <img src="/assets/img/1672314519805-5a23b668-55de-4fd5-9e2d-19be5566ed58.95db14c0.png" alt="image.png"> <img src="/assets/img/1672314532277-48a57200-1eda-42bb-9044-12885cb2e563.78c68ce5.png" alt="image.png"></p> <ul><li>list、deque、multiset、unordered_multiset 在构造时差别都不大，因为它们都是节点式的，不像 Vector 一样是连续的，一定要两倍扩容</li> <li>当然，它的影响不只存在于构造的时候，后面的操作都会影响，所以 2.0 很强调 move</li></ul> <p><img src="/assets/img/1672314641309-c91ca75f-d9dc-457a-b5e7-7a4ca89bef25.6f0de911.png" alt="image.png"> <img src="/assets/img/1672314709320-e2e15880-ecce-4f47-9eb6-9514cf9b6fd8.ed2563cf.png" alt="image.png"></p> <ul><li>静态的要在类外给初值</li> <li>copy 是深拷贝，不只把指针拷贝过来，还把指针指向的对象也拷贝过来。</li> <li>浅拷贝就是 move 的动作，差别在于<code>&amp;&amp;</code>上，其实就是把指针指过来，再把原来的指针断掉</li> <li>moveable 版本的析构函数要把指针删掉，并且为了避免同一个指针被删掉两次，要提前做检查</li> <li>但是浅拷贝更危险，move 不能乱用，自己写代码的时候一定要确认之前的东西不会再使用了才能 move</li></ul> <p><img src="/assets/img/1672315281877-50629708-2c04-46ae-997c-8614bdf381f7.b4663fda.png" alt="image.png"></p> <ul><li><code>M c11(c1)</code>是 copy，<code>M c12(std::move(c1))</code>是 move</li> <li><code>c1.insert(ite, V1type(buf))</code>是右值，临时对象，编译器知道不会再用了，就会自动去找 move 版本。而下面的 c1 不是临时对象，编译器不敢自作主张调用 move 版本，所以需要用<code>M c12(std::move(c1))</code>告诉编译器用 move 版本</li></ul> <p><img src="/assets/img/1672316873506-cb634a22-2c4d-4b2d-92ef-dbcb73c1410f.ccc3a34b.png" alt="image.png"></p> <ul><li>vector 的深拷贝就是把来源端拷贝一份到目的端</li></ul> <p><img src="/assets/img/1672316951023-207bbaf5-3799-43de-821b-a29daef65cac.58517150.png" alt="image.png"></p> <ul><li>浅拷贝是调用<code>vector(vector &amp;&amp; __x)</code>，做的事就是把来源端和目的端的三根指针交换（swap）</li></ul> <p><img src="/assets/img/1672317138933-4c6c8b46-5094-44d4-9ae7-9ff2336fd864.163c3da7.png" alt="image.png"></p> <ul><li>可以看到 string 有 move 版本，可以安心使用</li></ul> <p>其他参考：</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_1-1-认识-headers、版本、重要资源" class="sidebar-link reco-side-_1-1-认识-headers、版本、重要资源" data-v-70334359>1.1 认识 headers、版本、重要资源</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_1-2-stl-体系结构基础介绍" class="sidebar-link reco-side-_1-2-stl-体系结构基础介绍" data-v-70334359>1.2 STL 体系结构基础介绍</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#image-png-images-1671938612663-ac5cdf36-34b5-44d2-acd9-791476db9a48-png" class="sidebar-link reco-side-image-png-images-1671938612663-ac5cdf36-34b5-44d2-acd9-791476db9a48-png" data-v-70334359>!image.png</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-1-结构与分类" class="sidebar-link reco-side-_2-1-结构与分类" data-v-70334359>2.1 结构与分类</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-序列式容器" class="sidebar-link reco-side-_2-2-序列式容器" data-v-70334359>2.2 序列式容器</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-1-array" class="sidebar-link reco-side-_2-2-1-array" data-v-70334359>2.2.1 array</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-2-vector" class="sidebar-link reco-side-_2-2-2-vector" data-v-70334359>2.2.2 vector</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-3-list" class="sidebar-link reco-side-_2-2-3-list" data-v-70334359>2.2.3 list</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-4-forward-list" class="sidebar-link reco-side-_2-2-4-forward-list" data-v-70334359>2.2.4 forward_list</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-5-deque" class="sidebar-link reco-side-_2-2-5-deque" data-v-70334359>2.2.5 deque</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-2-6-stack" class="sidebar-link reco-side-_2-2-6-stack" data-v-70334359>2.2.6 stack</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-关联式容器" class="sidebar-link reco-side-_2-3-关联式容器" data-v-70334359>2.3 关联式容器</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-1-multiset" class="sidebar-link reco-side-_2-3-1-multiset" data-v-70334359>2.3.1 multiset</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-2-multimap" class="sidebar-link reco-side-_2-3-2-multimap" data-v-70334359>2.3.2 multimap</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-3-unordered-multiset" class="sidebar-link reco-side-_2-3-3-unordered-multiset" data-v-70334359>2.3.3 unordered_multiset</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-4-unordered-multimap" class="sidebar-link reco-side-_2-3-4-unordered-multimap" data-v-70334359>2.3.4 unordered_multimap</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-5-set" class="sidebar-link reco-side-_2-3-5-set" data-v-70334359>2.3.5 set</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-6-map" class="sidebar-link reco-side-_2-3-6-map" data-v-70334359>2.3.6 map</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-3-7-unordered-set-和-unordered-map" class="sidebar-link reco-side-_2-3-7-unordered-set-和-unordered-map" data-v-70334359>2.3.7 unorderedset 和 unorderedmap</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_2-4-其他补充" class="sidebar-link reco-side-_2-4-其他补充" data-v-70334359>2.4 其他补充</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_4-1-源码分布" class="sidebar-link reco-side-_4-1-源码分布" data-v-70334359>4.1 源码分布</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程" class="sidebar-link reco-side-_4-2-oop-object-oriented-programming-面向对象编程-vs-gp-genic-programming-泛型编程" data-v-70334359>4.2 OOP(Object-Oriented programming，面向对象编程) vs. GP(Genic Programming，泛型编程)</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_4-3-技术基础-操作符重载和模板" class="sidebar-link reco-side-_4-3-技术基础-操作符重载和模板" data-v-70334359>4.3 技术基础（操作符重载和模板）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_4-3-1-操作符重载" class="sidebar-link reco-side-_4-3-1-操作符重载" data-v-70334359>4.3.1 操作符重载</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_4-3-2-模板" class="sidebar-link reco-side-_4-3-2-模板" data-v-70334359>4.3.2 模板</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-1-list" class="sidebar-link reco-side-_6-1-list" data-v-70334359>6.1 list</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-2-迭代器的设计规则和-iterator-traits-的作用与设计" class="sidebar-link reco-side-_6-2-迭代器的设计规则和-iterator-traits-的作用与设计" data-v-70334359>6.2 迭代器的设计规则和 Iterator Traits 的作用与设计</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-3-vector" class="sidebar-link reco-side-_6-3-vector" data-v-70334359>6.3 vector</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-4-array" class="sidebar-link reco-side-_6-4-array" data-v-70334359>6.4 array</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-5-deque" class="sidebar-link reco-side-_6-5-deque" data-v-70334359>6.5 deque</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-5-1-deque-如何模拟连续空间" class="sidebar-link reco-side-_6-5-1-deque-如何模拟连续空间" data-v-70334359>6.5.1 deque 如何模拟连续空间</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-5-2-queue-和-stack" class="sidebar-link reco-side-_6-5-2-queue-和-stack" data-v-70334359>6.5.2 queue 和 stack</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-6-rb-tree" class="sidebar-link reco-side-_6-6-rb-tree" data-v-70334359>6.6 rb_tree</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-6-1-rb-tree-深度探索" class="sidebar-link reco-side-_6-6-1-rb-tree-深度探索" data-v-70334359>6.6.1 RB-tree 深度探索</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-6-2-set-和-multiset" class="sidebar-link reco-side-_6-6-2-set-和-multiset" data-v-70334359>6.6.2 set 和 multiset</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-6-3-map-和-multimap" class="sidebar-link reco-side-_6-6-3-map-和-multimap" data-v-70334359>6.6.3 map 和 multimap</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-7-hashtable" class="sidebar-link reco-side-_6-7-hashtable" data-v-70334359>6.7 hashtable</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-7-1-hashtable-深度探索" class="sidebar-link reco-side-_6-7-1-hashtable-深度探索" data-v-70334359>6.7.1 hashtable 深度探索</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap" class="sidebar-link reco-side-_6-7-2-hash-set-hash-multiset-hash-map-hash-multimap" data-v-70334359>6.7.2 hash set, hash multiset, hash map, hash multimap</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_6-7-3-unordered-容器" class="sidebar-link reco-side-_6-7-3-unordered-容器" data-v-70334359>6.7.3 unordered 容器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_7-1-算法的形式" class="sidebar-link reco-side-_7-1-算法的形式" data-v-70334359>7.1 算法的形式</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_7-2-迭代器的分类-category" class="sidebar-link reco-side-_7-2-迭代器的分类-category" data-v-70334359>7.2 迭代器的分类（category）</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_7-3-迭代器的分类对算法的影响" class="sidebar-link reco-side-_7-3-迭代器的分类对算法的影响" data-v-70334359>7.3 迭代器的分类对算法的影响</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_7-4-算法源码分析" class="sidebar-link reco-side-_7-4-算法源码分析" data-v-70334359>7.4 算法源码分析</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_8-1-容器适配器" class="sidebar-link reco-side-_8-1-容器适配器" data-v-70334359>8.1 容器适配器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_8-2-仿函数适配器" class="sidebar-link reco-side-_8-2-仿函数适配器" data-v-70334359>8.2 仿函数适配器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_8-3-迭代器适配器" class="sidebar-link reco-side-_8-3-迭代器适配器" data-v-70334359>8.3 迭代器适配器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_8-4-未知适配器" class="sidebar-link reco-side-_8-4-未知适配器" data-v-70334359>8.4 未知适配器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-1-一个万用的哈希函数" class="sidebar-link reco-side-_9-1-一个万用的哈希函数" data-v-70334359>9.1 一个万用的哈希函数</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-2-tuple" class="sidebar-link reco-side-_9-2-tuple" data-v-70334359>9.2 tuple</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-3-type-traits" class="sidebar-link reco-side-_9-3-type-traits" data-v-70334359>9.3 type traits</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-3-1-type-traits-测试" class="sidebar-link reco-side-_9-3-1-type-traits-测试" data-v-70334359>9.3.1 type traits 测试</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-3-2-type-traits-实现" class="sidebar-link reco-side-_9-3-2-type-traits-实现" data-v-70334359>9.3.2 type traits 实现</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-4-cout" class="sidebar-link reco-side-_9-4-cout" data-v-70334359>9.4 cout</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020303.html#_9-5-move" class="sidebar-link reco-side-_9-5-move" data-v-70334359>9.5 move</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/assets/js/app.6240a449.js" defer></script><script src="/assets/js/8.9d998bdf.js" defer></script><script src="/assets/js/1.c70aaa24.js" defer></script><script src="/assets/js/3.73702826.js" defer></script><script src="/assets/js/18.7965e7af.js" defer></script>
  </body>
</html>
