<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>侯捷 C++ 11&amp;14 新特性 | 飞&#39;s Space</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="keep Advancing">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.de4ca4d0.css" as="style"><link rel="preload" href="/assets/js/app.6240a449.js" as="script"><link rel="preload" href="/assets/js/8.9d998bdf.js" as="script"><link rel="preload" href="/assets/js/1.c70aaa24.js" as="script"><link rel="preload" href="/assets/js/6.c78de8db.js" as="script"><link rel="preload" href="/assets/js/18.7965e7af.js" as="script"><link rel="prefetch" href="/assets/js/10.a746ca24.js"><link rel="prefetch" href="/assets/js/11.37b96bc6.js"><link rel="prefetch" href="/assets/js/12.0e620898.js"><link rel="prefetch" href="/assets/js/13.a1c573f5.js"><link rel="prefetch" href="/assets/js/14.6467db82.js"><link rel="prefetch" href="/assets/js/15.5fcfb8d3.js"><link rel="prefetch" href="/assets/js/16.06ad1c2e.js"><link rel="prefetch" href="/assets/js/17.ca9e6d13.js"><link rel="prefetch" href="/assets/js/19.8605ea14.js"><link rel="prefetch" href="/assets/js/20.88777038.js"><link rel="prefetch" href="/assets/js/21.142a739e.js"><link rel="prefetch" href="/assets/js/22.230bba9e.js"><link rel="prefetch" href="/assets/js/23.85d00b1e.js"><link rel="prefetch" href="/assets/js/24.2e093bb4.js"><link rel="prefetch" href="/assets/js/25.d93ef571.js"><link rel="prefetch" href="/assets/js/26.f48e6be4.js"><link rel="prefetch" href="/assets/js/27.b2000fa2.js"><link rel="prefetch" href="/assets/js/28.b033a1a5.js"><link rel="prefetch" href="/assets/js/29.9f4f42e0.js"><link rel="prefetch" href="/assets/js/3.73702826.js"><link rel="prefetch" href="/assets/js/30.a4cb1200.js"><link rel="prefetch" href="/assets/js/31.3b4dd163.js"><link rel="prefetch" href="/assets/js/32.a6617dc8.js"><link rel="prefetch" href="/assets/js/33.233d6c4e.js"><link rel="prefetch" href="/assets/js/34.9b6b8a8b.js"><link rel="prefetch" href="/assets/js/35.6af2c493.js"><link rel="prefetch" href="/assets/js/36.819b6ce9.js"><link rel="prefetch" href="/assets/js/37.ca2e1e69.js"><link rel="prefetch" href="/assets/js/38.8faca71a.js"><link rel="prefetch" href="/assets/js/39.65a0135e.js"><link rel="prefetch" href="/assets/js/4.8d3c60e4.js"><link rel="prefetch" href="/assets/js/40.487eb8c2.js"><link rel="prefetch" href="/assets/js/41.b86e9661.js"><link rel="prefetch" href="/assets/js/42.aeefaf21.js"><link rel="prefetch" href="/assets/js/43.8849cd8c.js"><link rel="prefetch" href="/assets/js/5.3406c297.js"><link rel="prefetch" href="/assets/js/7.4db18221.js"><link rel="prefetch" href="/assets/js/9.7a339055.js">
    <link rel="stylesheet" href="/assets/css/0.styles.de4ca4d0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><LoadingPage class="loading-wrapper" data-v-1156296a data-v-1156296a></LoadingPage> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>飞's Space</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>keep Advancing</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">飞's Space</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    duolanda
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>0</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>侯捷 C++ 11&amp;14 新特性</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">侯捷 C++ 11&amp;14 新特性</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>duolanda</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2023/2/2</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/blogs/xue-xi-bi-ji/2023/020305.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h1> <p>包括语言和标准库两个部分</p> <h2 id="_1-1-演化"><a href="#_1-1-演化" class="header-anchor">#</a> 1.1 演化</h2> <ul><li>C++ 98（1.0）</li> <li>C++ 03（TR1，Technical Report 1）</li> <li>C++ 11（2.0）</li> <li>C++ 14</li></ul> <h2 id="_1-2-header-files"><a href="#_1-2-header-files" class="header-anchor">#</a> 1.2 Header files</h2> <p>C++ 2.0新特性包括语言和标准库两个层面，后者以 header files 形式呈现</p> <ul><li>C++ 标准库的 header files 不带扩展名（.h），例如<code>#include &lt;vector&gt;</code></li> <li>新式 C header files 不带副名称 .h，例如<code>#include &lt;cstdio&gt;</code></li> <li>旧式 C header files（带有副名称.h）仍可用，例如<code>#include &lt;stdio.h&gt;</code></li></ul> <p>曾经在 std::tr1 命名空间下的东西现在也都放到 std 里了，所以直接<code>using namespace std;</code>即可</p> <h2 id="_1-3-重点"><a href="#_1-3-重点" class="header-anchor">#</a> 1.3 重点</h2> <p>语言：</p> <ul><li>Variadic Templates</li> <li><strong>move</strong> Semantics</li> <li><strong>auto</strong></li> <li>Range-base <strong>for</strong> loop</li> <li>Initializer list</li> <li>Lambdas</li> <li>……</li></ul> <p>标准库：</p> <ul><li><strong>type_traits</strong></li> <li>Unordered 容器</li> <li><strong>forward_list</strong></li> <li><strong>array</strong></li> <li><strong>tuple</strong></li> <li>Con-currency</li> <li>RegEx</li> <li>……</li></ul> <h1 id="_2-variadic-templates-可变参数模板"><a href="#_2-variadic-templates-可变参数模板" class="header-anchor">#</a> 2.Variadic Templates（可变参数模板）</h1> <p>模板的进化堪比原子弹</p> <h2 id="_2-1-概述"><a href="#_2-1-概述" class="header-anchor">#</a> 2.1 概述</h2> <p>模板 Templates：</p> <ul><li>函数模板</li> <li>类模板</li></ul> <p>变化的是模板参数：</p> <ul><li>参数个数：利用参数个数逐一递减的特性，实现递归函数的调用，使用<strong>函数模板</strong>完成</li> <li>参数类型：利用参数个数逐一递减以致参数类型也逐一递减的特性，实现递归继承或递归复合，以<strong>类模板</strong>完成</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Types<span class="token operator">&gt;</span>                <span class="token comment">//这里的...是关键字的一部分：模板参数包</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> firstArg<span class="token punctuation">,</span> <span class="token keyword">const</span> Types<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>     <span class="token comment">//这里的...要写在自定义类型Types后面：函数参数类型包</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> firstArg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">//这里的...要写在变量args后面：函数参数包</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>参数的个数任意，参数的类型也任意</li> <li>传进来的参数会被分成一个和一包，如<code>print(7.5, &quot;hello&quot;, bitset&lt;16&gt;(377), 42);</code>7.5 就是“一个”，后面的参数是“一包”，一个由 cout 输出，一包再递归处理。等一包里面内容为 0 时，就不能再调用这个函数了，所以上面又写了一个空参数的 print</li> <li>注意例子中<code>...</code>的位置，都是语法规则</li> <li>在可变模板参数内部可以使用<code>sizeof...(args)</code>得到实参的个数（即一包里面有多少个东西）</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Types<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> Types<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">/*......*/</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>如果还有这个，看起来会不能共存，因为有歧义，但其实可以</li> <li>后面会讲两个谁是泛化，谁是特化</li></ul> <p><img src="/assets/img/1675248393898-d3acc9f0-25bd-4321-aaf1-5d35c817bd3f.99fe3ccc.png" alt="image.png"></p> <ul><li>hash 函数递归调用的例子</li> <li><code>hash_val(c.fname, c.lname, c.no);</code>的第一个参数不是<code>size_t</code>类型，所以会调用到 ①。① 给参数加上一个 seed 参数后传给 ②。② 先对 seed 调用 ④，再继续调用 seed 和参数，每次 ② 都会把参数拆成 1 个和多个，如果参数依然还剩多个就递归调用自己，只剩一个参数的话就调用 ③。</li></ul> <p><img src="/assets/img/1675248631832-e59e6230-8c51-4462-8da9-c494e10a21e7.f3df37b4.png" alt="image.png"></p> <ul><li>tuple 递归继承的例子</li> <li>关键在于<code>private tuple&lt;Tail...&gt;</code>，继承了那一包，然后再不停往上继承，最后继承自<code>tuple&lt;&gt;</code></li></ul> <h2 id="_2-2-七大例子"><a href="#_2-2-七大例子" class="header-anchor">#</a> 2.2 七大例子</h2> <p>在课程顺序上，这部分在 18 之后</p> <p><img src="/assets/img/1675328031125-95ec9d17-d614-4dff-97fb-d743e4565425.bbdf6988.png" alt="image.png"></p> <ul><li>用一个模板函数接收各种各样的参数</li> <li>① 和 ③ 可以共存，因为 ① 更特化，但其实共存的时候 ③ 永远不会被调用。哪怕只剩 1 个了，也会调用 1+0 个，而不是 1 个。</li></ul> <p><img src="/assets/img/1675328416772-d5083031-a91b-4f7b-b253-4e8dc7407023.74067d28.png" alt="image.png"></p> <ul><li>使用 variadic templates 模拟 C 的 printf()</li> <li>其实输出时没用到 %d 这些符号，直接往 cout 里丢，这几个 % 符号的作用主要是检查是不是数量相等，不相等就抛出异常</li></ul> <p><img src="/assets/img/1675329044792-6ce19f24-ffcd-4f01-95c9-3ebd0b67fe3d.0358cabd.png" alt="image.png"></p> <ul><li>可以接收任意参数的 max 函数，并没有用 variadic templates  而是用 initializer lists，放在这里的意思是，如果参数数量不限，但类型不一样，完全可以用 initializer lists</li> <li>从右上角开始看</li> <li>左侧箭头画错了，起点应该是下面的<code>__max_element</code></li> <li>_Iter_less_iter 是仿函数，用<code>&lt;</code>比大小</li> <li>左侧 while 一个个比大小</li></ul> <p><img src="/assets/img/1675329563714-daaa0cb3-1d4e-4498-96c1-f40dd1e02502.f9e41e43.png" alt="image.png"></p> <ul><li>例 3 的改版，不再需要大括号</li> <li>上面的蓝色箭头画错了，应该指向下面的<code>maximum()</code></li> <li>不断调用<code>std::max()</code>获取最大值</li> <li>当然，就像例 3 展示的，<code>std::max()</code>本来就可以接收任意数量的参数，只不过要加大括号</li></ul> <p><img src="/assets/img/1675329958614-05ec3946-6037-4eeb-80ca-6b918b6a7ca8.45e4641e.png" alt="image.png"></p> <ul><li>用类模板把模板参数一个个分解</li> <li>我希望输出时对头尾元素做特殊操作，输出之后，前后会有中括号，中间用逗号间隔开。所以必须要知道当前处理的元素总共有几个（<code>sizeof...()</code>），以及现在处理的是第几个（通过 IDX 记录）</li> <li>通过  IDX+1 与 MAX 比较判断是不是最后一个，如果是就不额外打印东西了，如果不是就额外打印逗号。最后一个处理完了会进入到最下面的偏特化版本，什么都不做</li></ul> <p><img src="/assets/img/1675331017912-a8997d57-8947-47bc-9dd5-e4b88e3c1d89.e447e719.png" alt="image.png"></p> <ul><li>tuple。前面都是递归调用、递归创建，而这个是递归继承</li> <li>递归继承，处理的是类型，要用类模板</li> <li>“一个”拿来声明变量，“一包”再做成 tuple 被继承，非常巧妙</li> <li>tail() 返回的是指针</li> <li><code>tuple(Head v, Tail... vtail):m_head(v), inherited(vtail...){}</code>的<code>inherited(vtail...)</code>其实是调用父类构造函数完成初值设定</li> <li>但是<code>typename Head::type head() {return m_head;}</code>这行会报错，因为 int 和 float 都回答不了 type</li></ul> <p><img src="/assets/img/1675331046310-1ef102ff-723e-4cfe-a0ab-45cf92b78d2d.0f4a93d6.png" alt="image.png"></p> <ul><li>为了编译通过，想到可以用<code>decltype</code>得到 m_head 的 type</li> <li>又遇到了一个问题，此时 m_head 还没有出现，编译依然不通过，于是把 protect 挪上来</li></ul> <p><img src="/assets/img/1675331086624-0ca566a2-e58f-4a00-ad3e-9eb2776ab42b.524901d1.png" alt="image.png"></p> <ul><li>后来发现其实是多此一举，刚才想的太复杂了</li> <li>其实根本不用问类型，就是 Head</li></ul> <p><img src="/assets/img/1675335555538-c958e4f3-cf3f-4a0a-a8ae-f375d187216c.a981ffb9.png" alt="image.png"></p> <ul><li>既然可以递归继承，那么也可以递归复合，模仿例 6 用复合实现 tuple</li></ul> <h1 id="_3-模板表达式中的空格"><a href="#_3-模板表达式中的空格" class="header-anchor">#</a> 3.模板表达式中的空格</h1> <p>如果模板参数本身也是模板，尖括号之间必须要有空格：<code>vector&lt;list&lt;int&gt; &gt;;</code>
自 C++11 之后开始就可以去掉空格了：<code>vector&lt;list&lt;int&gt;&gt;;</code></p> <h1 id="_4-nullptr"><a href="#_4-nullptr" class="header-anchor">#</a> 4.nullptr</h1> <p>标准库允许使用 nullptr 取代 0 或者 NULL 来对指针赋值（其实 NULL 就是 0）</p> <ul><li>nullptr 是个新关键字</li> <li>nullptr 可以被自动转换为各种 pointer 类型，但不会被转换为任何整数类型</li> <li>nullptr 的类型为 std::nullptr_t，定义于头文件中</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用 f(int).</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 因为定义 NULL 为 0，所以调用 f(int)，如果没有定义为 0，会产生二义性</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用 f(void*).</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="_5-auto"><a href="#_5-auto" class="header-anchor">#</a> 5.auto</h1> <p>auto 可以进行自动类型推导
注意，在 C 的语境下，auto 意味着局部变量，也叫 local 变量（因为函数结束后局部变量会自动消失）
使用 auto 的场景：类型太长（迭代器）或者类型太复杂（lambda）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
<span class="token keyword">auto</span> pos <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 代替 vector&lt;string&gt;::iterator</span>

<span class="token keyword">auto</span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">bool</span><span class="token punctuation">{</span> <span class="token comment">// l 代表了 lambda</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>一种写法简化</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token number">1</span>ist<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator ite<span class="token punctuation">;</span>
ite <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>；

<span class="token comment">//现在可写为</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token keyword">auto</span> ite <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h1 id="_6-uniform-initialization-一致性初始化"><a href="#_6-uniform-initialization-一致性初始化" class="header-anchor">#</a> 6.uniform initialization（一致性初始化）</h1> <p>C++11 之前初始化时存在多个版本<code>{}``()``=</code>。让使用者使用时比较混乱</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Rect r1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>area<span class="token punctuation">,</span> <span class="token operator">&amp;</span>print<span class="token punctuation">}</span><span class="token punctuation">;</span>
Rect <span class="token function">r1</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">210</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>C++11 提供一种万用的初始化方法，任何初始化都可以使用大括号<code>{}</code></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> values<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> cities <span class="token punctuation">{</span>
<span class="token string">&quot;Berlin&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;New York&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;London&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Braunschweig&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Cairo”,&quot;</span>Cologne&quot;
<span class="token punctuation">}</span><span class="token punctuation">;</span>
complex<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> c<span class="token punctuation">{</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//相当于 c(4.0,3.0) </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>只要变量名后接大括号就是初始化</p> <p>原理解析：当编译器看到大括号包起来的东西<code>{t1,t2...tn}</code>时，会生成一个<code>initializer_list&lt;T&gt;</code>，<code>initializer_list</code>关联至一个<code>array&lt;T,n&gt;</code>。调用函数（例如构造函数 ctor）时该 array 内的元素可被编译器分解逐一传给函数。
如<code>vector&lt;string&gt; cities {&quot;Berlin&quot;,&quot;New York&quot;,&quot;London&quot;,&quot;Braunschweig&quot;,&quot;Cairo”,&quot;Cologne&quot;};</code>形成一个<code>initializer_list&lt;string&gt;</code>，背后有<code>array&lt;string,6&gt;</code>。调用<code>vector&lt;string&gt;</code>ctors 时编译器找到了一个<code>vector&lt;string&gt;</code> ctor 接受 <code>initializer_list&lt;string&gt;</code>。
<code>complex&lt;double&gt; c{4.0, 3.0};</code>形成一个<code>initializer_list&lt;double&gt;</code>，背后有<code>array&lt;double,2&gt;</code>。因为<code>complex&lt;double&gt;</code>并无任何 ctor 接受<code>initializer_list&lt;double&gt;</code>，所以调用<code>complex&lt;double&gt;</code> ctor 时该 array 内的 2 个元素被分解后传给 ctor。
但是如果调用函数自身提供了<code>initializer_list&lt;T&gt;</code>参数类型的构造函数，则不会分解而是直接传过去。直接整包传入进行初始化。所有的容器都可以接受这样的参数。</p> <h1 id="_7-initializer-lists"><a href="#_7-initializer-lists" class="header-anchor">#</a> 7.Initializer Lists</h1> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token punctuation">;</span>      <span class="token comment">// 未初始化</span>
<span class="token keyword">int</span> j<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">// j 初始化为 0</span>
<span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>     <span class="token comment">// 未初始化</span>
<span class="token keyword">int</span><span class="token operator">*</span> q<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// q 初始化为 nullptr</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>大括号里面的内容不能窄化转换（narrowing conversion）</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">x1</span><span class="token punctuation">(</span><span class="token number">5.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x2 <span class="token operator">=</span> <span class="token number">5.3</span><span class="token punctuation">;</span> <span class="token comment">//这俩可以，但会转换为 5</span>
<span class="token keyword">int</span> x3<span class="token punctuation">{</span><span class="token number">5.3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5.3</span><span class="token punctuation">}</span> <span class="token comment">//这俩会报错，因为大括号不能窄化转换</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>虽然文档上如此描述，但在实际测试当中，只会警告，不会报错</p> <p>initializer_list 用来接收任意数量的东西<code>{12,3,5,7,11,13,17}</code>会自动被编译器当做<code>std::initializer_list&lt;int&gt;</code>。initializer_list<T>是一个class（类模板），虽然数量任意，但类型要一致。</T></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vals<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p<span class="token operator">=</span>vals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">!=</span>vals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span><span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="/assets/img/1675252082740-2d42c473-7ee0-4149-9707-37632b562fa1.240ecb75.png" alt="image.png"></p> <ul><li>p 是小括号，调用版本1；q 是大括号，调用版本 2（不要被箭头误导了，箭头指的是 complex 的情况）；r 和 s 也都是一包，调用版本 2。</li> <li>如果没有 2，只有 1，p、q 和 s 会调用版本 1，但是 r 不行，因为 r 有三个参数，</li> <li>联系前面的例子，complex<double> 就相当于没有版本 2，于是会调用到 1</double></li> <li>图右为 initializer_list 源码
<ul><li>initializer_list<T> 背后有 array 数组支撑，initializer_list 关联一个 array&lt;T,n&gt;</T></li> <li>initializer_list<T> 只包含一个指向 array 的指针，而不是内含整个 array，它的拷贝只是一个浅拷贝，比较危险，两个指针指向同一个内存</T></li></ul></li></ul> <p>根据源码检索，STL 的许多地方都用到了 initializer_list</p> <ul><li>所有容器都接受指定任意数量的值用于构造或赋值或者 insert() 或 assign()</li> <li>算法 max() 和 min() 也接受任意参数</li></ul> <h1 id="_8-explict"><a href="#_8-explict" class="header-anchor">#</a> 8.explict</h1> <p><img src="/assets/img/1675253507079-4ffc7071-724a-4a32-898c-ce30f6630d44.1ee491da.png" alt="image.png"></p> <ul><li>C++11 之前的 explicit</li> <li>左侧成立，相加时编译器发现 5 可以完成转换，变成 5+0i</li> <li>如果你不想编译器完成这样的隐式转换，就加上 explicit，右侧会报错<code>[Error] no match for 'operator+'(operand types are 'Complex' and 'int'</code></li> <li>但是 C++11 之前，只有非 explicit 的一个实参（one argument）的构造函数才会做隐式转换，而 C++11 开始多个实参也可以隐式转换了，所以 explicit 也支持多个参数的构造函数了</li></ul> <p>示例：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">P</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;P(int a, int b) \n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">P</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;P(initializer_list&lt;int&gt;) \n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">explicit</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;explicit P(int a, int b, int c) \n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fp</span><span class="token punctuation">(</span><span class="token keyword">const</span> P<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>P <span class="token function">p1</span> <span class="token punctuation">(</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//P(int a, int b)</span>
P p2 <span class="token punctuation">{</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">//P(initializer_list&lt;int&gt;)</span>
P p3 <span class="token punctuation">{</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>	<span class="token comment">//P(initializer_list&lt;int&gt;)</span>
P p4 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>		<span class="token comment">//P(initializer_list&lt;int&gt;)</span>
P p5 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//[Error] converting to 'P' from initializer list would use explicit constructor</span>
p <span class="token function">p6</span> <span class="token punctuation">(</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//explict P(int a, int b, int c)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="_9-range-based-for-statement-基于范围的-for-循环"><a href="#_9-range-based-for-statement-基于范围的-for-循环" class="header-anchor">#</a> 9.range-based for statement（基于范围的 for 循环）</h1> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">// 例子</span>
vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> elem<span class="token operator">:</span>vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	cout<span class="token operator">&lt;&lt;</span>elem<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> elem<span class="token operator">:</span>  vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elem <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>    
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>其实就是利用迭代器遍历了一遍</li></ul> <p>基于范围的 for 循环遇到类型不同时会做转换，如果之前用 explicit 禁止了转换，那么将会报错。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">C</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">explicit</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> vs<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> elem <span class="token operator">:</span> vs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ERROR, no conversion from string to C defined</span>
cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;</span> endl；
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h1 id="_10-default-delete"><a href="#_10-default-delete" class="header-anchor">#</a> 10.= default, = delete</h1> <p>哪怕一个类是空的，C++ 也会给它默认的构造函数、拷贝构造、拷贝赋值、移动构造、移动赋值、析构函数
如果已经自行定义了构造函数，那么编译器不会再给你默认的构造函数，可是如果加上<code>=default</code>，就可以重新获得并使用默认构造函数。<code>=delete</code>则相反，意味着这个函数已经删除，不能再被使用。引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Zoo</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Zoo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i1<span class="token punctuation">,</span> <span class="token keyword">int</span> i2<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">d1</span><span class="token punctuation">(</span>i1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d2</span><span class="token punctuation">(</span>i2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//构造函数</span>
    <span class="token function">Zoo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Zoo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">//拷贝构造 copy constructor</span>
    <span class="token function">Zoo</span><span class="token punctuation">(</span>Zoo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//移动构造 move constructor</span>
    Zoo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Zoo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//拷贝赋值 copy assignment</span>
    Zoo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Zoo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">//移动赋值 move assignment</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Zoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> d1<span class="token punctuation">,</span> d2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>构造函数、拷贝构造、拷贝赋值称为 big three，再加上移动构造和移动赋值是 big five</li></ul> <p><img src="/assets/img/1675256093243-bf9d3c31-86e6-49a5-bcc5-7ceb03f92d0b.bc53698f.png" alt="image.png"></p> <ul><li>我已经有一个构造函数了，默认的我也要，没问题，多个构造函数可以共存</li> <li>我已经写了拷贝构造，不能再<code>=default</code>了，因为拷贝构造只能有一个。<code>=delete</code>也不可以，既然已经写出来了又要 delete，那么编译器要何去何从呢？所以不行</li> <li>拷贝赋值同理，也只能有一个</li> <li><code>func1()</code>和<code>func2()</code>是两个一般的函数。一般函数并没有<code>=default</code>版本，所以编译会报错，但是<code>=delete</code>没问题。不过这种用法其实挺少的，因为一般不想要哪个函数一开始就不写就好了</li> <li>析构函数先<code>=delete</code>再<code>=default</code>也会报错，编译器搞不清你的意图</li> <li>补充：如果不想在某个类定义虚函数，可以加<code>=0</code>，代表纯虚函数。但<code>=0</code>只能用在虚函数上</li></ul> <p>什么样的类需要自己定义这些函数，而什么样的类用默认的就可以了呢？</p> <ul><li>如果类中带有 pointer member（指针成员），那我们就可以断定必须要自己写出 big five；
如果不带，绝大多数情况下就不必给出 big five。</li> <li>复数类中没有指针，拷贝就是把实部、虚部都拷贝过去即可，编译器默认给的也是这么做的</li> <li>字符串中有指针，涉及到浅拷贝和深拷贝的问题，所以必须要自己写出 big five</li></ul> <p><img src="/assets/img/1675257159948-3947fd22-b254-4f24-a21b-5a508a6092fb.969271cf.png" alt="image.png"></p> <ul><li>根据<code>=default</code>和<code>=delete</code>写出这三个特别的类</li> <li>NoCopy 不允许拷贝，所以把拷贝构造和拷贝赋值都<code>=delete</code>了</li> <li>NoDtor 删除了析构函数，这么做一定要考虑后果，对象离开作用域或消除时都会报错</li> <li>PrivateCopy 不允许一般的代码拷贝，但是可以被友元或成员拷贝</li></ul> <p><img src="/assets/img/1675257490982-02bcee2e-3b30-463d-ade5-b800d156c86f.caac5f3a.png" alt="image.png"></p> <ul><li>boost 就使用了类似的手法</li> <li>它也把拷贝构造和拷贝赋值都放到 private 里了，如此设计是为了让其他的类来继承，继承之后也会具有这样的性质</li></ul> <h1 id="_11-alias-template-模板别名"><a href="#_11-alias-template-模板别名" class="header-anchor">#</a> 11.Alias Template（模板别名）</h1> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> Vec <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

<span class="token comment">//使用</span>
Vec<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> coll<span class="token punctuation">;</span> <span class="token comment">//相当于 std::vector&lt;int, MyAlloc&lt;int&gt;&gt; coll;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用宏无法达到相同的效果</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Vec</span><span class="token expression"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span></span></span>

Vec<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> coll<span class="token punctuation">;</span>
<span class="token comment">//相当于</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> MyAlloc<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> coll<span class="token punctuation">;</span> <span class="token comment">//牛头不对马嘴</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>typedef 同样也不行，因为 typedef 无法制定参数</p> <p>Alias Template 无法特化（偏特化和全特化都不行）。</p> <p><img src="/assets/img/1675316919444-c58c5a45-77fb-4dbf-b36a-a798e0f01e79.987b7c23.png" alt="image.png"></p> <ul><li>我希望写一个测试函数，可以传入任意的容器和类型</li> <li>左侧就是天方夜谭，因为函数传入的参数都是对象，这里却想拿 cntr 的参数类型做构造</li> <li>右侧就是传东西了（list()是个临时对象），然后用函数模板取出类型，但依然是天方夜谭，因为 Container 不是模板</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">test_moveable</span><span class="token punctuation">(</span>Container c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> <span class="token class-name">iterator_traits</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Container</span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_type Valtype<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Valtype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">output_static_data</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">c1</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">c2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">list</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyString<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">list</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyStrNoMov<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyString<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyStrNoMow<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">deque</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyString<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test <span class="token function">moveable</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">deque</span><span class="token generic class-name"><span class="token operator">&lt;</span>MyStrNoMove<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>只好牺牲调用端的弹性，在调用端就把容器和类型结合起来</li> <li>因为传入的是结合后的，代码里必须要把元素类型取出来，通过把容器的迭代器丢到萃取机里得到元素类型，并重命名为 Valtype</li> <li>这样的写法并不差，但没有达到最初想要的效果。而且，如果容器没有迭代器或 traits 呢（当然标准库里的容器肯定都有）。该如何做到能接受一个模板参数 Container，而 Container 本身又是个模板，并从中取出 Container 的模板参数？如收到 vector<string>，如何取出元素类型 string？</string></li></ul> <p>下面用 template template parameter（模板模板参数）解决这个问题</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
          <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  <span class="token comment">//T 可写可不写，默认是前面的 T</span>
              <span class="token keyword">class</span> <span class="token class-name">Container</span>
         <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">XCls</span>
<span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">XCls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//构造函数</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>SIZE<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            c<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token function">output_static_data</span><span class="token punctuation">(</span><span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">c1</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Container<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">c2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        c1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用时会报错</span>
XCls<span class="token operator">&lt;</span>MyString<span class="token punctuation">,</span> vector<span class="token operator">&gt;</span> c1<span class="token punctuation">;</span>        <span class="token comment">//[Error] vector的实际类型和模板中的Container&lt;T&gt;类型不匹配</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><ul><li><code>template &lt;class&gt; class Container</code>是外面模板的模板参数，而它自己本身也是一个模板</li> <li>XCls 这个名字是随便取的，意思是 X Class</li> <li>代码本身编译通过了，但加上使用的代码后报错了，因为 vector 是有两个参数的（元素类型和分配器），但代码里<code>Container&lt;T&gt; c;</code>只写了一个。平时写的时候因为分配器这个参数有默认值所以只需要写一个，但现在作为模板模板参数，编译器无法推导</li> <li>这时就引入我们的主题了：Alias Template</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> Vec <span class="token operator">=</span> vector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
 
XCls<span class="token operator">&lt;</span>MyString<span class="token punctuation">,</span> Vec<span class="token operator">&gt;</span> c1<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>上面的代码都不变，在外部加上这三行，Vec 只需要一个参数就够了，与<code>Container&lt;T&gt; c;</code>相匹配，达到我们的目标
可见 Alias Template 并非只是让我们少写几行代码，而是有更丰富的作用</p> <h1 id="_12-type-alias"><a href="#_12-type-alias" class="header-anchor">#</a> 12.Type Alias</h1> <p>类似 typedef，同样借助 using 关键字来使用</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">using</span> func <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//相当于</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
func fn <span class="token operator">=</span> example<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>func 是一个类型，typedef 的语法并不能很好的表达这一点，Type Alias 就清晰多了
Type Alias 和 typedef 完全等价</p> <h1 id="_13-using-用法总结"><a href="#_13-using-用法总结" class="header-anchor">#</a> 13.using 用法总结</h1> <ol><li>打开命名空间（<code>using namespace std</code>）或者命名空间（<code>using std::cout</code>）的成员</li> <li>打开类的成员（<code>using _Base::_M_allocate;</code>，这样以后只需写 _M_allocate，编译器便会到 _Base 类里去找）</li> <li>类型别名和模板别名（C++ 11开始支持）</li></ol> <h1 id="_14-noexcept"><a href="#_14-noexcept" class="header-anchor">#</a> 14.noexcept</h1> <p><img src="/assets/img/1675321059407-4dccde7b-86d3-41ba-9c58-5fa44f6bb09d.0406eb8f.png" alt="image.png"></p> <ul><li>在函数后面加上<code>noexpect</code>关键字，保证这个函数不会丢出异常，后面可以在小括号里面写上不会丢出异常的限定条件，<code>noexpect</code>就相当于<code>noexpect(true)</code></li> <li><strong>一般异常处理流程</strong>：当程序发生异常时会将异常信息上报返回给调用者，如果有异常处理则处理，如果该调用者没有处理异常则会接着上报上一层，若到了最上层都没有处理，就会调用<code>std::terminate()</code>调用<code>std::abort()</code>，然后终止程序</li></ul> <p><img src="/assets/img/1675321467031-ee892b92-0e9b-434e-946d-e9fcdb75f820.2befafdc.png" alt="image.png"></p> <ul><li>一定要给移动构造和移动赋值加上<code>noexpect</code>，vector 才会用它</li> <li>但实际写的时候不知道其他人会用什么，所以最好有移动构造和移动赋值就写上<code>noexpect</code></li></ul> <h1 id="_15-override"><a href="#_15-override" class="header-anchor">#</a> 15.override</h1> <p><img src="/assets/img/1675321992225-cc667834-4c22-4930-a421-4bc5938efdd7.37083193.png" alt="image.png"></p> <ul><li><code>override</code>应用在虚函数上，告诉编译器这个函数就是要重写父类虚函数，让编译器帮忙检查</li> <li>上面框中，子类本来想重写父类的函数，结果写错了，编译器会认为这是子类的新函数</li> <li>下面框中，在子类后面加上<code>override</code>，编译器会报错，告诉你写错了</li></ul> <h1 id="_16-final"><a href="#_16-final" class="header-anchor">#</a> 16.final</h1> <p><img src="/assets/img/1675322246583-0de700ae-438d-424d-85c4-5b947cfa5973.9232e4d8.png" alt="image.png"></p> <ul><li>有两个作用
<ul><li>父类禁止自己被继承</li> <li>虚函数禁止自己被重写</li></ul></li></ul> <h1 id="_17-decltype"><a href="#_17-decltype" class="header-anchor">#</a> 17.decltype</h1> <p><code>decltype</code>可以让编译器找出表达式的类型，虽然之前已经有了<code>typeof</code>，但它并非标准库的一部分，所以 C++ 11 加入了 decltype</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span> coll<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>coll<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span>value_type elem<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>实际当中这两行可能隔得很远。我们知道这个是容器，所以用 value_type 拿到类型，然后用它的 type 声明变量 elem</li> <li>C++ 11 之前无法通过对象取得 type，你必须知道那个对象是什么类型，要写成<code>map&lt;string, float&gt;::value_type elem;</code></li></ul> <p>三种应用：声明返回类型、模板之间应用（元编程）、求 lambda 表达式类型
<img src="/assets/img/1675323020354-38f7e79e-c71d-4d11-a969-4a8b678d867c.1f87074c.png" alt="image.png"></p> <ul><li>声明一种返回类型</li> <li>一般<code>+</code>都是作用在两个相同类型之间的，但这里 x 和 y 是两个类型。<code>decltype</code>的作用就体现出来了，它允许我们的返回类型是 x+y 之后的类型。但是这样编译不通过，因为 x 和 y 在后面才出现</li> <li>于是写成<code>autoAdd(T1 x, T2 y) -&gt; decltype(x + y);</code>，意思一样，但可以通过编译。当然，即使编译通过了，如果用的时候 x 和 y 无法相加，还是会报错</li> <li>这种指定方式和 lambdas 很像</li></ul> <p><img src="/assets/img/1675323483162-d4d1b9ee-6576-44e9-b753-134b734cdc79.fa0c9d59.png" alt="image.png"></p> <ul><li>模板之间的应用</li> <li>模板之间调来调去之后，如果我想知道 obj 的类型，就可以用<code>decltype</code></li> <li>同理，虽然编译可以通过，如果使用者传进来一个没有迭代器的 obj，就会报错</li></ul> <p><img src="/assets/img/1675323860876-ff13f6f4-be85-48b5-a889-5a9f574ac453.9dfb3f9f.png" alt="image.png"></p> <ul><li>求 lambda 表达式类型</li> <li>lambda 是一个函数，这个函数用 cmp 表示，如果只是用这个对象很好办，但有时候我们会需要它的类型，我们又不知道，就可以用<code>decltype</code></li></ul> <h1 id="_18-lambdas"><a href="#_18-lambdas" class="header-anchor">#</a> 18.Lambdas</h1> <p><img src="/assets/img/1675324960240-7f16828e-f695-4664-b025-e121204533a7.33f9adfa.png" alt="image.png"></p> <ul><li>lambda 是函数的定义，lambda 可以用作内联函数，可以被当做一个参数或者一个对象，类似于仿函数。</li> <li>中括号开头的就是 lambda，大括号内是函数本体，调用的时候直接在后面加小括号即可（注意，这里和前面的概念不同，小括号不是生成临时对象，而是直接调用）</li></ul> <p><img src="/assets/img/1675325585255-54d462f9-23ba-4a06-9d6b-04b02d4ea8a8.a059cea1.png" alt="image.png"></p> <ul><li>完整形式
<ul><li>[]：lambda 导入器（introducer），看到它就知道是 lambda，取用外部变量</li> <li>()：参数</li> <li>mutable：[] 中的导入数据是否可变</li> <li>throwSpec：抛出异常</li> <li>retType：返回类型</li> <li>{}：函数体</li></ul></li> <li>因为 lambda 的写法是 [] 开始的，所以返回类型写到了后面</li> <li>mutable、throwSpec、retType 都是可写可不写的，但只要写了三个里的其中一个，就必须也要写上小括号</li> <li><code>[=, &amp;y]</code>中<code>=</code>的意思是接收任意外界对象 by value。不是很推荐这种写法，可读性比较差</li></ul> <p><img src="/assets/img/1675326010577-b6bda992-ebf9-473e-b452-bae11cc40c52.3d447075.png" alt="image.png"></p> <ul><li>左边 lambda 和右边是近乎等价的</li> <li>所以会有如此的输出结果，它变的不是外面的 id，而是传入后的自己的 id。这里是 pass by value</li> <li>但如果不写 mutable，确实不能<code>++id</code>，可见左右不完全相同</li></ul> <p><img src="/assets/img/1675326382992-c32f941f-18e6-4232-be3c-82e514856102.bdf2c1ca.png" alt="image.png"></p> <ul><li>左右都是 pass by value，中间是 pass by reference</li> <li>中间的变化会影响外界</li> <li>右框因为没写 mutable，所以不能<code>++id</code></li> <li>左下框是可以编译通过的，lambda 可以有静态、非静态数据，也可以 return</li></ul> <p><img src="/assets/img/1675326706849-6d1716cb-750c-456a-9d48-f2eb4de36178.b0745c20.png" alt="image.png"></p> <ul><li>① 相当于 ②</li></ul> <p><img src="/assets/img/1675326854475-162d9ea2-ee33-4ec7-8111-4de32634927b.1222021d.png" alt="image.png"></p> <ul><li>如果你需要 lambda 当做排序准则交给 set，就需要用<code>decltype()</code>获取它的类型。你也必须把 cmp（lambda obj）传给<code>coll()</code>的构造函数，否则<code>coll()</code>会调用默认构造函数，不幸的是，lambda 并没有默认构造函数，也没有赋值操作，所以会报错。因此，如果要写排序准则，最好写成仿函数，会更直观。</li></ul> <p><img src="/assets/img/1675327503341-5dc79dfd-432b-49a2-bde1-0154b64f9307.4c3de514.png" alt="image.png"></p> <ul><li>n 是元素，x y 是范围，我希望所有的元素都在 x&lt;n&lt;y 的范围里，把不符合范围的删掉。写成左侧的 lambda 要比右侧的仿函数简洁很多，而且因为 lambda 是 inline，效率也会略高</li></ul> <h1 id="_19-rvalue-references-右值引用"><a href="#_19-rvalue-references-右值引用" class="header-anchor">#</a> 19.Rvalue references（右值引用）</h1> <p>上面都是语言，从这开始进入第二个部分：标准库
右值引用严格来说算是语言，但它和标准库有关
<img src="/assets/img/1675336508778-f78fb569-ae7f-4ef9-8326-c77ab2949f78.025f35d3.png" alt="image.png"></p> <ul><li>帮助解决非必要的拷贝。如果赋值的右侧是个右值，那么左值就可以直接把右值移动（move）过来，而不用重新分配</li> <li>变量就是左值，不能放在左边的就是右值</li> <li>例子中<code>a</code>、<code>b</code>都是左值，<code>a+b</code>就是右值，临时对象也是右值（可以理解成临时对象没有名字，没法赋值）</li> <li>string 和 complex 比较特别，没有遵循定义，不用管它们</li></ul> <p><img src="/assets/img/1675336521714-905d0397-222a-4088-b7ba-92cd27816228.ad7b185b.png" alt="image.png"></p> <ul><li><code>&amp;foo</code>可以，对函数取地址。<code>&amp;foo()</code>不行，因为函数返回的东西是右值，不能对右值取地址。C++ 11 之后就不一样了</li></ul> <p><img src="/assets/img/1675336531671-ea610838-31b0-41d4-84b2-24436db0bffe.0ef9e383.png" alt="image.png"></p> <ul><li><code>Vtype(buf)</code>是临时对象，自然而然是右值</li> <li>过去<code>insert()</code>为了 copy 会调用这个元素的拷贝构造，现在已经明确自己是可以 move 的了，于是会调用移动构造。前者是深拷贝，后者是浅拷贝。所以右值在 move 之后就不能再用了，不然会有危险</li> <li>如果我是左值，但我明确我以后不会再用了，也想 move，只要把左值放到<code>std::move()</code>里即可，就能得到左值的右值版本</li></ul> <p><img src="/assets/img/1675338005401-ca8e84c7-2dd8-4acb-a675-ed0fac5050b1.c12a1c3b.png" alt="image.png"></p> <ul><li>G2.9 （代表 C++ 11 之前）中 vector 的 insert 只有一个版本，G4.9（代表 C++ 11 之后）则有两个版本</li></ul> <p><img src="/assets/img/1675338640818-9070a896-1f26-4445-ad28-c495a94ecf48.67640df8.png" alt="image.png"></p> <ul><li>不但有移动构造，也有移动赋值</li></ul> <h1 id="_20-perfect-forwarding"><a href="#_20-perfect-forwarding" class="header-anchor">#</a> 20.Perfect Forwarding</h1> <p><img src="/assets/img/1675338717754-6e55e3ed-b336-4a37-8285-d6b10ca6de37.eb424d44.png" alt="image.png"></p> <ul><li>先看看什么是不完美的传递</li> <li>两个<code>process()</code>，分别是左值版本和右值版本，通过输出可以知道调用了哪个版本</li> <li>中介函数<code>forward()</code>，<code>forward()</code>再调用<code>process()</code>。这时候出现了问题，右值经过转交后被当成了左值处理</li> <li>左值更不用说了，完全不能调用<code>forward()</code></li></ul> <p><img src="/assets/img/1675338691621-924b66f2-8c49-445d-9390-0ab91d1c23cb.d9b26eb2.png" alt="image.png"> <img src="/assets/img/1675339068008-3c27e601-d02f-4ae7-ad46-1956d886bd48.42163a64.png" alt="image.png"></p> <ul><li>标准库中的<code>forward()</code>可以做到完美传递，我们不深究实现细节</li></ul> <h1 id="_21-move-aware-class"><a href="#_21-move-aware-class" class="header-anchor">#</a> 21.move aware class</h1> <p><img src="/assets/img/1675339599857-f6dc8fea-c93d-4ebc-9828-60678b152dc9.10da3bfb.png" alt="image.png"></p> <ul><li>写一个可以被 move 的 class，作为元素的类型。未来容器需要的时候就可以 move 它而不是拷贝</li> <li>重点是 move constructor。首先参数是右值引用，然后把指针和长度设过来，注意，清除动作（delete）不应该写在这，而是应该交给析构函数来做。一定要把指针设为 NULL，即把指针打断，析构函数也要检查是不是 NULL，不然会把数据本身杀掉</li></ul> <p><img src="/assets/img/1675340094588-15343059-6078-453e-973e-a72c02e6c114.e911eeb0.png" alt="image.png"></p> <ul><li>接上页</li> <li>移动赋值其他和拷贝赋值都一样，只不过是浅拷贝而不是深拷贝</li> <li>测试时要把它放到各种容器里，而关联式容器如 set、map 需要检测元素大小，所以也要重载<code>&lt;</code>和<code>==</code>，因为 MyString 是 C 风格字符串，为了方便，借用 C++ 的 String 比大小。不过这部分和 move 无关，只是为了测试。同理，hash table 需要 hash function，所以写了蓝色的部分</li></ul> <p><img src="/assets/img/1675340934649-73f1aec1-e351-4d32-876f-a8c5aca8a35f.21b682af.png" alt="image.png"> <img src="/assets/img/1675341165919-c0dedabd-140c-4c77-9b3c-c80ec1dd61ed.b247ae7c.png" alt="image.png"> <img src="/assets/img/1672314355323-9fa36a58-cd57-42f9-9342-3e8f14d3d4f9.f9a61345.png" alt="image.png"> <img src="/assets/img/1672314505115-ef1c3323-52fd-4a14-8c32-24d7a6e20cb7.c030d684.png" alt="image.png"> <img src="/assets/img/1672314519805-5a23b668-55de-4fd5-9e2d-19be5566ed58.95db14c0.png" alt="image.png"> <img src="/assets/img/1672314532277-48a57200-1eda-42bb-9044-12885cb2e563.78c68ce5.png" alt="image.png"></p> <ul><li>与《STL 标准库与泛型编程》中的 9.5 部分相同</li></ul> <p><img src="/assets/img/1672316873506-cb634a22-2c4d-4b2d-92ef-dbcb73c1410f.ccc3a34b.png" alt="image.png"></p> <ul><li>为什么 copy 和 move 速度差这么多？</li> <li>vector 的拷贝构造是真的一个个的把来源端拷贝到目的端。copy 最终的确完成了 memory allocation 及 copy ctor 的调用</li> <li>顺着箭头走，它最后所做的事只是 swap 来源端和目的端的三根指针。move-copy 最终是三根指针进行 swap()，交换后 c 变成了 c2，而 c2 变成了 c，但 c2 原本无意义，所以现在 c 变得无意义，因此 move-copy 之后的来源端（本例的 c）不能再被使用，否则后果自负</li></ul> <h1 id="_22-容器"><a href="#_22-容器" class="header-anchor">#</a> 22.容器</h1> <h2 id="_22-1-array"><a href="#_22-1-array" class="header-anchor">#</a> 22.1 array</h2> <p>与《STL 标准库与泛型编程》中的 6.4 部分相同。本质是数组，给数组容器该有的接口。</p> <h2 id="_22-2-hash-table"><a href="#_22-2-hash-table" class="header-anchor">#</a> 22.2 Hash Table</h2> <h3 id="_22-2-1-容器-hash-table"><a href="#_22-2-1-容器-hash-table" class="header-anchor">#</a> 22.2.1 容器 hash table</h3> <p>与《STL 标准库与泛型编程》中的 6.7.1 部分类似。主要讲了 Separate Chaining（分离链接法）</p> <h3 id="_22-2-2-hash-function"><a href="#_22-2-2-hash-function" class="header-anchor">#</a> 22.2.2 hash function</h3> <p><img src="/assets/img/1675343096756-5ea5cf63-c958-4a07-87ca-07cfc948d4c2.c1cae049.png" alt="image.png"></p> <ul><li>测试基本类型数据的 hash code 怎么取</li> <li>整数型的数据得到的也是整数型（包括 char）</li> <li>都是 3.141592653，float 和 double 不一样；都是 Ace，C 的字符串和 C++ 的不一样</li></ul> <p><img src="/assets/img/1675343969060-3d41bed5-ed62-45fa-987a-9db5c72ba5f8.6ee4dfb6.png" alt="image.png"></p> <ul><li>G2.9 整形的哈希函数，模板特化，传入什么就返回什么</li></ul> <p><img src="/assets/img/1675343991464-84fcd131-94bc-4ecd-a0aa-bb51c48d656b.5634a0ff.png" alt="image.png"></p> <ul><li>G2.9 字符串的哈希函数（C 风格的字符串，C++ 的字符串在 G2.9 还没有）</li></ul> <p><img src="/assets/img/1675344329686-86aa8b27-54c0-4db4-aeb8-fbd90cb5bd16.e9658c8c.png" alt="image.png"></p> <ul><li>手动计算出的结果与应该落入的桶的编号与观察到的结果相匹配</li></ul> <p><img src="/assets/img/1675344460987-b8cd1cab-bd26-4fec-b020-4fa4e40c680a.18a142d9.png" alt="image.png"></p> <ul><li>G4.9 版的哈希函数</li> <li>针对各种各样的类型做特化</li></ul> <p><img src="/assets/img/1675344497334-da88fc7c-5134-4e97-b16b-d5b87aced462.92d196ce.png" alt="image.png"></p> <ul><li>这一页左侧和上一页右侧都是针对整形做特化</li></ul> <p><img src="/assets/img/1675344602782-585b8847-7c0e-43e1-84d1-03505de0c6cb.dcd3a127.png" alt="image.png"></p> <ul><li>针对浮点数做特化，调用<code>_Hash_impl::hash()</code></li> <li>根据上一页，<code>_Hash_impl::hash()</code>调用了<code>_Hash_bytes()</code>，但这个函数没有定义，只有声明（可能已经编译成二进制了），所以如何计算浮点数的哈希函数不得而知</li></ul> <p><img src="/assets/img/1675344877362-e70da5dd-b1a4-4b17-a521-3f45f637e2fd.f5b3c286.png" alt="image.png"></p> <ul><li>functional_hash.h 里并没有字符串相关的哈希函数，很合理，因为字符串应该自己设计自己的哈希函数</li></ul> <p><img src="/assets/img/1675344970377-b458310b-3378-4d47-8380-ecad655e5a90.64429463.png" alt="image.png"></p> <ul><li>字符串的哈希函数，最后也是落到不知道怎么实现的<code>_Hash_bytes()</code></li></ul> <p><img src="/assets/img/1675345010057-559b36b4-0a17-4a26-8ee7-a916c0f169ca.e60416e1.png" alt="image.png"></p> <ul><li><code>_Hash_bytes()</code>出现的地方，只有声明，没有定义</li></ul> <p>一个万用的哈希函数，该部分没有视频，推断与《STL 标准库与泛型编程》中的 9.1 部分类似。用到了 variadic templates</p> <h1 id="_23-tuple"><a href="#_23-tuple" class="header-anchor">#</a> 23.tuple</h1> <p><img src="/assets/img/1675345524187-9cde5fad-170d-4132-bb85-4cca8311bd1f.cdb01996.png" alt="image.png"></p> <ul><li>tuple 源码大家已经很熟悉了（前面的 variadic templates 讲的很透彻了），这里只看用法</li> <li>与《STL 标准库与泛型编程》中的 9.2 部分相同</li></ul> <p><img src="/assets/img/1675345536697-b4e952a3-03cb-41de-a0da-457bd4182089.c645b6e3.png" alt="image.png"></p> <ul><li>在没有 variadic templates 的时候也有 tuple，我们看一下当时的做法</li> <li><code>GenScatterHiderarchy</code>其实就是想实现左侧的继承体系，它用 #define 硬写出来，局限在于它写到多少，里面就只能放多少个东西</li></ul> <p><img src="/assets/img/1675345545149-d6b4188f-7c0d-4a87-b378-81e13405a472.77baa867.png" alt="image.png"></p> <ul><li>boost 里的名字就叫 tuple</li> <li>概念和上面的差不多，也是硬写出来的，最多写到了针对 15 个的</li> <li><code>tuple_base</code>这一页放不开，放在上一页</li></ul> <p>其他参考：</p> <h1 id=""><a href="#" class="header-anchor">#</a></h1> <h1 id="-2"><a href="#-2" class="header-anchor">#</a></h1></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_1-1-演化" class="sidebar-link reco-side-_1-1-演化" data-v-70334359>1.1 演化</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_1-2-header-files" class="sidebar-link reco-side-_1-2-header-files" data-v-70334359>1.2 Header files</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_1-3-重点" class="sidebar-link reco-side-_1-3-重点" data-v-70334359>1.3 重点</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_2-1-概述" class="sidebar-link reco-side-_2-1-概述" data-v-70334359>2.1 概述</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_2-2-七大例子" class="sidebar-link reco-side-_2-2-七大例子" data-v-70334359>2.2 七大例子</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_22-1-array" class="sidebar-link reco-side-_22-1-array" data-v-70334359>22.1 array</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_22-2-hash-table" class="sidebar-link reco-side-_22-2-hash-table" data-v-70334359>22.2 Hash Table</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_22-2-1-容器-hash-table" class="sidebar-link reco-side-_22-2-1-容器-hash-table" data-v-70334359>22.2.1 容器 hash table</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020305.html#_22-2-2-hash-function" class="sidebar-link reco-side-_22-2-2-hash-function" data-v-70334359>22.2.2 hash function</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/assets/js/app.6240a449.js" defer></script><script src="/assets/js/8.9d998bdf.js" defer></script><script src="/assets/js/1.c70aaa24.js" defer></script><script src="/assets/js/6.c78de8db.js" defer></script><script src="/assets/js/18.7965e7af.js" defer></script>
  </body>
</html>
