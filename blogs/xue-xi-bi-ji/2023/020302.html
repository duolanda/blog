<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>侯捷 C++ 面向对象高级编程（下） | 飞&#39;s Space</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="keep Advancing">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.de4ca4d0.css" as="style"><link rel="preload" href="/assets/js/app.6240a449.js" as="script"><link rel="preload" href="/assets/js/8.9d998bdf.js" as="script"><link rel="preload" href="/assets/js/1.c70aaa24.js" as="script"><link rel="preload" href="/assets/js/7.4db18221.js" as="script"><link rel="preload" href="/assets/js/18.7965e7af.js" as="script"><link rel="prefetch" href="/assets/js/10.a746ca24.js"><link rel="prefetch" href="/assets/js/11.37b96bc6.js"><link rel="prefetch" href="/assets/js/12.0e620898.js"><link rel="prefetch" href="/assets/js/13.a1c573f5.js"><link rel="prefetch" href="/assets/js/14.6467db82.js"><link rel="prefetch" href="/assets/js/15.5fcfb8d3.js"><link rel="prefetch" href="/assets/js/16.06ad1c2e.js"><link rel="prefetch" href="/assets/js/17.ca9e6d13.js"><link rel="prefetch" href="/assets/js/19.8605ea14.js"><link rel="prefetch" href="/assets/js/20.88777038.js"><link rel="prefetch" href="/assets/js/21.142a739e.js"><link rel="prefetch" href="/assets/js/22.230bba9e.js"><link rel="prefetch" href="/assets/js/23.85d00b1e.js"><link rel="prefetch" href="/assets/js/24.2e093bb4.js"><link rel="prefetch" href="/assets/js/25.d93ef571.js"><link rel="prefetch" href="/assets/js/26.f48e6be4.js"><link rel="prefetch" href="/assets/js/27.b2000fa2.js"><link rel="prefetch" href="/assets/js/28.b033a1a5.js"><link rel="prefetch" href="/assets/js/29.9f4f42e0.js"><link rel="prefetch" href="/assets/js/3.73702826.js"><link rel="prefetch" href="/assets/js/30.a4cb1200.js"><link rel="prefetch" href="/assets/js/31.3b4dd163.js"><link rel="prefetch" href="/assets/js/32.a6617dc8.js"><link rel="prefetch" href="/assets/js/33.233d6c4e.js"><link rel="prefetch" href="/assets/js/34.9b6b8a8b.js"><link rel="prefetch" href="/assets/js/35.6af2c493.js"><link rel="prefetch" href="/assets/js/36.819b6ce9.js"><link rel="prefetch" href="/assets/js/37.ca2e1e69.js"><link rel="prefetch" href="/assets/js/38.8faca71a.js"><link rel="prefetch" href="/assets/js/39.65a0135e.js"><link rel="prefetch" href="/assets/js/4.8d3c60e4.js"><link rel="prefetch" href="/assets/js/40.487eb8c2.js"><link rel="prefetch" href="/assets/js/41.b86e9661.js"><link rel="prefetch" href="/assets/js/42.aeefaf21.js"><link rel="prefetch" href="/assets/js/43.8849cd8c.js"><link rel="prefetch" href="/assets/js/5.3406c297.js"><link rel="prefetch" href="/assets/js/6.c78de8db.js"><link rel="prefetch" href="/assets/js/9.7a339055.js">
    <link rel="stylesheet" href="/assets/css/0.styles.de4ca4d0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-1156296a><div data-v-1156296a><LoadingPage class="loading-wrapper" data-v-1156296a data-v-1156296a></LoadingPage> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>飞's Space</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>keep Advancing</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">飞's Space</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    duolanda
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>0</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/学习笔记/" class="nav-link"><i class="undefined"></i>
  学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/categories/文章/" class="nav-link"><i class="undefined"></i>
  文章
</a></li><li class="dropdown-item"><!----> <a href="/categories/踩坑/" class="nav-link"><i class="undefined"></i>
  踩坑
</a></li><li class="dropdown-item"><!----> <a href="/categories/游戏/" class="nav-link"><i class="undefined"></i>
  游戏
</a></li><li class="dropdown-item"><!----> <a href="/categories/问题速查/" class="nav-link"><i class="undefined"></i>
  问题速查
</a></li><li class="dropdown-item"><!----> <a href="/categories/项目总结/" class="nav-link"><i class="undefined"></i>
  项目总结
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-document"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/test-doc/" class="nav-link"><i class="undefined"></i>
  test-doc
</a></li><li class="dropdown-item"><!----> <a href="/docs/基建/" class="nav-link"><i class="undefined"></i>
  北邮基建
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/duolanda" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>侯捷 C++ 面向对象高级编程（下）</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>duolanda</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2024
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">侯捷 C++ 面向对象高级编程（下）</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>duolanda</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2022/12/24</span></i> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/blogs/xue-xi-bi-ji/2023/020302.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <!----></div></div> <div class="theme-reco-content content__default"><p><img src="/assets/img/1671777369629-ee512531-bfc1-4b6e-bdfd-cd25777fa95c.64501f17.png" alt="image.png">
整个标准库都是按照模板化编程的思维来写的，而不是面向对象思维。</p> <h1 id="_1-c-常用功能函数"><a href="#_1-c-常用功能函数" class="header-anchor">#</a> 1.C++ 常用功能函数</h1> <h2 id="_1-1-数据类型转换"><a href="#_1-1-数据类型转换" class="header-anchor">#</a> 1.1 数据类型转换</h2> <h3 id="_1-1-1-conversion-function-转换函数"><a href="#_1-1-1-conversion-function-转换函数" class="header-anchor">#</a> 1.1.1 conversion function（转换函数）</h3> <p><img src="/assets/img/1671778051817-4090500a-ce01-484f-a4a2-96895d942993.5321e0eb.png" alt="image.png"></p> <ul><li>我们这里有一个分数，可以认为分子/分母就是 double，因此设计者希望分数可以被当成 double，于是编写黄色高亮部分。意思是 Fraction 可以被转为 double，编译器在碰到任何需要把 Fraction 转为 double 的时候就调用黄色部分。</li> <li>作用：把一个 class 的类型转换成你想要的、自认为合理的类型。</li> <li>格式：<code>operator double() const {...}</code>(以转换成 double 类型为例)
<ul><li><code>double()</code>不可以有参数；没有 return type（毕竟后面已经写清楚是 double 了）；分子和分母都不应该改变，所以通常要加<code>const</code></li></ul></li> <li>只要你认为合理，你可以在类中写多个转换函数，将 class 类型转换成多个其他类型。</li></ul> <h3 id="_1-1-2-non-explicit-one-argument-ctor-与-explicit-one-argument-ctor"><a href="#_1-1-2-non-explicit-one-argument-ctor-与-explicit-one-argument-ctor" class="header-anchor">#</a> 1.1.2 non-explicit-one-argument ctor 与 explicit-one-argument ctor</h3> <p><img src="/assets/img/1671778893546-f93aac0c-b1c5-4554-8988-054f2abe22b5.7cf39f83.png" alt="image.png"></p> <ul><li>这种构造函数很特别，称为** non-explicit-one-argument ctor**，one argument 指的是一个实参（两个也可以，但是一个就够了），explicit 是关键字，这里没有加，所以是 non-explicit</li> <li>作用：把其他类型转换为这个 class 的类型。与转换函数刚好相反。</li> <li>执行到<code>f+4</code>时，编译器发现 Fraction 定义了 +，但是参数要是 Fraction，于是编译器尝试将 4 转为 Fraction，由于有绿色的部分，4 变成了 4/1，可以正常相加。</li></ul> <p><img src="/assets/img/1671779365838-e9319f9d-a95e-47a1-9802-156da2736435.08c254fa.png" alt="image.png"></p> <ul><li>如果黄绿二者并存，且代码为<code>Fraction d2=f+4;</code>编译器发现会有两条路可以走：
<ul><li>可以通过 non-explicit-one-argument ctor 把 4 转换成 Fraction 类型，再与 f 相加。</li> <li>可以通过转换函数把 Fraction 类型的 f 转换成 0.6，再与 4 相加，再通过 non-explicit-one-argument ctor 把 4.6 转换成 Fraction 类型。</li></ul></li> <li>此时会产生二义性（歧义），编译器报错</li></ul> <p><img src="/assets/img/1671779604550-e5b86753-17a1-4f38-852d-1598ce8f948c.193a538f.png" alt="image.png"></p> <ul><li>explicit 的意思是明确的。告诉编译器，只有真正需要构造函数的时候再调用构造函数，编译器不能擅自把 4 转为 4/1</li> <li>这个关键字只在这里使用（其实模板的一个很小的地方也会用到，但是太细微了）</li></ul> <h2 id="_1-2-pointer-like-classes"><a href="#_1-2-pointer-like-classes" class="header-anchor">#</a> 1.2 <strong>pointer-like classes</strong></h2> <h3 id="_1-2-1-智能指针"><a href="#_1-2-1-智能指针" class="header-anchor">#</a> 1.2.1 智能指针</h3> <p><img src="/assets/img/1671780088298-10fc4868-8e9d-4734-afad-057181aad374.a7a64371.png" alt="image.png"></p> <ul><li>为什么我们要设计像指针的类，是为了做比指针更多的事</li> <li>智能指针中一定有一个一般的指针。这里 px 就是那个指针。</li> <li>指针能做的它也应该能做，所以它一定有<code>*</code> 、<code>-&gt;</code>这两个操作符的重载，且实现手法都是固定的。</li> <li><code>sp-&gt;method()</code>等同于 <code>px-&gt;method()</code>，这时大家可能会困惑，<code>-&gt;</code>已经把 sp 变成 px 了，怎么还会有一个<code>-&gt;</code>，这是因为 C++ 语法规定<code>-&gt;</code>不会被“消耗”，在发挥作用之后依然可以使用。注意，<code>*</code>使用一次之后就会被“消耗”，*sp 就是变成 *px。</li></ul> <h3 id="_1-2-2-迭代器"><a href="#_1-2-2-迭代器" class="header-anchor">#</a> 1.2.2 迭代器</h3> <p><img src="/assets/img/1671780955715-80d89c1c-3cf4-4249-ad55-59b29e06f0a9.18c075c5.png" alt="image.png"></p> <ul><li>迭代器主要用来遍历容器</li> <li>迭代器和上面一般的智能指针有些不同，不光要处理<code>*</code>和<code>-&gt;</code>，还要重载<code>++</code>、<code>--</code>等，对<code>*</code>和<code>-&gt;</code>的处理也有所不同</li></ul> <p><img src="/assets/img/1671781197255-67d9c50c-2004-4ba6-bc20-4c2449a390be.8925ea32.png" alt="image.png"></p> <ul><li>这里用双向链表的迭代器举例</li> <li>绿色的 node 就是这里真正的指针</li> <li>用户使用<code>*</code>是为了取得数据，于是我们解参考，再把 data 返回给用户</li> <li>用户使用<code>-&gt;</code>等同于<code>(*ite).method()</code>等同于<code>(&amp;(*ite))-&gt;method()</code>，于是我们设计成返回<code>&amp;(operator*())</code>，其中<code>operator*()</code>就是上面的<code>*</code>部分</li></ul> <h2 id="_1-3-function-like-classes"><a href="#_1-3-function-like-classes" class="header-anchor">#</a> 1.3 function-like classes</h2> <p><img src="/assets/img/1671781746692-5c786c41-2256-41f8-8b3e-c0fe9e1f5661.dcaac81b.png" alt="image.png"></p> <ul><li><code>()</code>被称为函数调用操作符，所以任何一个东西如果能接受<code>()</code>，我们就称它为 function-like</li> <li>例子中的三个类都重载了<code>()</code>，所以他们都是 function-like
<ul><li><code>identity</code>的意思是同一个东西，所以它接收 x 就传回来 x</li> <li><code>select1st</code>接收 Pair 类型的元素，取出第一个。代码示例：<code>select1st&lt;Pair&gt;()()</code>，前面的括号负责创建临时对象，后面的括号才是调用函数，两者不同</li> <li><code>select2nd</code>，同理，取出第二个</li></ul></li> <li>这样的 class 生成的对象称为函数对象或仿函数</li> <li>灰色部分其实是有内容的，还很长，继承了其他的 class</li></ul> <p><img src="/assets/img/1671782618632-859caed9-7539-4e5c-8582-8fd3e87c0cc1.4052452a.png" alt="image.png"></p> <ul><li><code>identity</code> <code>select1st</code> <code>select2ed</code>继承了<code>unary_function</code>，<code>plus</code> <code>minus``equal_to``less</code>继承了<code>binary_function</code>，前者意思是一个操作数，后者是两个操作数</li> <li>这些奇特父类的大小理论上为 0（实现上 sizeof 可能会得到 1），且没有数据、没有函数，只有一些 typedef 定义。具体为什么继承这些是一个很大的话题，请参见标准库课程。</li></ul> <h2 id="_1-4-namespace-经验谈"><a href="#_1-4-namespace-经验谈" class="header-anchor">#</a> 1.4 namespace 经验谈</h2> <p><img src="/assets/img/1671783230993-5afb0cde-6bde-4d34-9e61-428325334e70.4c1e64bd.png" alt="image.png"></p> <ul><li>namespace 的主要用途就是为了避免命名冲突，在大型工程中尤为常见，自己在写一些测试代码时也可以使用命名空间封装起来。</li> <li>这里的例子是测试程序</li></ul> <h2 id="_1-5-模板"><a href="#_1-5-模板" class="header-anchor">#</a> 1.5 模板</h2> <h3 id="_1-5-1-class-template-类模板"><a href="#_1-5-1-class-template-类模板" class="header-anchor">#</a> 1.5.1 class template（类模板）</h3> <p><img src="/assets/img/1671783461633-d535dfa1-7e34-4e23-8a8c-f8d95fca0fd7.b5279b3d.png" alt="image.png"></p> <ul><li>前面的课程讲过，这里简单带过</li> <li>其实比面向对象简单，因为在涉及到继承和虚函数的时候可能会有很多层、很复杂</li> <li>把类型&quot;提取&quot;出来，在用的时候在进行替换补充就好</li></ul> <h3 id="_1-5-2-function-template-函数模板"><a href="#_1-5-2-function-template-函数模板" class="header-anchor">#</a> 1.5.2 function template（函数模板）</h3> <p><img src="/assets/img/1671783618526-1c2c3ce3-3d75-4221-b242-40f2adad6ebc.336d9adf.png" alt="image.png"></p> <ul><li>前面的课程讲过，这里简单带过</li> <li>使用比类模板更简单，使用时无需指明 type</li> <li>如果 stone 没有重写<code>&lt;</code>，就会编译失败</li></ul> <h3 id="_1-5-3-member-template-成员模板"><a href="#_1-5-3-member-template-成员模板" class="header-anchor">#</a> 1.5.3 member template（成员模板）</h3> <p><img src="/assets/img/1671783823862-81c333a6-e6fc-45db-ae03-ad073b7e5bc5.074f0ed3.png" alt="image.png"></p> <ul><li>黄色部分是模板里的一个 member，而它本身又是一个模板，我们将它称为成员模板。</li></ul> <p><img src="/assets/img/1671783929495-1125aabb-a26a-455b-a18d-70358e867c6b.a6186361.png" alt="image.png"></p> <ul><li>一般用在构造函数中</li> <li>设计四个类，鱼类、鸟类、鲫鱼、麻雀</li> <li>把鲫鱼和麻雀构成 pair，鱼类和鸟类构成 pair，可以把鲫鱼和麻雀的 pair 作为初值放到鸟类和鱼类的 pair 里，但反之不行</li> <li>如何体现这种设计，我允许你放任意的 T1 T2，并且构造的时候可以放任意的 U1 U2，但 U1 U2 必须满足赋值动作<code>first(p.first), second(p.second)</code>初值是鲫鱼和麻雀，鲫鱼是鱼类满足转型<code>first(p.first)</code>，同理，麻雀也是鸟类，所以可以。如果初值是鲸鱼和麻雀便不行，因为鲸鱼不是鱼类。</li></ul> <p><img src="/assets/img/1671784440368-693191cf-a2f1-408c-884a-6686988807e1.19b9276d.png" alt="image.png"></p> <ul><li>new 一个鲫鱼，指针指向鱼类，是可以的。称为 up-cast。</li> <li>既然指针可以，智能指针也必须可以，为了实现这一点，要写上方的成员模板代码</li></ul> <h3 id="_1-5-3-specialization-模板特化"><a href="#_1-5-3-specialization-模板特化" class="header-anchor">#</a> 1.5.3 specialization（模板特化）</h3> <p><img src="/assets/img/1671785224676-9ff3f2e5-eb58-4c4a-9fec-34d6191c0256.0b97aa75.png" alt="image.png"></p> <ul><li>任意的类型都会来到 hash{}，但如果指定的是 char、int、long，编译器就会用这三段代码</li> <li>上面的框是泛化，下面的框是特化</li></ul> <h3 id="_1-5-3-partial-specialization-模板偏特化"><a href="#_1-5-3-partial-specialization-模板偏特化" class="header-anchor">#</a> 1.5.3 partial specialization（模板偏特化）</h3> <h4 id="_1-个数上的偏"><a href="#_1-个数上的偏" class="header-anchor">#</a> 1.个数上的偏</h4> <p><img src="/assets/img/1671785578133-91153d6e-17fb-4e35-94c3-43efe7f42c31.637d1208.png" alt="image.png"></p> <ul><li>在有多个模板参数时，绑定其中一个参数</li> <li>一定要严格的从左到右，比方说有五个模板参数，不能跳着绑定 1、3、5</li></ul> <h4 id="_2-范围上的偏"><a href="#_2-范围上的偏" class="header-anchor">#</a> 2.范围上的偏</h4> <p><img src="/assets/img/1671785770195-bcb8c28c-aa54-4c2c-b646-1da88a83f993.93b00e48.png" alt="image.png"></p> <ul><li>将什么类型都可以传的模板，偏特化为只有指针类型（指针什么都能传）能传的模板。</li> <li>是指针用一套代码，不是指针用另一套代码</li> <li>泛化的 T 和 T* 中的 T 是两样东西，为了避免混淆，可以写成 U 和 U*</li></ul> <h3 id="_1-5-4-template-template-parameter-模板的模板参数"><a href="#_1-5-4-template-template-parameter-模板的模板参数" class="header-anchor">#</a> 1.5.4 template template parameter（模板的模板参数）</h3> <p><img src="/assets/img/1671786089480-699625b0-a7d7-44d4-b709-7614cf7dc809.41233b09.png" alt="image.png"></p> <ul><li>一个模板的参数是模板类型。例子中第二个参数是模板</li> <li>只有在模板的尖括号中 typename 和 class 才能共通，其他地方都不可以</li> <li>在例子中，使用者可以指定任意的元素类型和容器类型。但是<code>list</code>其实是有第二模板参数的，平时可以不写是因为有默认值，但这里会报错。为了解决这个问题，引入中间框内的两行（具体含义不解释，比较复杂，是 C++ 11 语法）</li></ul> <p><img src="/assets/img/1671786483361-fd6ae76a-4f5e-4edb-911c-4a177a38f618.db5292ad.png" alt="image.png"></p> <ul><li>这个例子中不再传容器，而是传智能指针，因为大部分智能指针只有一个模板参数，不会报错。但<code>weak_ptr</code>和<code>auto_ptr</code>因为一些特性也不可以，这不是我们的重点</li></ul> <p><img src="/assets/img/1671786609417-da256a15-1a4f-4ae4-8966-389dedca5bcf.cceebfd6.png" alt="image.png"></p> <ul><li>Sequence 是模板里的参数，而且本身是模板，但确实不是模板的模板参数</li> <li>如果我们在使用时把两个参数都写出来，必须写成<code>stack&lt;int, list&lt;int&gt;&gt;</code>，会发现它已经不是模板了，而是已经完全绑定写死了，所以与前面的例子并不相同</li></ul> <h2 id="_1-6-c-标准库"><a href="#_1-6-c-标准库" class="header-anchor">#</a> 1.6 C++ 标准库</h2> <p><img src="/assets/img/1671786927776-5dc2338c-abd8-4b1e-93a9-9079356e3621.e5657e78.png" alt="image.png"></p> <ul><li>标准库提供给我们可以直接用的一个就是容器（数据结构），另一个就是算法</li> <li>建议大家都用一遍，测试一遍，熟记有哪些内容，避免未来重复造轮子</li></ul> <h1 id="_2-c-11-和-reference"><a href="#_2-c-11-和-reference" class="header-anchor">#</a> 2.C++11 和 reference</h1> <p>C++11 有专门的课程，这里挑选了三个重要的小主题讲解</p> <h2 id="_2-1-variadic-templates-可变模板参数"><a href="#_2-1-variadic-templates-可变模板参数" class="header-anchor">#</a> 2.1 variadic templates（可变模板参数）</h2> <p><img src="/assets/img/1671862090075-283b4f66-117c-4a39-9b9a-ad8d67dee4ce.f2fa9c10.png" alt="image.png"></p> <ul><li>三个里面最重要的，其他两个只是语法糖</li> <li>可以传入数量不定的模板参数，它把传入的参数分为：<strong>一个</strong>和<strong>一包</strong>。一包使用<code>...</code>表示，注意一个是<code>typename... Types</code>，一个是<code>Types&amp;... args</code>，位置不同</li> <li>例子中使用了递归，输出完 42 的时候<code>args...</code>就是空了，所以有写了上面的<code>void print()</code>，调用它来结束。当然，实际使用中也不一定递归，还有其他很多运用。</li> <li>如果你想确定这“一包”参数具体有多少个，可以用语法：<code>sizeof...(args)</code></li> <li>整个标准库都用这个新语法翻新了</li></ul> <h2 id="_2-2-auto"><a href="#_2-2-auto" class="header-anchor">#</a> 2.2 auto</h2> <p><img src="/assets/img/1671863038015-c0db01b8-816f-4bf1-b5fb-71f6ab641167.7bc159c7.png" alt="image.png"></p> <ul><li>面对复杂的返回类型可以用<code>auto</code>自动推导出来</li> <li>过去 ite 的类型要写很长，现在写成<code>auto</code>就可以了</li> <li>使用<code>auto</code>的时候一定要让编译器能帮你推，最下面的框就不行</li> <li>作为标准库的使用者，都应该具备能把容器类型写出来的能力，<code>auto</code>只是方便我们而已，但<code>lambda</code>的类型是真写不出来</li></ul> <h2 id="_2-3-ranged-base-for"><a href="#_2-3-ranged-base-for" class="header-anchor">#</a> 2.3 ranged-base for</h2> <p><img src="/assets/img/1671863493453-106b53b8-fe9c-46df-bdd8-c15650b1253f.fe1ef7d0.png" alt="image.png"></p> <ul><li>它有两个参数，一个是自己创建的变量，另一个是一个容器</li> <li>范围 for 循环可以将一个容器(第二个参数)里的元素依次传到第一个参数，并在该循环体中依次对每一个元素做操作</li> <li>如果你不想影响容器中的参数，请 <strong>pass by value</strong>，否则请 <strong>pass by reference</strong></li> <li>这里引出一个概念，引用其实是一种指针（从编译器实现的角度）</li></ul> <h2 id="_2-4-reference"><a href="#_2-4-reference" class="header-anchor">#</a> 2.4 reference</h2> <p><img src="/assets/img/1671863990476-3a0473e5-5439-418b-9bf0-5a0325e65a74.6f02a3d1.png" alt="image.png"></p> <ul><li>x 是整数，p 是指向 x 的指针，r 是 x 的引用。x、p、r 都是变量，都占用内存，x 是整数占 4 个字节，p 是指针，也占 4 个字节，r 代表 x，所以也是整数，它代表的东西多大，它也多大，也是 4 个字节</li> <li>其实编译器是把 r 当成指针处理的，r 实际上就是 4 个字节，但编译器会制造“假象”，如果 x 大小是 100 字节，<code>sizeof(r)</code>也会是 100 字节，并且 r 和 x 的地址也是完全相同的，这是好事，符合我们对 r 逻辑上的解读（r 是 x 的代表，x 是什么，r 就应该是什么）</li> <li>reference 一定要有初值，说清楚它代表谁，而且设完之后不能再变了，不能再代表其他了。</li> <li><code>r = x2</code>相当于<code>x=x2</code>，所以并不是说 r 变成代表 x2 了，而是 r 和 x 都变成 5 了。</li></ul> <p><img src="/assets/img/1671864850058-4e290490-15d6-49c4-99e4-1791e860d203.306b19cb.png" alt="image.png"></p> <ul><li>验证代码，object 和其 reference 的大小相同，地址也相同（全都是假象）</li></ul> <p><img src="/assets/img/1671865047317-49bb4b48-fc24-4069-8f20-1ce8e10449df.d8559400.png" alt="image.png"></p> <ul><li>reference 是一种漂亮的 pointer</li> <li>reference 通常不用于声明变量，而**用于参数类型（parameters type）和返回类型（return type）**的描述，即多用于参数传递上</li> <li>可以发现，pass by value（func2） 和 pass by reference（func3）在被调用端写法是相同的，这是件很棒的事，不会像 pass by pointer（func1）一样不同，并且 reference 在保证写法相同的前提下速度又更快了</li> <li>如果 <code>imag(const double&amp; im){...}</code>和<code>imag(const double im){...}</code>被视为不同的话就麻烦大了，因为在调用 imag 时，编译器就会不知道你要调用哪个，所以二者不能同时存在。</li> <li><code>const</code>是函数签名的一部分，加不加 const 是两个函数</li></ul> <h1 id="_3-object-model-虚函数、虚指针、虚表、动态绑定"><a href="#_3-object-model-虚函数、虚指针、虚表、动态绑定" class="header-anchor">#</a> 3.Object Model（虚函数、虚指针、虚表、动态绑定）</h1> <p>一些底层的，表面看不到的东西，对于 C++ 理解至关重要</p> <h2 id="_3-1-复合-继承关系下的构造和析构"><a href="#_3-1-复合-继承关系下的构造和析构" class="header-anchor">#</a> 3.1 <strong>复合&amp;继承关系下的构造和析构</strong></h2> <p><img src="/assets/img/1671865734953-3a8ba648-a134-4fe5-aa91-48cc4e6093ce.b5bab1cd.png" alt="image.png"></p> <ul><li>回顾一下之前讲过的复合关系下的构造和析构顺序，继承关系下的构造和析构顺序</li></ul> <p><img src="/assets/img/1671865902339-4706422e-ce6d-46c8-8add-4e3bf91210e9.84a41bd4.png" alt="image.png"></p> <ul><li>考虑继承+复合关系下的构造和析构，以下结论为老师手头编译器得到的结果</li> <li>先调用父类构造函数、再调用 Component，最后自己；析构反过来，先自己、再 Component、再 Base</li></ul> <h2 id="_3-2-关于-vptr-虚指针-和-vtbl-虚表"><a href="#_3-2-关于-vptr-虚指针-和-vtbl-虚表" class="header-anchor">#</a> 3.2 <strong>关于 vptr（虚指针）和 vtbl（虚表）</strong></h2> <p><img src="/assets/img/1671866155742-9b50fd9e-4394-4625-acf7-773177107c1d.c6bc6b52.png" alt="image.png"></p> <ul><li>B 继承 A，C 继承 B</li> <li>当子类继承父类时，除了继承数据之外，同时会继承父类的函数（父类如果有虚函数，子类也一定有）</li> <li>子类继承父类的函数，继承的其实是它的<strong>调用权</strong>，而不是大小</li> <li>A、B、C 总共有 8 个函数，4 个非虚函数，4 个虚函数</li> <li>A 有两个虚函数 vfunc1、vfunc2 以及两个非虚函数 func1、func2；B 类继承 A 类的 vfunc2，同时覆写A类的 vfunc1，此时 B 有两个虚函数(vfunc1 和 vfunc2)；C 类继承了 B 类的 vfunc2（vfunc2 其实是 A 的），同时覆写了 vfunc1，也有两个虚函数。</li> <li>只要一个类拥有虚函数，则就会有一个虚指针 vptr，该 vptr 指向一个虚表 vtbl，虚表 vtbl 中放的都是函数指针，指向虚函数所在的位置。可以观察到，关系图中虚表中的函数指针都指向相应的虚函数的位置，编译器也是用相同的路径调用到正确的函数，这其实就是<strong>动态绑定</strong>的关键（静态绑定地址都是写死的，动态绑定会看 p 指向什么）。</li> <li>上面的步骤写成 C 的形式就是<code>(*(p-&gt;vptr)[n])(p);</code>或<code>(* p-&gt;vptr[n])(p);</code>n 指的是要调用的虚函数在虚表中的第几个。n 在写虚函数代码的时候编译器看该虚函数第几个写的则 n 就是几。</li></ul> <p><img src="/assets/img/1671867104100-f392b3f9-21c2-4b6e-86cb-80bcca52d853.8cc9bc7d.png" alt="image.png"></p> <ul><li>换一个生活中的例子</li> <li>我们为了让容器能够存放不同的形状，必须让它放置指针，否则不同形状在内存中的占用大小不一，容器无法存放</li> <li>在绘制时，每个图形都各自用自己的<code>draw()</code>绘制（类似上一页的 <code>vfunc1()</code>），因此需要用虚函数实现。如果是 C，只能用代码判断是什么形状，再用对应函数绘制，这很不好，如果未来要添加新的形状，代码也要多写 if  else</li> <li>总结一下，C++编译器看到一个函数调用，它有两个考量：
<ul><li>是静态绑定吗？（Call ×××）</li> <li>还是动态绑定，要想动态绑定要满足三个条件：
<ul><li>第一：必须是<strong>通过指针来调用</strong></li> <li>第二：该指针是<strong>向上转型</strong>（up-cast）的</li> <li>第三：调用的是<strong>虚函数</strong></li></ul></li></ul></li> <li>这种用法被称为多态（polymorphism），可以发现，多态、虚函数、动态绑定是指的一回事，把这部分基础打牢，能很好的理解面向对象</li></ul> <h2 id="_3-3-关于-this"><a href="#_3-3-关于-this" class="header-anchor">#</a> 3.3 关于 this</h2> <h2 id=""><a href="#" class="header-anchor">#</a> <img src="/assets/img/1671867999023-7afb44a3-a4e8-4dac-a975-0f3a04a388c7.5ff4e927.png" alt="image.png"></h2> <ul><li>通过对象调用一个函数，那个对象的地址就是<code>this</code></li> <li>对于<code>this</code>概念要很清晰，不然在分析继承体系的时候会搞不清谁调用谁</li> <li>子类对象调用父类的函数，执行到<code>Serialize()</code>时会跑到子类重写的部分再跑回去，为什么会跑到这来呢，答案是动态绑定</li> <li><code>myDoc.OnFileOpen();</code>中，myDoc 在调用它，所以 myDoc 的地址就是 this，传进来之后，<code>OnFileOpen()</code>中所有的动作都是通过 this 调用的，到<code>this-&gt;Serialize()</code>时，编译器发现：
<ul><li>this 是指针</li> <li>myDoc 是子类对象，this 指向子类对象，所以是向上转型</li> <li>this 调用的是虚函数</li></ul></li> <li>于是满足动态绑定的条件，实际执行为<code>(*(this-&gt;vptr)[n])(this);</code>，编译器发现 this 指向子类，所以调用的是子类的虚函数，而不是父类的</li></ul> <h2 id="_3-4-关于动态绑定"><a href="#_3-4-关于动态绑定" class="header-anchor">#</a> 3.4 关于动态绑定</h2> <p><img src="/assets/img/1671868932730-c2e1fa01-dbd5-4b93-853c-5155cb5f5e4a.9b7990aa.png" alt="image.png"></p> <ul><li>为什么动态绑定解析成 C 语言是<code>(*(p-&gt;vptr)[n])(p);</code>或<code>(* p-&gt;vptr[n])(p);</code>呢，下面从汇编角度分析</li> <li>a 是 A 的对象，它不是指针，调用方式是静态绑定，可以看到汇编呈现的是：call 一个地址</li></ul> <p><img src="/assets/img/1671869024070-86eba877-7bd7-441f-be63-cdc6c53fb9bc.3405e9ac.png" alt="image.png"></p> <ul><li>下面通过 pa 调用，pa 满足动态绑定的三个条件，可以看出，call 后面不再是固定的地址，而汇编呈现的内容等价于 C 语言的<code>(*(p-&gt;vptr)[n])(p);</code>或<code>(* p-&gt;vptr[n])(p);</code></li></ul> <h1 id="_4-const、动态分配与-new、delete"><a href="#_4-const、动态分配与-new、delete" class="header-anchor">#</a> 4.const、动态分配与 new、delete</h1> <h2 id="_4-1-谈谈-const"><a href="#_4-1-谈谈-const" class="header-anchor">#</a> 4.1 谈谈 const</h2> <h2 id="-2"><a href="#-2" class="header-anchor">#</a> <img src="/assets/img/1671869591577-1cc10ce8-b8de-4746-bba2-78f757079f6f.99ff2fac.png" alt="image.png"></h2> <ul><li>之前课程的例子<code>double real() const {return re;}</code></li> <li>加 const 的意图是告诉编译器，成员函数不打算改变 class 的 data，只是读，请编译器帮忙把关，看有没有违反意图</li> <li>对象调用成员函数的时候，对象可能是 const，也可能不是，成员函数同理，于是产生了四种情况。我的数据是不能改变的，这个函数却可能改变我的数据，所以 const object 不能调用 non-const 函数</li> <li>const也是函数签名的一部份，即可构成函数重载。</li> <li>标准库的字符串时能共享的，四份相同的字符串会共享一个，所以其中一个人要改的时候，要单独拷贝一份修改，另外三个人继续共享原来的。使用者可能会写<code>a[5]='B'</code>，意味着 [] 有可能被用来修改数据，因此不带 const 的 [] 必须要考虑 Copy On Write 行为。考虑常量字符串，它不会改变内容，可以不必考虑 COW，所以如果能区分两个函数会很好。</li> <li>当成员函数的 const 和 non-const 版本同时存在，const 对象只能调用 const 版本的成员函数，non-const 对象只能调用 non-const 版本的成员函数。
<ul><li>如果这条规则不存在，non-const 的字符串有可能会调用 const 的 []，这样 const 的 [] 依然要考虑 COW，不符合我们的想法</li> <li>这条规则保证只有常量字符串才会调用 const 的 []，const 的 [] 可以放心地不必考虑 COW。</li></ul></li></ul> <h2 id="_4-2-关于-new、delete"><a href="#_4-2-关于-new、delete" class="header-anchor">#</a> 4.2 关于 new、delete</h2> <p><img src="/assets/img/1671871073889-fd9fe3fc-25fb-4ca0-866e-3fa60f767731.9ebf841a.png" alt="image.png"></p> <ul><li>全部是回顾之前讲过的</li> <li>使用 new，其实会有三个动作，依次为：分配内存、转型、构造函数；delete 有两个动作：析构函数、释放内存</li> <li>当我们 new 一个对象或 delete 一块内存的时候，这个 new、delete 是一个 expression（表达式），不可以重载。但是他们的内部 new、delete 是 operator（操作符）可以重载。重载后可用来写内存池</li> <li>array new 一定要搭配 array delete。</li></ul> <h2 id="_4-3-重载-operator-new-operator-delete"><a href="#_4-3-重载-operator-new-operator-delete" class="header-anchor">#</a> 4.3 <strong>重载 operator new，operator delete</strong></h2> <h3 id="_4-3-1-全局重载-operator-new-operator-delete-operator-new-operator-delete"><a href="#_4-3-1-全局重载-operator-new-operator-delete-operator-new-operator-delete" class="header-anchor">#</a> 4.3.1 全局重载 ::operator new, ::operator delete, :: operator new[], ::operator delete[]</h3> <p><img src="/assets/img/1671871274958-2567b7ef-ad93-4308-91c7-278df980c40e.ce8591a5.png" alt="image.png"></p> <ul><li><code>::</code>代表全局的</li> <li>着用这种重载要小心，它影响范围是全局。</li></ul> <h3 id="_4-3-2-重载-member-operator-new-delete"><a href="#_4-3-2-重载-member-operator-new-delete" class="header-anchor">#</a> 4.3.2 重载 member operator new/delete</h3> <p><img src="/assets/img/1671871415119-c1af1bb0-a353-4549-96fd-489353d3ed40.34eb8198.png" alt="image.png"></p> <ul><li>现在是在类里</li> <li>delete 重载的第二个参数时是可选的，可以不写</li></ul> <h3 id="_4-3-3-重载-member-operator-new-delete"><a href="#_4-3-3-重载-member-operator-new-delete" class="header-anchor">#</a> 4.3.3 重载 member operator new[] / delete[]</h3> <p><img src="/assets/img/1671871567384-78b617b4-de6d-4a43-85d8-9b75352d2217.a316544e.png" alt="image.png"></p> <ul><li>和上一页比对，只有 [] 的区别</li></ul> <h3 id="_4-3-4-接口示例"><a href="#_4-3-4-接口示例" class="header-anchor">#</a> 4.3.4 接口示例</h3> <p><img src="/assets/img/1671871781938-95654e47-9cd6-4d98-a41c-a8d69c3e9fc1.8558d44a.png" alt="image.png"></p> <ul><li>如果使用者想绕过重写，可以加全局作用域<code>Foo* pf = ::new Foo;``::delete pf;</code>（虽然很难想象什么场景下会有这种需求）</li></ul> <p><img src="/assets/img/1671871977991-995e553e-f174-41aa-884b-4a716ad36e41.d3586c99.png" alt="image.png"></p> <ul><li>Foo 有 一个 int 一个 long 一个 string，int 占 4 字节，long 占 4 字节，string 里面其实是指针，占 4 字节。所以第一行显示，一个 Foo 占 12 个字节</li> <li>如果 Foo 有虚函数，就会多一个指针，大小为 16 字节</li> <li><code>new Foo[5];</code>，12*5=60，但显示出来是 64，为什么会多出一个 4？这个 4 记录的其实是数组大小（5），这样编译器才能很快的知道，下面要调用 5 次构造或 5 次析构</li></ul> <p><img src="/assets/img/1671872542428-9e7eae06-3d1f-4b8a-ab42-cf5ab410894d.efc0061f.png" alt="image.png"></p> <ul><li>通过测试程序可以发现，加上<code>::</code>后确实没有进入重写的部分</li></ul> <h2 id="_4-4-重载-new-delete"><a href="#_4-4-重载-new-delete" class="header-anchor">#</a> 4.4 <strong>重载 new()，delete()</strong></h2> <p><img src="/assets/img/1671872640391-3f07df1b-8cdf-4a1a-ba42-0f1e4a83c06a.2cbb50d6.png" alt="image.png"></p> <ul><li><p>这种形式叫作 placement new</p></li> <li><p>使用形式：<code>Foo* pf = new(300,'c') Foo;</code></p></li> <li><p>可以重载多个 class member operator new() 版本，但每一个版本的<strong>参数列表必须独一无二</strong></p></li> <li><p>且参数列表的第一个参数必须为 <strong>size_t</strong>，其余参数以 new 所指定的 placement arguments 为初值。出现在new(......) 小括号内的便是所谓的 placement arguments。</p> <ul><li>很合理，因为必须知道大小才能分配内存</li></ul></li> <li><p>所以上述的使用形式小括号内虽然看到有两个参数(300，‘c’)，但其实有三个。</p></li> <li><p>可以重载多个 class member operator delete() 版本，但绝不会被 delete 调用（这个 delete 是指可以被分解为两步的那个 delete）</p></li> <li><p>唯一被调用的时机：只有当 new 所调用的构造函数(new 被分解的第一步)抛出异常，才会调用与 new 对应的那个重载 operator delete()，主要用来归还未能完全创建成功的对象所占用的内存。</p></li></ul> <p><img src="/assets/img/1671872732997-c9be5cdb-3ffc-4bb3-a789-fccfa40f349b.7e94f41a.png" alt="image.png"> <img src="/assets/img/1671872759748-f65f69fa-d608-45d5-b41e-126a875bfea1.351e2b23.png" alt="image.png"></p> <ul><li>(5) 是故意写错第一个参数的版本，会报错</li> <li>为了测试 placement operator delete，故意在第一页抛出异常</li> <li>下面的四个 operator delete 每个都是对应上面的一个 operator new</li> <li>如果 operator new 调用构造函数时发生异常，应该把刚刚分配的内存释放掉才对，否则会发生内存泄漏，就在这时，对应的 operator delete 就会被调用，去释放内存</li> <li>p1、p2、p3、p4 都是调用默认的构造函数，p5 故意调用了会抛出异常的带参数的构造函数（C++ 程序在抛出异常后就不会继续执行了，所以 p6、p7、p8 不用管），但奇怪的是，这次测试中没有调用 operator delete，之前的测试却调用了，可能和编译器有关</li> <li>即使 operator delete 未能一一对应 operator new，也不会出现任何报错，编译器只会认为你不在乎异常，而不会强制要求你处理</li></ul> <p><img src="/assets/img/1671873705772-6f73bcc9-afed-4b3e-b07e-71a482e13be8.cb5cf2dc.png" alt="image.png"></p> <ul><li>标准库重载 placement operator new 的例子</li> <li>字符串是放到 extra 部分里，Rep 做计数器</li> <li>他这样做可以无声无息地多分配一部分内存</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-1-数据类型转换" class="sidebar-link reco-side-_1-1-数据类型转换" data-v-70334359>1.1 数据类型转换</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-1-1-conversion-function-转换函数" class="sidebar-link reco-side-_1-1-1-conversion-function-转换函数" data-v-70334359>1.1.1 conversion function（转换函数）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-1-2-non-explicit-one-argument-ctor-与-explicit-one-argument-ctor" class="sidebar-link reco-side-_1-1-2-non-explicit-one-argument-ctor-与-explicit-one-argument-ctor" data-v-70334359>1.1.2 non-explicit-one-argument ctor 与 explicit-one-argument ctor</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-2-pointer-like-classes" class="sidebar-link reco-side-_1-2-pointer-like-classes" data-v-70334359>1.2 pointer-like classes</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-2-1-智能指针" class="sidebar-link reco-side-_1-2-1-智能指针" data-v-70334359>1.2.1 智能指针</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-2-2-迭代器" class="sidebar-link reco-side-_1-2-2-迭代器" data-v-70334359>1.2.2 迭代器</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-3-function-like-classes" class="sidebar-link reco-side-_1-3-function-like-classes" data-v-70334359>1.3 function-like classes</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-4-namespace-经验谈" class="sidebar-link reco-side-_1-4-namespace-经验谈" data-v-70334359>1.4 namespace 经验谈</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-模板" class="sidebar-link reco-side-_1-5-模板" data-v-70334359>1.5 模板</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-1-class-template-类模板" class="sidebar-link reco-side-_1-5-1-class-template-类模板" data-v-70334359>1.5.1 class template（类模板）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-2-function-template-函数模板" class="sidebar-link reco-side-_1-5-2-function-template-函数模板" data-v-70334359>1.5.2 function template（函数模板）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-3-member-template-成员模板" class="sidebar-link reco-side-_1-5-3-member-template-成员模板" data-v-70334359>1.5.3 member template（成员模板）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-3-specialization-模板特化" class="sidebar-link reco-side-_1-5-3-specialization-模板特化" data-v-70334359>1.5.3 specialization（模板特化）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-3-partial-specialization-模板偏特化" class="sidebar-link reco-side-_1-5-3-partial-specialization-模板偏特化" data-v-70334359>1.5.3 partial specialization（模板偏特化）</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-5-4-template-template-parameter-模板的模板参数" class="sidebar-link reco-side-_1-5-4-template-template-parameter-模板的模板参数" data-v-70334359>1.5.4 template template parameter（模板的模板参数）</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_1-6-c-标准库" class="sidebar-link reco-side-_1-6-c-标准库" data-v-70334359>1.6 C++ 标准库</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_2-1-variadic-templates-可变模板参数" class="sidebar-link reco-side-_2-1-variadic-templates-可变模板参数" data-v-70334359>2.1 variadic templates（可变模板参数）</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_2-2-auto" class="sidebar-link reco-side-_2-2-auto" data-v-70334359>2.2 auto</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_2-3-ranged-base-for" class="sidebar-link reco-side-_2-3-ranged-base-for" data-v-70334359>2.3 ranged-base for</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_2-4-reference" class="sidebar-link reco-side-_2-4-reference" data-v-70334359>2.4 reference</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_3-1-复合-继承关系下的构造和析构" class="sidebar-link reco-side-_3-1-复合-继承关系下的构造和析构" data-v-70334359>3.1 复合&amp;继承关系下的构造和析构</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_3-2-关于-vptr-虚指针-和-vtbl-虚表" class="sidebar-link reco-side-_3-2-关于-vptr-虚指针-和-vtbl-虚表" data-v-70334359>3.2 关于 vptr（虚指针）和 vtbl（虚表）</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_3-3-关于-this" class="sidebar-link reco-side-_3-3-关于-this" data-v-70334359>3.3 关于 this</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#image-png-images-1671867999023-7afb44a3-a4e8-4dac-a975-0f3a04a388c7-png" class="sidebar-link reco-side-image-png-images-1671867999023-7afb44a3-a4e8-4dac-a975-0f3a04a388c7-png" data-v-70334359>!image.png</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_3-4-关于动态绑定" class="sidebar-link reco-side-_3-4-关于动态绑定" data-v-70334359>3.4 关于动态绑定</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-1-谈谈-const" class="sidebar-link reco-side-_4-1-谈谈-const" data-v-70334359>4.1 谈谈 const</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#-2" class="sidebar-link reco-side--2" data-v-70334359>!image.png</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-2-关于-new、delete" class="sidebar-link reco-side-_4-2-关于-new、delete" data-v-70334359>4.2 关于 new、delete</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-3-重载-operator-new-operator-delete" class="sidebar-link reco-side-_4-3-重载-operator-new-operator-delete" data-v-70334359>4.3 重载 operator new，operator delete</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-3-1-全局重载-operator-new-operator-delete-operator-new-operator-delete" class="sidebar-link reco-side-_4-3-1-全局重载-operator-new-operator-delete-operator-new-operator-delete" data-v-70334359>4.3.1 全局重载 ::operator new, ::operator delete, :: operator new[], ::operator delete[]</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-3-2-重载-member-operator-new-delete" class="sidebar-link reco-side-_4-3-2-重载-member-operator-new-delete" data-v-70334359>4.3.2 重载 member operator new/delete</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-3-3-重载-member-operator-new-delete" class="sidebar-link reco-side-_4-3-3-重载-member-operator-new-delete" data-v-70334359>4.3.3 重载 member operator new[] / delete[]</a></li><li class="level-3" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-3-4-接口示例" class="sidebar-link reco-side-_4-3-4-接口示例" data-v-70334359>4.3.4 接口示例</a></li><li class="level-2" data-v-70334359><a href="/blogs/xue-xi-bi-ji/2023/020302.html#_4-4-重载-new-delete" class="sidebar-link reco-side-_4-4-重载-new-delete" data-v-70334359>4.4 重载 new()，delete()</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----></div></div>
    <script src="/assets/js/app.6240a449.js" defer></script><script src="/assets/js/8.9d998bdf.js" defer></script><script src="/assets/js/1.c70aaa24.js" defer></script><script src="/assets/js/7.4db18221.js" defer></script><script src="/assets/js/18.7965e7af.js" defer></script>
  </body>
</html>
